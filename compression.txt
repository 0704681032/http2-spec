



HTTPbis Working Group                                            R. Peon
Internet-Draft                                               Google, Inc
Intended status: Informational                                H. Ruellan
Expires: April 19, 2014                                        Canon CRF
                                                        October 16, 2013


                HPACK - Header Compression for HTTP/2.0
              draft-ietf-httpbis-header-compression-latest

Abstract

   This document describes HPACK, a format adapted to efficiently
   represent HTTP header fields in the context of HTTP/2.0.

Editorial Note (To be removed by RFC Editor)

   Discussion of this draft takes place on the HTTPBIS working group
   mailing list (ietf-http-wg@w3.org), which is archived at [1].

   Working Group information and related documents can be found at [2]
   (Wiki) and [3] (source code and issues tracker).

   The changes in this draft are summarized in Appendix A.1.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on April 19, 2014.

Copyright Notice

   Copyright (c) 2013 IETF Trust and the persons identified as the
   document authors.  All rights reserved.





Peon & Ruellan           Expires April 19, 2014                 [Page 1]

Internet-Draft                   HPACK                      October 2013


   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Overview  . . . . . . . . . . . . . . . . . . . . . . . . . .   3
     2.1.  Outline . . . . . . . . . . . . . . . . . . . . . . . . .   3
   3.  Header Field Encoding . . . . . . . . . . . . . . . . . . . .   4
     3.1.  Encoding Concepts . . . . . . . . . . . . . . . . . . . .   4
       3.1.1.  Encoding Context  . . . . . . . . . . . . . . . . . .   5
       3.1.2.  Header Table  . . . . . . . . . . . . . . . . . . . .   5
       3.1.3.  Reference Set . . . . . . . . . . . . . . . . . . . .   5
       3.1.4.  Header Field Representation . . . . . . . . . . . . .   6
       3.1.5.  Header Field Emission . . . . . . . . . . . . . . . .   7
     3.2.  Header Block Decoding . . . . . . . . . . . . . . . . . .   7
       3.2.1.  Header Field Representation Processing  . . . . . . .   7
       3.2.2.  Reference Set Emission  . . . . . . . . . . . . . . .   8
       3.2.3.  Header Set Completion . . . . . . . . . . . . . . . .   8
     3.3.  Header Table Management . . . . . . . . . . . . . . . . .   8
       3.3.1.  Maximum Table Size  . . . . . . . . . . . . . . . . .   8
       3.3.2.  Entry Eviction  . . . . . . . . . . . . . . . . . . .   8
       3.3.3.  Entry Addition  . . . . . . . . . . . . . . . . . . .   9
   4.  Detailed Format . . . . . . . . . . . . . . . . . . . . . . .   9
     4.1.  Low-level representations . . . . . . . . . . . . . . . .   9
       4.1.1.  Integer representation  . . . . . . . . . . . . . . .   9
       4.1.2.  String Literal Representation . . . . . . . . . . . .  11
     4.2.  Indexed Header Field Representation . . . . . . . . . . .  11
     4.3.  Literal Header Field Representation . . . . . . . . . . .  11
       4.3.1.  Literal Header Field without Indexing . . . . . . . .  12
       4.3.2.  Literal Header Field with Incremental Indexing  . . .  13
   5.  Security Considerations . . . . . . . . . . . . . . . . . . .  13
   6.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  14
     6.1.  Normative References  . . . . . . . . . . . . . . . . . .  14
     6.2.  Informative References  . . . . . . . . . . . . . . . . .  14
   Appendix A.  Change Log (to be removed by RFC Editor before
                publication  . . . . . . . . . . . . . . . . . . . .  15
     A.1.  Since draft-ietf-httpbis-header-compression-03  . . . . .  15
     A.2.  Since draft-ietf-httpbis-header-compression-02  . . . . .  15
     A.3.  Since draft-ietf-httpbis-header-compression-01  . . . . .  15
     A.4.  Since draft-ietf-httpbis-header-compression-01  . . . . .  16



Peon & Ruellan           Expires April 19, 2014                 [Page 2]

Internet-Draft                   HPACK                      October 2013


   Appendix B.  Static Table . . . . . . . . . . . . . . . . . . . .  16
   Appendix C.  Example  . . . . . . . . . . . . . . . . . . . . . .  18
     C.1.  First header set  . . . . . . . . . . . . . . . . . . . .  18
     C.2.  Second header set . . . . . . . . . . . . . . . . . . . .  19
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  21

1.  Introduction

   This document describes HPACK, a format adapted to efficiently
   represent HTTP header fields in the context of HTTP/2.0 (see
   [HTTP2]).

2.  Overview

   In HTTP/1.X, header fields are sent without any form of compression.
   As web pages have grown to include dozens to hundreds of requests,
   the redundant header fields in these requests now pose a problem of
   measurable latency and unnecessary bandwidth (see [PERF1] and
   [PERF2]).

   SPDY [SPDY] initially addressed this redundancy by compressing header
   fields with Deflate, which proved very effective at eliminating the
   redundant header fields.  However, that aproach exposed a security
   risk as demonstrated by the CRIME [CRIME].

   In this document, we propose a new compressor for headers which
   eliminates redundant headers, is not vulnerable to CRIME style
   attacks, and which also has a bounded memory cost for use in
   constrained environments.

2.1.  Outline

   The HTTP header field encoding described in this document is based on
   a header table that map (name, value) pairs to index values.  Header
   tables are incrementally updated during the HTTP/2.0 session.

   The encoder is responsible for deciding which header fields to insert
   as new entries in the header table.  The decoder then does exactly
   what the encoder prescribes, ending in a state that exactly matches
   the encoder's state.  This enables decoders to remain simple and
   understand a wide variety of encoders.

   As two consecutive sets of header fields often have header fields in
   common, each set of header fields is coded as a difference from the
   previous set of header fields.  The goal is to only encode the
   changes (header fields present in one of the set and not in the
   other) between the two sets of header fields.




Peon & Ruellan           Expires April 19, 2014                 [Page 3]

Internet-Draft                   HPACK                      October 2013


   An example illustrating the use of these different mechanisms to
   represent header fields is available in Appendix C.

3.  Header Field Encoding

3.1.  Encoding Concepts

   The encoding and decoding of headers relies on some components and
   concepts:

   Header Field  A key, value-list pair where the value-list is a NULL
      separated ordered list of values.

   Header Table:  The header table (see Section 3.1.2) is a component
      used to associate stored header fields to index values.  The data
      stored in this table is in first-in, first-out order.

   Static Table:  The static table (see Appendix B) is a component used
      to associate static header fields to index values.  This data is
      ordered, read-only, always accessible, and may be shared amongst
      all encoding contexts.

   Reference Set:  The reference set (see Section 3.1.3) is a component
      containing an unordered set of references to entries in the header
      table or static table.  This is used for the differential encoding
      of a new header set.

   Header Set:  A header set is a potentially ordered group of header
      fields that are encoded jointly.  A complete set of key-value
      pairs as encoded in a HTTP request or response is a header set.

   Header Representation:  A header can be represented in encoded form
      either as a literal or as an index (see Section 3.1.4).

   Header Block:  The entire set of encoded header representations
      which, when decoded, yield a complete header set.

   Header Field Emission:  When decoding a set of header
      representations, some operations emit a header field (see
      Section 3.1.5).  All emitted header fields which are considered to
      be part of the same header set comprise an HTTP request or
      response.









Peon & Ruellan           Expires April 19, 2014                 [Page 4]

Internet-Draft                   HPACK                      October 2013


3.1.1.  Encoding Context

   The set of mutable structures used within an encoding context include
   a header table and a reference set.  Everything else is either
   immutable or conceptual.

   Using HTTP, messages are exchanged between a client and a server in
   both direction.  To keep the encoding of header fields in each
   direction independent from the other direction, there is one encoding
   context for each direction.

   The header fields contained in a PUSH_PROMISE frame sent by a server
   to a client are encoded within the same context as the header fields
   contained in the HEADERS frame corresponding to a response sent from
   the server to the client.

3.1.2.  Header Table

   A header table consists of a list of header fields maintained in
   first-in, first-out order.  The first and newest entry in a header
   table is always at index 0, and the oldest entry of a header table is
   at the index len(header table)-1.

   The header table is initially empty.

   There is typically no need for the header table to contain duplicate
   entries.  However, duplicate entries MUST NOT be treated as an error
   by a decoder.

   The encoder decides how to update the header table and as such can
   control how much memory is used by the header table.  To limit the
   memory requirements on the decoder side, the header table size is
   strictly bounded (see Section 3.3.1).

   The header table is updated during the processing of a set of header
   representations (see header representation processing
   (Section 3.2.1).

3.1.3.  Reference Set

   A reference set is an unordered set of references to entries either
   within the header table or the static table.

   The reference set is initially empty.

   The reference set is updated during the processing of a set of header
   representations (see header representation processing
   (Section 3.2.1).



Peon & Ruellan           Expires April 19, 2014                 [Page 5]

Internet-Draft                   HPACK                      October 2013


   The reference set enables differential encoding, whereby only
   differences between the previous header set and the current header
   set need to be encoded.

3.1.4.  Header Field Representation

   A header field can be represented either as a literal or as an index.

   Literal Representation:  A literal representation defines a new
      header field.  The header field name is represented either
      literally or as a reference to an entry of the header table.  The
      header field value is represented literally.

      Two different literal representations are provided:

      *  A literal representation that does not add the header field to
         the header table (see Section 4.3.1).

      *  A literal representation that adds the header field as a new
         entry at the beginning of the header table (see Section 4.3.2).

   Indexed Representation:  The indexed representation defines a header
      field as a reference in the header table (see Section 4.2).

         Indices between 0 and len(header table)-1, inclusive, refer to
         elements in the header table, with index 0 referring to the
         beginning of the table.

         Indices between len(header table) and len(header
         table)+len(static table)-1, inclusive, refer to elements in the
         static table, where the index len(header table) refers to the
         first entry in the static table.

         Any other indices MUST be treated as erroneous, and the
         compression context considered corrupt and unusable.




          <----------  Index Address Space ---------->
          <-- Header  Table -->  <-- Static  Table -->
          +---+-----------+---+  +---+-----------+---+
          | 0 |    ...    | k |  |k+1|    ...    | n |
          +---+-----------+---+  +---+-----------+---+
          ^                   |
          |                   V
   Insertion Point       Drop Point




Peon & Ruellan           Expires April 19, 2014                 [Page 6]

Internet-Draft                   HPACK                      October 2013


                            Index Address Space

3.1.5.  Header Field Emission

   The emission of header field is the process of passing that header
   field to the application, so that the application can process and
   react to header field data.

   By emitting headers instead of emitting header sets, the decoder may
   be implemented in a streaming way, and as such must only keep in
   memory the header table and the reference set.  This bounds the
   amount of memory used by the decoder, even in presence of a very
   large set of header fields.  The management of memory for handling
   very large sets of header fields can therefore be deferred to the
   application.

   When a header field includes a value-list which has a NULL, each
   value within the value-list may be emitted with the name separately
   in the order in which it appears in the value-list.

3.2.  Header Block Decoding

   The processing of a header block to obtain a header set is defined in
   this section.  To ensure that the decoding will successfully produce
   a header set, a decoder MUST obey the following rules.

3.2.1.  Header Field Representation Processing

   All the header field representations contained in a header block are
   processed in the order in which they are presented, as specified
   below.

   An _indexed representation_ corresponding to an entry _not present_
   in the reference set entails the following actions:

   o  A reference to the entry is added to the reference set.

   o  The header field corresponding to the entry is emitted.

   An _indexed representation_ corresponding to an entry _present_ in
   the reference set entails the following actions:

   o  The reference to the entry is removed from the reference set.

   A _literal representation_ that is _not added_ to the header table
   entails the following action:

   o  The header field is emitted.



Peon & Ruellan           Expires April 19, 2014                 [Page 7]

Internet-Draft                   HPACK                      October 2013


   A _literal representation_ that is _added_ to the header table
   entails the following actions:

   o  The header field is inserted at the beginning of the header table.

   o  A reference to the new entry is added to the reference set.

   o  The header is emitted.

3.2.2.  Reference Set Emission

   Once all the representations contained in a header block have been
   processed, the header fields referenced in the reference set which
   have not previously been emitted during this processing are emitted.

3.2.3.  Header Set Completion

   Once all of the header field representations have been processed, and
   the remaining items in the reference set have been emitted, the
   header set is complete.

3.3.  Header Table Management

3.3.1.  Maximum Table Size

   To limit the memory requirements on the decoder side, the size of the
   the header table is bounded.  The size of the header table MUST stay
   lower than or equal to the value of the HTTP/2.0 setting
   SETTINGS_HEADER_TABLE_SIZE (see [HTTP2]).

   The size of the the header table is the sum of the size of its
   entries.

   The size of an entry is the sum of its name's length in bytes (as
   defined in Section 4.1.2), of its value's length in bytes
   (Section 4.1.2) and of 32 bytes.  The 32 bytes are an accounting for
   the entry structure overhead.  For example, an entry structure using
   two 64-bits pointers to reference the name and the value and the
   entry, and two 64-bits integer for counting the number of references
   to these name and value would use 32 bytes.

3.3.2.  Entry Eviction

   Whenever an entry is evicted from the header table, any reference to
   that entry contained by the reference set is removed.






Peon & Ruellan           Expires April 19, 2014                 [Page 8]

Internet-Draft                   HPACK                      October 2013


   Whenever SETTINGS_HEADER_TABLE_SIZE is made smaller, entries are
   evicted from the end of the header table until the size of the header
   table is less than or equal to SETTINGS_HEADER_TABLE_SIZE.

   The eviction of an entry from the header table causes the index of
   the entries in the static table to be reduced by one.

3.3.3.  Entry Addition

   Whenever a new entry is to be added to the table, entries are first
   evicted from the end of the header table until the size of the header
   table is less than or equal to SETTINGS_HEADER_TABLE_SIZE - new entry
   size, or until the table is empty.

   If the size of the new entry is less than or equal to
   SETTINGS_HEADER_TABLE_SIZE, that entry is added to the table.  It is
   not an error to attempt to add an entry that is larger than
   SETTINGS_HEADER_TABLE_SIZE.

4.  Detailed Format

4.1.  Low-level representations

4.1.1.  Integer representation

   Integers are used to represent name indexes, pair indexes or string
   lengths.  To allow for optimized processing, an integer
   representation always finishes at the end of a byte.

   An integer is represented in two parts: a prefix that fills the
   current byte and an optional list of bytes that are used if the
   integer value does not fit in the prefix.  The number of bits of the
   prefix (called N) is a parameter of the integer representation.

   The N-bit prefix allows filling the current byte.  If the value is
   small enough (strictly less than 2^N-1), it is encoded within the
   N-bit prefix.  Otherwise all the bits of the prefix are set to 1 and
   the value is encoded using an unsigned variable length integer [4]
   representation.

   The algorithm to represent an integer I is as follows:

   If I < 2^N - 1, encode I on N bits
   Else
       encode 2^N - 1 on N bits
       I = I - (2^N - 1)
       While I >= 128
            Encode (I % 128 + 128) on 8 bits



Peon & Ruellan           Expires April 19, 2014                 [Page 9]

Internet-Draft                   HPACK                      October 2013


            I = I / 128
       encode (I) on 8 bits


4.1.1.1.  Example 1: Encoding 10 using a 5-bit prefix

   The value 10 is to be encoded with a 5-bit prefix.

   o  10 is less than 31 (= 2^5 - 1) and is represented using the 5-bit
      prefix.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | X | X | X | 0 | 1 | 0 | 1 | 0 |   10 stored on 5 bits
   +---+---+---+---+---+---+---+---+


4.1.1.2.  Example 2: Encoding 1337 using a 5-bit prefix

   The value I=1337 is to be encoded with a 5-bit prefix.

      1337 is greater than 31 (= 2^5 - 1).



         The 5-bit prefix is filled with its max value (31).

      I = 1337 - (2^5 - 1) = 1306.



         I (1306) is greater than or equal to 128, the while loop body
         executes:



            I % 128 == 26

            26 + 128 == 154

            154 is encoded in 8 bits as: 10011010

            I is set to 10 (1306 / 128 == 10)

            I is no longer greater than or equal to 128, the while loop
            terminates.

         I, now 10, is encoded on 8 bits as: 00001010



Peon & Ruellan           Expires April 19, 2014                [Page 10]

Internet-Draft                   HPACK                      October 2013


      The process ends.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | X | X | X | 1 | 1 | 1 | 1 | 1 |  Prefix = 31, I = 1306
   | 1 | 0 | 0 | 1 | 1 | 0 | 1 | 0 |  1306>=128, encode(154), I=1306/128
   | 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 |  10<128, encode(10), done
   +---+---+---+---+---+---+---+---+


4.1.2.  String Literal Representation

   Header field names and header field values are encoded as sequences
   of bytes.  A header field name or a header field value is encoded in
   two parts:

   1.  The number of bytes in the sequence, represented as a variable-
       length-quantity (Section 4.1.1).

   2.  The sequence of bytes representing the header field name or
       value.

4.2.  Indexed Header Field Representation

   An indexed header representation either identifies an entry in the
   header table or static table.  The specified entry is emitted and a
   reference to that entry is added to the reference set if it is not
   currently in the reference set.  If it is present in the reference
   set then the reference is removed and the entry is not emitted.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1 |        Index (7+)         |
   +---+---------------------------+

                              Indexed Header

   This representation starts with the '1' 1-bit pattern, followed by
   the index of the matching pair, represented as an integer with a
   7-bit prefix.

4.3.  Literal Header Field Representation

   Literal header field representations contain a literal header field
   value.  Header field names are either provided as a literal or by
   reference to an existing header table entry.





Peon & Ruellan           Expires April 19, 2014                [Page 11]

Internet-Draft                   HPACK                      October 2013


   Literal representations all result in the emission of a header field
   when decoded.

4.3.1.  Literal Header Field without Indexing

   A literal header field without indexing causes the emission of a
   header field without altering the header table.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 1 |      Index (6+)       |
   +---+---+---+-------------------+
   |       Value Length (8+)       |
   +-------------------------------+
   | Value String (Length octets)  |
   +-------------------------------+

           Literal Header Field without Indexing - Indexed Name

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 1 |           0           |
   +---+---+---+-------------------+
   |       Name Length (8+)        |
   +-------------------------------+
   |  Name String (Length octets)  |
   +-------------------------------+
   |       Value Length (8+)       |
   +-------------------------------+
   | Value String (Length octets)  |
   +-------------------------------+

             Literal Header Field without Indexing - New Name

   This representation starts with the '01' 2-bit pattern.

   If the header name matches the header name of a (name, value) pair
   stored in the Header Table or Static Table, the index of that entry,
   increased by one (index + 1), is represented as an integer with a
   6-bit prefix.  Note that if the index is strictly below 63, only one
   byte is used for this representation.

   If the header field name does not match a header field name entry,
   the value 0 is represented on 6 bits followed by the header field
   name (Section 4.1.2).

   The header field name representation is followed by the header field
   value represented as a literal string as described in Section 4.1.2.



Peon & Ruellan           Expires April 19, 2014                [Page 12]

Internet-Draft                   HPACK                      October 2013


4.3.2.  Literal Header Field with Incremental Indexing

   A literal header field with incremental indexing adds a new entry to
   the header table.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 0 |      Index (6+)       |
   +---+---+---+-------------------+
   |       Value Length (8+)       |
   +-------------------------------+
   | Value String (Length octets)  |
   +-------------------------------+

       Literal Header Field with Incremental Indexing - Indexed Name

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 0 |           0           |
   +---+---+---+-------------------+
   |       Name Length (8+)        |
   +-------------------------------+
   |  Name String (Length octets)  |
   +-------------------------------+
   |       Value Length (8+)       |
   +-------------------------------+
   | Value String (Length octets)  |
   +-------------------------------+

         Literal Header Field with Incremental Indexing - New Name

   This representation starts with the '00' 2-bit pattern.

   If the header name matches the header name of a (name, value) pair
   stored in the header table or static table, the index of the pair
   increased by one (index + 1) is represented as an integer with a
   6-bit prefix.

   If the header field name does not match a header field name entry,
   the value 0 is represented on 6 bits followed by the header field
   name (Section 4.1.2).

   The header field name representation is followed by the header field
   value represented as a literal string as described in Section 4.1.2.

5.  Security Considerations





Peon & Ruellan           Expires April 19, 2014                [Page 13]

Internet-Draft                   HPACK                      October 2013


   This compressor exists to solve security issues present in stream
   compressors such as DEFLATE whereby the compression context can be
   efficiently probed to reveal secrets.  A conformant implementation of
   this specification should be fairly safe against that kind of attack,
   as the reaping of any information from the compression context
   requires more work than guessing and verifying the plaintext data
   directly with the server.  As with any secret, however, the longer
   the length of the secret, the more difficult the secret is to guess.
   It is inadvisable to have short cookies that are relied upon to
   remain secret for any duration of time.

   A proper security-conscious implementation will also need to prevent
   timing attacks by ensuring that the amount of time it takes to do
   string comparisons is always a function of the total length of the
   strings, and not a function of the number of matched characters.

   Another common security problem is when the remote endpoint
   successfully causes the local endpoint to exhaust its memory.  This
   compressor attempts to deal with the most obvious ways that this
   could occur by limiting both the peak and the steady-state amount of
   memory consumed in the compressor state, by providing ways for the
   application to consume/flush the emitted header fields in small
   chunks, and by considering overhead in the state size calculation.
   Implementors must still be careful in the creation of APIs to an
   implementation of this compressor by ensuring that header field keys
   and values are either emitted as a stream, or that the compression
   implementation have a limit on the maximum size of a key or value.
   Failure to implement these kinds of safeguards may still result in a
   scenario where the local endpoint exhausts its memory.

6.  References

6.1.  Normative References

   [HTTP2]    Belshe, M., Peon, R., Thomson, M., and A. Melnikov,
              "Hypertext Transfer Protocol version 2.0", draft-ietf-
              httpbis-http2-06 (work in progress), August 2013.

6.2.  Informative References

   [CRIME]    Rizzo, J. and T. Duong, "The Crime Attack", September
              2012, <https://docs.google.com/a/twist.com/presentation/d/
              11eBmGiHbYcHR9gL5nDyZChu_-lCa2GizeuOfaLU2HOU/
              edit#slide=id.g1eb6c1b5_3_6>.

   [PERF1]    Belshe, M., "IETF83: SPDY and What to Consider for HTTP/
              2.0", March 2012, <http://www.ietf.org/proceedings/83/
              slides/slides-83-httpbis-3>.



Peon & Ruellan           Expires April 19, 2014                [Page 14]

Internet-Draft                   HPACK                      October 2013


   [PERF2]    McManus, P., "SPDY: What I Like About You", September
              2011, <http://bitsup.blogspot.com/2011/09/spdy-what-i
              -like-about-you.html>.

   [SPDY]     Belshe, M. and R. Peon, "SPDY Protocol", February 2012,
              <http://tools.ietf.org/html/draft-mbelshe-httpbis-spdy>.

Appendix A.  Change Log (to be removed by RFC Editor before publication

A.1.  Since draft-ietf-httpbis-header-compression-03

   o  A large number of editorial changes; changed the description of
      evicting/adding new entries.

   o  Removed substitution indexing

   o  Changed 'initial headers' to 'static headers', as per issue #258

   o  Merged 'request' and 'response' static headers, as per issue #259

   o  Changed text to indicate that new headers are added at index 0 and
      expire from the largest index, as per issue #233

A.2.  Since draft-ietf-httpbis-header-compression-02

   o  Corrected error in integer encoding pseudocode.

A.3.  Since draft-ietf-httpbis-header-compression-01

   o  Refactored of Header Encoding Section: split definitions and
      processing rule.

   o  Backward incompatible change: Updated reference set management as
      per issue #214.  This changes how the interaction between the
      reference set and eviction works.  This also changes the working
      of the reference set in some specific cases.

   o  Backward incompatible change: modified initial header list, as per
      issue #188.

   o  Added example of 32 bytes entry structure (issue #191).










Peon & Ruellan           Expires April 19, 2014                [Page 15]

Internet-Draft                   HPACK                      October 2013


   o  Added Header Set Completion section.  Reflowed some text.
      Clarified some writing which was akward.  Added text about
      duplicate header entry encoding.  Clarified some language w.r.t
      Header Set.  Changed x-my-header to mynewheader.  Added text in
      the HeaderEmission section indicating that the application may
      also be able to free up memory more quickly.  Added information in
      Security Considerations section.

A.4.  Since draft-ietf-httpbis-header-compression-01

      Fixed bug/omission in integer representation algorithm.

      Changed the document title.

      Header matching text rewritten.

      Changed the definition of header emission.

      Changed the name of the setting which dictates how much memory the
      compression context should use.

      Removed "specific use cases" section

      Corrected erroneous statement about what index can be contained in
      one byte

      Added descriptions of opcodes

      Removed security claims from introduction.

Appendix B.  Static Table

   The static table consists of an unchangable ordered list of (name,
   value) pairs.  The first entry in the table is always represented by
   the index len(header table), and the last entry in the table is
   represented by the index len(header table)+len(static table)-1.

   [[The ordering of these tables is currently arbitrary.  The tables in
   this section should be updated and ordered such that the table
   entries with the smallest indices are those which, based on a
   statistical analysis of the frequency of use weighted by size,
   achieve the largest decrease in bytes transmitted subject to HTTP 2.0
   header rules (like removal of some headers).  This set of headers is
   currently very likely incomplete, and should be made complete.  ]]

   The following table lists the pre-defined header fields that make-up
   the static header table.




Peon & Ruellan           Expires April 19, 2014                [Page 16]

Internet-Draft                   HPACK                      October 2013


          +-------+-----------------------------+--------------+
          | Index | Header Name                 | Header Value |
          +-------+-----------------------------+--------------+
          | 0     | :host                       |              |
          | 1     | :method                     | GET          |
          | 2     | :method                     | POST         |
          | 3     | :path                       | /            |
          | 4     | :path                       | /index.html  |
          | 5     | :scheme                     | http         |
          | 6     | :scheme                     | https        |
          | 7     | :status                     | 200          |
          | 8     | :status                     | 500          |
          | 9     | :status                     | 404          |
          | 10    | :status                     | 403          |
          | 11    | :status                     | 400          |
          | 12    | :status                     | 401          |
          | 13    | accept-charset              |              |
          | 14    | accept-encoding             |              |
          | 15    | accept-language             |              |
          | 16    | accept-ranges               |              |
          | 17    | accept                      |              |
          | 18    | access-control-allow-origin |              |
          | 19    | age                         |              |
          | 20    | allow                       |              |
          | 21    | authorization               |              |
          | 22    | cache-control               |              |
          | 23    | content-disposition         |              |
          | 24    | content-encoding            |              |
          | 25    | content-language            |              |
          | 26    | content-length              |              |
          | 27    | content-location            |              |
          | 28    | content-range               |              |
          | 29    | content-type                |              |
          | 30    | cookie                      |              |
          | 31    | date                        |              |
          | 32    | etag                        |              |
          | 33    | expect                      |              |
          | 34    | expires                     |              |
          | 35    | from                        |              |
          | 36    | if-match                    |              |
          | 37    | if-modified-since           |              |
          | 38    | if-none-match               |              |
          | 39    | if-range                    |              |
          | 40    | if-unmodified-since         |              |
          | 41    | last-modified               |              |
          | 42    | link                        |              |
          | 43    | location                    |              |
          | 44    | max-forwards                |              |



Peon & Ruellan           Expires April 19, 2014                [Page 17]

Internet-Draft                   HPACK                      October 2013


          | 45    | proxy-authenticate          |              |
          | 46    | proxy-authorization         |              |
          | 47    | range                       |              |
          | 48    | referer                     |              |
          | 49    | refresh                     |              |
          | 50    | retry-after                 |              |
          | 51    | server                      |              |
          | 52    | set-cookie                  |              |
          | 53    | strict-transport-security   |              |
          | 54    | transfer-encoding           |              |
          | 55    | user-agent                  |              |
          | 56    | vary                        |              |
          | 57    | via                         |              |
          | 58    | www-authenticate            |              |
          +-------+-----------------------------+--------------+

                       Table 1: Static Table Entries

   The table give the index of each entry in the static table.  The full
   index of each entry, to be used for encoding a reference to this
   entry, is computed by adding the number of entries in the header
   table to this index.

Appendix C.  Example

   Here is an example that illustrates different representations and how
   tables are updated.  [[This section needs to be updated to better
   reflect the new processing of header fields, and include more
   examples.]]

C.1.  First header set

   The first header set to represent is the following:

   :path, /my-example/index.html
   user-agent, my-user-agent
   mynewheader, first


   The header table is empty, all header fields are represented as
   literal header fields with indexing.  The 'mynewheader' header field
   name is not in the header table and is encoded literally.  This gives
   the following representation:

   0x04      (literal header with incremental indexing, name index = 3)
   0x16      (header field value string length = 22)
   /my-example/index.html
   0x0D      (literal header with incremental indexing, name index = 12)



Peon & Ruellan           Expires April 19, 2014                [Page 18]

Internet-Draft                   HPACK                      October 2013


   0x0D      (header field value string length = 13)
   my-user-agent
   0x00      (literal header with incremental indexing, new name)
   0x0B      (header field name string length = 11)
   mynewheader
   0x05      (header field value string length = 5)
   first


   The header table is as follows after the processing of these header
   fields:

   Header table
   +---------+----------------+---------------------------+
   |  Index  | Header Name    | Header Value              |
   +---------+----------------+---------------------------+
   |    0    | mynewheader    | first                     | added header
   +---------+----------------+---------------------------+
   |    1    | user-agent     | my-user-agent             | added header
   +---------+----------------+---------------------------+
   |    2    | :path          | /my-example/index.html    | added header
   +---------+----------------+---------------------------+
   |    3    | :scheme        | http                      |
   +---------+----------------+---------------------------+
   |    4    | :scheme        | https                     |
   +---------+----------------+---------------------------+
   |   ...   | ...            | ...                       |
   +---------+----------------+---------------------------+
   |   32    | via            |                           |
   +---------+----------------+---------------------------+


   As all the header fields in the first header set are indexed in the
   header table, all are kept in the reference set of header fields,
   which is:

   Reference Set:
   :path, /my-example/index.html
   user-agent, my-user-agent
   mynewheader, first


C.2.  Second header set

   The second header set to represent is the following:

   :path, /my-example/resources/script.js
   user-agent, my-user-agent



Peon & Ruellan           Expires April 19, 2014                [Page 19]

Internet-Draft                   HPACK                      October 2013


   mynewheader, second


   Comparing this second header set to the reference set, the first and
   third header fields are from the reference set are not present in
   this second header set and must be removed.  In addition, in this new
   set, the first and third header fields have to be encoded.  The path
   header field is represented as a literal header field without
   indexing.  The mynewheader will be represented as a literal header
   field with incremental indexing.

   0x80       (indexed header, index = 0: removal from reference set)
   0x82       (indexed header, index = 2: removal from reference set)
   0x43       (literal header, without indexing, name index = 2)
   0x1f       (header field value string length = 31)
   /my-example/resources/script.js
   0x01       (literal header, incremental indexing, name index = 0)
   0x06       (header field value string length = 6)
   second


   The header table is updated as follow:

   Header table
   +---------+----------------+---------------------------+
   |  Index  | Header Name    | Header Value              |
   +---------+----------------+---------------------------+
   |    0    | mynewheader    | second                    | added header
   +---------+----------------+---------------------------+
   |    1    | mynewheader    | first                     |
   +---------+----------------+---------------------------+
   |    2    | user-agent     | my-user-agent             |
   +---------+----------------+---------------------------+
   |    3    | :path          | /my-example/index.html    |
   +---------+----------------+---------------------------+
   |    4    | :scheme        | http                      |
   +---------+----------------+---------------------------+
   |    5    | :scheme        | https                     |
   +---------+----------------+---------------------------+
   |   ...   | ...            | ...                       |
   +---------+----------------+---------------------------+
   |   33    | via            |                           |
   +---------+----------------+---------------------------+


   All the header fields in this second header set are indexed in the
   header table, therefore, all are kept in the reference set of header
   fields, which becomes:



Peon & Ruellan           Expires April 19, 2014                [Page 20]

Internet-Draft                   HPACK                      October 2013


   Reference Set:
   :path, /my-example/resources/script.js
   user-agent, my-user-agent
   mynewheader, second


Authors' Addresses

   Roberto Peon
   Google, Inc

   EMail: fenix@google.com


   Herve Ruellan
   Canon CRF

   EMail: herve.ruellan@crf.canon.fr
































Peon & Ruellan           Expires April 19, 2014                [Page 21]
