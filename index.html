<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en">
   <head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>Hypertext Transfer Protocol version 2.0</title><script>
var buttonsAdded = false;

function init() {
  var fb = document.createElement("div");
  fb.className = "feedback noprint";
  fb.setAttribute("onclick", "feedback();");
  fb.appendChild(document.createTextNode("feedback"));

  var bodyl = document.getElementsByTagName("body");
  bodyl.item(0).appendChild(fb);
}

function feedback() {
  toggleButtonsToElementsByName("h1");
  toggleButtonsToElementsByName("h2");
  toggleButtonsToElementsByName("h3");
  toggleButtonsToElementsByName("h4");

  buttonsAdded = !buttonsAdded;
}

function toggleButtonsToElementsByName(name) {
  var list = document.getElementsByTagName(name);
  for (var i = 0; i < list.length; i++) {
    toggleButton(list.item(i));
  }
}

function toggleButton(node) {
  if (! buttonsAdded) {

    // docname
    var template = "mailto:ietf-http-wg@w3.org?subject={docname},%20%22{section}%22&body=<{ref}>:";

    var id = node.getAttribute("id");
    // better id available?
    var titlelinks = node.getElementsByTagName("a");
    for (var i = 0; i < titlelinks.length; i++) {
      var tl = titlelinks.item(i);
      if (tl.getAttribute("id")) {
        id = tl.getAttribute("id");
      }
    }

    // ref
    var ref = window.location.toString();
    var hash = ref.indexOf("#");
    if (hash != -1) {
      ref = ref.substring(0, hash);
    }
    if (id != "") {
      ref += "#" + id;
    }

    // docname
    var docname = "draft-ietf-httpbis-http2-latest";

    // section
    var section = node.textContent;
    section = section.replace("\u00a0", " ");

    // build URI from template
    var uri = template.replace("{docname}", encodeURIComponent(docname));
    uri = uri.replace("{section}", encodeURIComponent(section));
    uri = uri.replace("{ref}", encodeURIComponent(ref));

    var button = document.createElement("a");
    button.className = "fbbutton noprint";
    button.setAttribute("href", uri);
    button.appendChild(document.createTextNode("send feedback"));
    node.appendChild(button);
  }
  else {
    var buttons = node.getElementsByTagName("a");
    for (var i = 0; i < buttons.length; i++) {
      var b = buttons.item(i);
      if (b.className == "fbbutton noprint") {
        node.removeChild(b);
      }
    }
  }
}</script><style type="text/css" title="Xml2Rfc (sans serif)">
a {
  text-decoration: none;
}
a.smpl {
  color: black;
}
a:hover {
  text-decoration: underline;
}
a:active {
  text-decoration: underline;
}
address {
  margin-top: 1em;
  margin-left: 2em;
  font-style: normal;
}
body {
  color: black;
  font-family: verdana, helvetica, arial, sans-serif;
  font-size: 10pt;
  margin-right: 2em;
}
cite {
  font-style: normal;
}
dl {
  margin-left: 2em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}
dl p {
  margin-left: 0em;
}
dt {
  margin-top: .5em;
}
h1 {
  font-size: 14pt;
  line-height: 21pt;
  page-break-after: avoid;
}
h1.np {
  page-break-before: always;
}
h1 a {
  color: #333333;
}
h2 {
  font-size: 12pt;
  line-height: 15pt;
  page-break-after: avoid;
}
h3, h4, h5, h6 {
  font-size: 10pt;
  page-break-after: avoid;
}
h2 a, h3 a, h4 a, h5 a, h6 a {
  color: black;
}
img {
  margin-left: 3em;
}
li {
  margin-left: 2em;
}
ol {
  margin-left: 2em;
}
ol.la {
  list-style-type: lower-alpha;
}
ol.ua {
  list-style-type: upper-alpha;
}
ol p {
  margin-left: 0em;
}
p {
  margin-left: 2em;
}
pre {
  margin-left: 3em;
  background-color: lightyellow;
  padding: .25em;
  page-break-inside: avoid;
}
pre.text2 {
  border-style: dotted;
  border-width: 1px;
  background-color: #f0f0f0;
  width: 69em;
}
pre.inline {
  background-color: white;
  padding: 0em;
}
pre.text {
  border-style: dotted;
  border-width: 1px;
  background-color: #f8f8f8;
  width: 69em;
}
pre.drawing {
  border-style: solid;
  border-width: 1px;
  background-color: #f8f8f8;
  padding: 2em;
}
sup {
  font-size: 60%;
}
table {
  margin-left: 2em;
}
table.tt {
  vertical-align: top;
}
table.full {
  border-style: outset;
  border-width: 1px;
}
table.headers {
  border-style: outset;
  border-width: 1px;
}
table.tt td {
  vertical-align: top;
}
table.full td {
  border-style: inset;
  border-width: 1px;
}
table.tt th {
  vertical-align: top;
}
table.full th {
  border-style: inset;
  border-width: 1px;
}
table.headers th {
  border-style: none none inset none;
  border-width: 1px;
}
table.left {
  margin-right: auto;
}
table.right {
  margin-left: auto;
}
table.center {
  margin-left: auto;
  margin-right: auto;
}
caption {
  caption-side: bottom;
  font-weight: bold;
  font-size: 9pt;
  margin-top: .5em;
}

table.header {
  border-spacing: 1px;
  width: 95%;
  font-size: 10pt;
  color: white;
}
td.top {
  vertical-align: top;
}
td.topnowrap {
  vertical-align: top;
  white-space: nowrap;
}
table.header td {
  background-color: gray;
  width: 50%;
}
td.reference {
  vertical-align: top;
  white-space: nowrap;
  padding-right: 1em;
}
thead {
  display:table-header-group;
}
ul.toc, ul.toc ul {
  list-style: none;
  margin-left: 1.5em;
  padding-left: 0em;
}
ul.toc li {
  line-height: 150%;
  font-weight: bold;
  font-size: 10pt;
  margin-left: 0em;
}
ul.toc li li {
  line-height: normal;
  font-weight: normal;
  font-size: 9pt;
  margin-left: 0em;
}
li.excluded {
  font-size: 0pt;
}
ul p {
  margin-left: 0em;
}

.comment {
  background-color: yellow;
}
.center {
  text-align: center;
}
.error {
  color: red;
  font-style: italic;
  font-weight: bold;
}
.figure {
  font-weight: bold;
  text-align: center;
  font-size: 9pt;
}
.filename {
  color: #333333;
  font-weight: bold;
  font-size: 12pt;
  line-height: 21pt;
  text-align: center;
}
.fn {
  font-weight: bold;
}
.hidden {
  display: none;
}
.left {
  text-align: left;
}
.right {
  text-align: right;
}
.title {
  color: #990000;
  font-size: 18pt;
  line-height: 18pt;
  font-weight: bold;
  text-align: center;
  margin-top: 36pt;
}
.vcardline {
  display: block;
}
.warning {
  font-size: 14pt;
  background-color: yellow;
}
.feedback {
  position: fixed;
  bottom: 1%;
  right: 1%;
  padding: 3px 5px;
  color: white;
  border-radius: 5px;
  background: #a00000;
  border: 1px solid silver;
}
.fbbutton {
  margin-left: 1em;
  color: #303030;
  font-size: small;
  font-weight: normal;
  background: #d0d000;
  padding: 1px 4px;
  border: 1px solid silver;
  border-radius: 5px;
}

@media print {
  .noprint {
    display: none;
  }

  a {
    color: black;
    text-decoration: none;
  }

  table.header {
    width: 90%;
  }

  td.header {
    width: 50%;
    color: black;
    background-color: white;
    vertical-align: top;
    font-size: 12pt;
  }

  ul.toc a:nth-child(2)::after {
    content: leader('.') target-counter(attr(href), page);
  }

  ul.ind li li a {
    content: target-counter(attr(href), page);
  }

  .print2col {
    column-count: 2;
    -moz-column-count: 2;
    column-fill: auto;
  }
}

@page {
  @top-left {
       content: "Internet-Draft";
  }
  @top-right {
       content: "June 2013";
  }
  @top-center {
       content: "HTTP/2.0";
  }
  @bottom-left {
       content: "Belshe, et al.";
  }
  @bottom-center {
       content: "Expires December 9, 2013";
  }
  @bottom-right {
       content: "[Page " counter(page) "]";
  }
}

@page:first {
    @top-left {
      content: normal;
    }
    @top-right {
      content: normal;
    }
    @top-center {
      content: normal;
    }
}
</style><style tyle='text/css'>body {   font: 10pt/12pt verdana, helvetica, arial, sans-serif;   margin: 1em auto;   max-width: 700px; }  table {   margin-left: 0em; }  table.header {   width: 100%; }  table.header td {   background-color: inherit;   color: black; }  pre.text, pre.text2 {   width: 90%; }</style><link rel="Contents" href="#rfc.toc">
      <link rel="Author" href="#rfc.authors">
      <link rel="Copyright" href="#rfc.copyrightnotice">
      <link rel="Chapter" title="1 Introduction" href="#rfc.section.1">
      <link rel="Chapter" title="2 Starting HTTP/2.0" href="#rfc.section.2">
      <link rel="Chapter" title="3 HTTP/2.0 Framing Layer" href="#rfc.section.3">
      <link rel="Chapter" title="4 HTTP Message Exchanges" href="#rfc.section.4">
      <link rel="Chapter" title="5 Design Rationale and Notes" href="#rfc.section.5">
      <link rel="Chapter" title="6 Security Considerations" href="#rfc.section.6">
      <link rel="Chapter" title="7 Privacy Considerations" href="#rfc.section.7">
      <link rel="Chapter" title="8 IANA Considerations" href="#rfc.section.8">
      <link rel="Chapter" title="9 Acknowledgements" href="#rfc.section.9">
      <link rel="Chapter" href="#rfc.section.10" title="10 References">
      <link rel="Appendix" title="A Change Log (to be removed by RFC Editor before publication)" href="#rfc.section.A">
      <meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.597, 2013/05/27 06:39:42, XSLT vendor: SAXON 9.1.0.8 from Saxonica http://www.saxonica.com/">
      <meta name="keywords" content="HTTP, SPDY, Web">
      <link rel="schema.dct" href="http://purl.org/dc/terms/">
      <meta name="dct.creator" content="Belshe, M.">
      <meta name="dct.creator" content="Peon, R.">
      <meta name="dct.creator" content="Thomson, M.">
      <meta name="dct.creator" content="Melnikov, A.">
      <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-httpbis-http2-latest">
      <meta name="dct.issued" scheme="ISO8601" content="2013-06-07">
      <meta name="dct.abstract" content="This specification describes an optimized expression of the syntax of the Hypertext Transfer Protocol (HTTP). The HTTP/2.0 encapsulation enables more efficient use of network resources and reduced perception of latency by allowing header field compression and multiple concurrent messages on the same connection. It also introduces unsolicited push of representations from servers to clients. This document is an alternative to, but does not obsolete the HTTP/1.1 message format or protocol. HTTP's existing semantics remain unchanged.">
      <meta name="description" content="This specification describes an optimized expression of the syntax of the Hypertext Transfer Protocol (HTTP). The HTTP/2.0 encapsulation enables more efficient use of network resources and reduced perception of latency by allowing header field compression and multiple concurrent messages on the same connection. It also introduces unsolicited push of representations from servers to clients. This document is an alternative to, but does not obsolete the HTTP/1.1 message format or protocol. HTTP's existing semantics remain unchanged.">
   </head>
   <body onload="init();">
      <table class="header">
         <tbody>
            <tr>
               <td class="left">HTTPbis Working Group</td>
               <td class="right">M. Belshe</td>
            </tr>
            <tr>
               <td class="left">Internet-Draft</td>
               <td class="right">Twist</td>
            </tr>
            <tr>
               <td class="left">Intended status: Standards Track</td>
               <td class="right">R. Peon</td>
            </tr>
            <tr>
               <td class="left">Expires: December 9, 2013</td>
               <td class="right">Google, Inc</td>
            </tr>
            <tr>
               <td class="left"></td>
               <td class="right">M. Thomson, Editor</td>
            </tr>
            <tr>
               <td class="left"></td>
               <td class="right">Microsoft</td>
            </tr>
            <tr>
               <td class="left"></td>
               <td class="right">A. Melnikov, Editor</td>
            </tr>
            <tr>
               <td class="left"></td>
               <td class="right">Isode Ltd</td>
            </tr>
            <tr>
               <td class="left"></td>
               <td class="right">June 7, 2013</td>
            </tr>
         </tbody>
      </table>
      <p class="title">Hypertext Transfer Protocol version 2.0<br><span class="filename">draft-ietf-httpbis-http2-latest</span></p>
      <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
      <p>This specification describes an optimized expression of the syntax of the Hypertext Transfer Protocol (HTTP). The HTTP/2.0
         encapsulation enables more efficient use of network resources and reduced perception of latency by allowing header field compression
         and multiple concurrent messages on the same connection. It also introduces unsolicited push of representations from servers
         to clients.
      </p>
      <p>This document is an alternative to, but does not obsolete the HTTP/1.1 message format or protocol. HTTP's existing semantics
         remain unchanged.
      </p>
      <h1 id="rfc.note.1"><a href="#rfc.note.1">Editorial Note (To be removed by RFC Editor)</a></h1>
      <p>Discussion of this draft takes place on the HTTPBIS working group mailing list (ietf-http-wg@w3.org), which is archived at &lt;<a href="http://lists.w3.org/Archives/Public/ietf-http-wg/">http://lists.w3.org/Archives/Public/ietf-http-wg/</a>&gt;.
      </p>
      <p>Working Group information and related documents can be found at &lt;<a href="http://tools.ietf.org/wg/httpbis/">http://tools.ietf.org/wg/httpbis/</a>&gt; (Wiki) and &lt;<a href="https://github.com/http2/http2-spec">https://github.com/http2/http2-spec</a>&gt; (source code and issues tracker).
      </p>
      <p>The changes in this draft are summarized in <a href="#changes.since.draft-ietf-httpbis-http2-03" title="Since draft-ietf-httpbis-http2-03">Appendix&nbsp;A.1</a>.
      </p>
      <h1><a id="rfc.status" href="#rfc.status">Status of This Memo</a></h1>
      <p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
      <p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute
         working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.
      </p>
      <p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other
         documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work
         in progress”.
      </p>
      <p>This Internet-Draft will expire on December 9, 2013.</p>
      <h1><a id="rfc.copyrightnotice" href="#rfc.copyrightnotice">Copyright Notice</a></h1>
      <p>Copyright © 2013 IETF Trust and the persons identified as the document authors. All rights reserved.</p>
      <p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights
         and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License
         text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified
         BSD License.
      </p>
      <hr class="noprint">
      <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
      <ul class="toc">
         <li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#intro">Introduction</a><ul>
               <li><a href="#rfc.section.1.1">1.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.1.1">Document Organization</a></li>
               <li><a href="#rfc.section.1.2">1.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.1.2">Conventions and Terminology</a></li>
            </ul>
         </li>
         <li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#starting">Starting HTTP/2.0</a><ul>
               <li><a href="#rfc.section.2.1">2.1</a>&nbsp;&nbsp;&nbsp;<a href="#versioning">HTTP/2.0 Version Identification</a></li>
               <li><a href="#rfc.section.2.2">2.2</a>&nbsp;&nbsp;&nbsp;<a href="#discover-http">Starting HTTP/2.0 for "http:" URIs</a></li>
               <li><a href="#rfc.section.2.3">2.3</a>&nbsp;&nbsp;&nbsp;<a href="#discover-https">Starting HTTP/2.0 for "https:" URIs</a></li>
               <li><a href="#rfc.section.2.4">2.4</a>&nbsp;&nbsp;&nbsp;<a href="#known-http">Starting HTTP/2.0 with Prior Knowledge</a></li>
            </ul>
         </li>
         <li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#FramingLayer">HTTP/2.0 Framing Layer</a><ul>
               <li><a href="#rfc.section.3.1">3.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.1">Connection</a></li>
               <li><a href="#rfc.section.3.2">3.2</a>&nbsp;&nbsp;&nbsp;<a href="#ConnectionHeader">Connection Header</a></li>
               <li><a href="#rfc.section.3.3">3.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.3">Framing</a><ul>
                     <li><a href="#rfc.section.3.3.1">3.3.1</a>&nbsp;&nbsp;&nbsp;<a href="#FrameHeader">Frame Header</a></li>
                     <li><a href="#rfc.section.3.3.2">3.3.2</a>&nbsp;&nbsp;&nbsp;<a href="#FrameSize">Frame Size</a></li>
                  </ul>
               </li>
               <li><a href="#rfc.section.3.4">3.4</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.4">Streams</a><ul>
                     <li><a href="#rfc.section.3.4.1">3.4.1</a>&nbsp;&nbsp;&nbsp;<a href="#StreamCreation">Stream Creation</a></li>
                     <li><a href="#rfc.section.3.4.2">3.4.2</a>&nbsp;&nbsp;&nbsp;<a href="#StreamPriority">Stream priority</a></li>
                     <li><a href="#rfc.section.3.4.3">3.4.3</a>&nbsp;&nbsp;&nbsp;<a href="#StreamHalfClose">Stream half-close</a></li>
                     <li><a href="#rfc.section.3.4.4">3.4.4</a>&nbsp;&nbsp;&nbsp;<a href="#StreamClose">Stream close</a></li>
                  </ul>
               </li>
               <li><a href="#rfc.section.3.5">3.5</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.5">Error Handling</a><ul>
                     <li><a href="#rfc.section.3.5.1">3.5.1</a>&nbsp;&nbsp;&nbsp;<a href="#ConnectionErrorHandler">Connection Error Handling</a></li>
                     <li><a href="#rfc.section.3.5.2">3.5.2</a>&nbsp;&nbsp;&nbsp;<a href="#StreamErrorHandler">Stream Error Handling</a></li>
                     <li><a href="#rfc.section.3.5.3">3.5.3</a>&nbsp;&nbsp;&nbsp;<a href="#ErrorCodes">Error Codes</a></li>
                  </ul>
               </li>
               <li><a href="#rfc.section.3.6">3.6</a>&nbsp;&nbsp;&nbsp;<a href="#flowcontrol">Stream Flow Control</a><ul>
                     <li><a href="#rfc.section.3.6.1">3.6.1</a>&nbsp;&nbsp;&nbsp;<a href="#fc-principles">Flow Control Principles</a></li>
                     <li><a href="#rfc.section.3.6.2">3.6.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.6.2">Appropriate Use of Flow Control</a></li>
                  </ul>
               </li>
               <li><a href="#rfc.section.3.7">3.7</a>&nbsp;&nbsp;&nbsp;<a href="#HeaderBlock">Header Blocks</a></li>
               <li><a href="#rfc.section.3.8">3.8</a>&nbsp;&nbsp;&nbsp;<a href="#frame-types">Frame Types</a><ul>
                     <li><a href="#rfc.section.3.8.1">3.8.1</a>&nbsp;&nbsp;&nbsp;<a href="#DataFrames">DATA Frames</a></li>
                     <li><a href="#rfc.section.3.8.2">3.8.2</a>&nbsp;&nbsp;&nbsp;<a href="#HEADERS_PRIORITY">HEADERS+PRIORITY</a></li>
                     <li><a href="#rfc.section.3.8.3">3.8.3</a>&nbsp;&nbsp;&nbsp;<a href="#PRIORITY">PRIORITY</a></li>
                     <li><a href="#rfc.section.3.8.4">3.8.4</a>&nbsp;&nbsp;&nbsp;<a href="#RST_STREAM">RST_STREAM</a></li>
                     <li><a href="#rfc.section.3.8.5">3.8.5</a>&nbsp;&nbsp;&nbsp;<a href="#SETTINGS">SETTINGS</a><ul>
                           <li><a href="#rfc.section.3.8.5.1">3.8.5.1</a>&nbsp;&nbsp;&nbsp;<a href="#SettingFormat">Setting Format</a></li>
                           <li><a href="#rfc.section.3.8.5.2">3.8.5.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.8.5.2">Setting Persistence</a></li>
                           <li><a href="#rfc.section.3.8.5.3">3.8.5.3</a>&nbsp;&nbsp;&nbsp;<a href="#SettingValues">Defined Settings</a></li>
                        </ul>
                     </li>
                     <li><a href="#rfc.section.3.8.6">3.8.6</a>&nbsp;&nbsp;&nbsp;<a href="#PUSH_PROMISE">PUSH_PROMISE</a></li>
                     <li><a href="#rfc.section.3.8.7">3.8.7</a>&nbsp;&nbsp;&nbsp;<a href="#PING">PING</a></li>
                     <li><a href="#rfc.section.3.8.8">3.8.8</a>&nbsp;&nbsp;&nbsp;<a href="#GOAWAY">GOAWAY</a></li>
                     <li><a href="#rfc.section.3.8.9">3.8.9</a>&nbsp;&nbsp;&nbsp;<a href="#HEADERS">HEADERS</a></li>
                     <li><a href="#rfc.section.3.8.10">3.8.10</a>&nbsp;&nbsp;&nbsp;<a href="#WINDOW_UPDATE">WINDOW_UPDATE</a><ul>
                           <li><a href="#rfc.section.3.8.10.1">3.8.10.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.8.10.1">The Flow Control Window</a></li>
                           <li><a href="#rfc.section.3.8.10.2">3.8.10.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.8.10.2">Initial Flow Control Window Size</a></li>
                           <li><a href="#rfc.section.3.8.10.3">3.8.10.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.8.10.3">Reducing the Stream Window Size</a></li>
                           <li><a href="#rfc.section.3.8.10.4">3.8.10.4</a>&nbsp;&nbsp;&nbsp;<a href="#EndFlowControl">Ending Flow Control</a></li>
                        </ul>
                     </li>
                  </ul>
               </li>
            </ul>
         </li>
         <li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#HTTPLayer">HTTP Message Exchanges</a><ul>
               <li><a href="#rfc.section.4.1">4.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.1">Connection Management</a></li>
               <li><a href="#rfc.section.4.2">4.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.2">HTTP Request/Response</a><ul>
                     <li><a href="#rfc.section.4.2.1">4.2.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.2.1">HTTP Header Fields and HTTP/2.0 Headers</a></li>
                     <li><a href="#rfc.section.4.2.2">4.2.2</a>&nbsp;&nbsp;&nbsp;<a href="#HttpRequest">Request</a></li>
                     <li><a href="#rfc.section.4.2.3">4.2.3</a>&nbsp;&nbsp;&nbsp;<a href="#HttpResponse">Response</a></li>
                  </ul>
               </li>
               <li><a href="#rfc.section.4.3">4.3</a>&nbsp;&nbsp;&nbsp;<a href="#PushResources">Server Push Transactions</a><ul>
                     <li><a href="#rfc.section.4.3.1">4.3.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.3.1">Server implementation</a></li>
                     <li><a href="#rfc.section.4.3.2">4.3.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.3.2">Client implementation</a></li>
                  </ul>
               </li>
            </ul>
         </li>
         <li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5">Design Rationale and Notes</a><ul>
               <li><a href="#rfc.section.5.1">5.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.1">Separation of Framing Layer and Application Layer</a></li>
               <li><a href="#rfc.section.5.2">5.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.2">Error handling - Framing Layer</a></li>
               <li><a href="#rfc.section.5.3">5.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.3">One Connection per Domain</a></li>
               <li><a href="#rfc.section.5.4">5.4</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.4">Fixed vs Variable Length Fields</a></li>
               <li><a href="#rfc.section.5.5">5.5</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.5">Server Push</a></li>
            </ul>
         </li>
         <li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.6">Security Considerations</a><ul>
               <li><a href="#rfc.section.6.1">6.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.6.1">Server Authority and Same-Origin</a></li>
               <li><a href="#rfc.section.6.2">6.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.6.2">Cross-Protocol Attacks</a></li>
               <li><a href="#rfc.section.6.3">6.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.6.3">Cacheability of Pushed Resources</a></li>
            </ul>
         </li>
         <li><a href="#rfc.section.7">7.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.7">Privacy Considerations</a><ul>
               <li><a href="#rfc.section.7.1">7.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.7.1">Long Lived Connections</a></li>
               <li><a href="#rfc.section.7.2">7.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.7.2">SETTINGS frame</a></li>
            </ul>
         </li>
         <li><a href="#rfc.section.8">8.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.8">IANA Considerations</a><ul>
               <li><a href="#rfc.section.8.1">8.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.8.1">Frame Type Registry</a></li>
               <li><a href="#rfc.section.8.2">8.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.8.2">Error Code Registry</a></li>
               <li><a href="#rfc.section.8.3">8.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.8.3">Settings Registry</a></li>
            </ul>
         </li>
         <li><a href="#rfc.section.9">9.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.9">Acknowledgements</a></li>
         <li><a href="#rfc.section.10">10.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a><ul>
               <li><a href="#rfc.section.10.1">10.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.1">Normative References</a></li>
               <li><a href="#rfc.section.10.2">10.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.2">Informative References</a></li>
            </ul>
         </li>
         <li><a href="#rfc.authors">Authors' Addresses</a></li>
         <li><a href="#rfc.section.A">A.</a>&nbsp;&nbsp;&nbsp;<a href="#change.log">Change Log (to be removed by RFC Editor before publication)</a><ul>
               <li><a href="#rfc.section.A.1">A.1</a>&nbsp;&nbsp;&nbsp;<a href="#changes.since.draft-ietf-httpbis-http2-03">Since draft-ietf-httpbis-http2-03</a></li>
               <li><a href="#rfc.section.A.2">A.2</a>&nbsp;&nbsp;&nbsp;<a href="#changes.since.draft-ietf-httpbis-http2-02">Since draft-ietf-httpbis-http2-02</a></li>
               <li><a href="#rfc.section.A.3">A.3</a>&nbsp;&nbsp;&nbsp;<a href="#changes.since.draft-ietf-httpbis-http2-01">Since draft-ietf-httpbis-http2-01</a></li>
               <li><a href="#rfc.section.A.4">A.4</a>&nbsp;&nbsp;&nbsp;<a href="#changes.since.draft-ietf-httpbis-http2-00">Since draft-ietf-httpbis-http2-00</a></li>
               <li><a href="#rfc.section.A.5">A.5</a>&nbsp;&nbsp;&nbsp;<a href="#changes.since.draft-mbelshe-httpbis-spdy-00">Since draft-mbelshe-httpbis-spdy-00</a></li>
            </ul>
         </li>
      </ul>
      <ul class="toc">
         <li>Figures
            
            <ul>
               <li><a href="#rfc.figure.1">Figure 1: Frame Header</a></li>
               <li><a href="#rfc.figure.2">Figure 2: HEADERS+PRIORITY Frame Payload</a></li>
               <li><a href="#rfc.figure.3">Figure 3: PRIORITY Frame Payload</a></li>
               <li><a href="#rfc.figure.4">Figure 4: RST_STREAM Frame Payload</a></li>
               <li><a href="#rfc.figure.5">Figure 5: Setting Format</a></li>
               <li><a href="#rfc.figure.6">Figure 6: PUSH_PROMISE Payload Format</a></li>
               <li><a href="#rfc.figure.7">Figure 7: GOAWAY Payload Format</a></li>
            </ul>
         </li>
      </ul>
      <h1 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a id="intro" href="#intro">Introduction</a></h1>
      <p id="rfc.section.1.p.1">The Hypertext Transfer Protocol (HTTP) is a wildly successful protocol. However, the HTTP/1.1 message encapsulation (<a href="#HTTP-p1"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[HTTP-p1]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/22/p1-messaging.html#http.message" title="Message Format">Section 3</a>) is optimized for implementation simplicity and accessibility, not application performance. As such it has several characteristics
         that have a negative overall effect on application performance.
      </p>
      <p id="rfc.section.1.p.2">In particular, HTTP/1.0 only allows one request to be delivered at a time on a given connection. HTTP/1.1 pipelining only
         partially addressed request concurrency, and is not widely deployed. Therefore, clients that need to make many requests (as
         is common on the Web) typically use multiple connections to a server in order to reduce perceived latency.
      </p>
      <p id="rfc.section.1.p.3">Furthermore, HTTP/1.1 header fields are often repetitive and verbose, which, in addition to generating more or larger network
         packets, can cause the small initial TCP congestion window to quickly fill. This can result in excessive latency when multiple
         requests are made on a single new TCP connection.
      </p>
      <p id="rfc.section.1.p.4">This document addresses these issues by defining an optimized mapping of HTTP's semantics to an underlying connection. Specifically,
         it allows interleaving of request and response messages on the same connection and uses an efficient coding for HTTP header
         fields. It also allows prioritization of requests, letting more important requests complete more quickly, further improving
         perceived performance.
      </p>
      <p id="rfc.section.1.p.5">The resulting protocol is designed to have be more friendly to the network, because fewer TCP connections can be used, in
         comparison to HTTP/1.x. This means less competition with other flows, and longer-lived connections, which in turn leads to
         better utilization of available network capacity.
      </p>
      <p id="rfc.section.1.p.6">Finally, this encapsulation also enables more scalable processing of messages through use of binary message framing.</p>
      <h2 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1</a>&nbsp;Document Organization
      </h2>
      <p id="rfc.section.1.1.p.1">The HTTP/2.0 Specification is split into three parts: starting HTTP/2.0 (<a href="#starting" title="Starting HTTP/2.0">Section&nbsp;2</a>), which covers how a HTTP/2.0 connection is initiated; a framing layer (<a href="#FramingLayer" title="HTTP/2.0 Framing Layer">Section&nbsp;3</a>), which multiplexes a single TCP connection into independent frames of various types; and an HTTP layer (<a href="#HTTPLayer" title="HTTP Message Exchanges">Section&nbsp;4</a>), which specifies the mechanism for expressing HTTP interactions using the framing layer. While some of the framing layer
         concepts are isolated from HTTP, building a generic framing layer has not been a goal. The framing layer is tailored to the
         needs of the HTTP protocol and server push.
      </p>
      <h2 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2</a>&nbsp;Conventions and Terminology
      </h2>
      <p id="rfc.section.1.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL"
         in this document are to be interpreted as described in <a href="#RFC2119">RFC 2119</a> <cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite>.
      </p>
      <p id="rfc.section.1.2.p.2">All numeric values are in network byte order. Values are unsigned unless otherwise indicated. Literal values are provided
         in decimal or hexadecimal as appropriate. Hexadecimal literals are prefixed with <samp>0x</samp> to distinguish them from decimal literals.
      </p>
      <p id="rfc.section.1.2.p.3">The following terms are used: </p>
      <dl>
         <dt>client:</dt>
         <dd>The endpoint initiating the HTTP connection.</dd>
         <dt>connection:</dt>
         <dd>A transport-level connection between two endpoints.</dd>
         <dt>endpoint:</dt>
         <dd>Either the client or server of the connection.</dd>
         <dt>frame:</dt>
         <dd>The smallest unit of communication within an HTTP/2.0 connection, consisting of a header and a variable-length sequence of
            bytes structured according to the frame type.
         </dd>
         <dt>peer:</dt>
         <dd>An endpoint. When discussing a particular endpoint, "peer" refers to the endpoint that is remote to the primary subject of
            discussion.
         </dd>
         <dt>receiver:</dt>
         <dd>An endpoint that is receiving frames.</dd>
         <dt>sender:</dt>
         <dd>An endpoint that is transmitting frames.</dd>
         <dt>server:</dt>
         <dd>The endpoint which did not initiate the HTTP connection.</dd>
         <dt>connection error:</dt>
         <dd>An error on the HTTP/2.0 connection.</dd>
         <dt>stream:</dt>
         <dd>A bi-directional flow of frames across a virtual channel within the HTTP/2.0 connection.</dd>
         <dt>stream error:</dt>
         <dd>An error on the individual HTTP/2.0 stream.</dd>
      </dl>
      <h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a>&nbsp;<a id="starting" href="#starting">Starting HTTP/2.0</a></h1>
      <p id="rfc.section.2.p.1">HTTP/2.0 uses the same "http:" and "https:" URI schemes used by HTTP/1.1. As a result, implementations processing requests
         for target resource URIs like "http://example.org/foo" or "https://example.com/bar" are required to first discover whether
         the upstream server (the immediate peer to which the client wishes to establish a connection) supports HTTP/2.0.
      </p>
      <p id="rfc.section.2.p.2">The means by which support for HTTP/2.0 is determined is different for "http" and "https" URIs. Discovery for "https:" URIs
         is described in <a href="#discover-https" title="Starting HTTP/2.0 for &#34;https:&#34; URIs">Section&nbsp;2.3</a>. Discovery for "http" URIs is described here.
      </p>
      <h2 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1</a>&nbsp;<a id="versioning" href="#versioning">HTTP/2.0 Version Identification</a></h2>
      <p id="rfc.section.2.1.p.1">The protocol defined in this document is identified using the string "HTTP/2.0". This identification is used in the HTTP/1.1
         Upgrade header field, in the <a href="#TLSALPN">TLS application layer protocol negotiation extension</a> <cite title="Transport Layer Security (TLS) Application Layer Protocol Negotiation Extension">[TLSALPN]</cite> field and other places where protocol identification is required.
      </p>
      <p id="rfc.section.2.1.p.2">Negotiating "HTTP/2.0" implies the use of the transport, security, framing and message semantics described in this document.</p>
      <p id="rfc.section.2.1.p.3"> <span class="comment" id="rfc.comment.1">[<a href="#rfc.comment.1" class="smpl">rfc.comment.1</a>: Editor's Note: please remove the following text prior to the publication of a final version of this document.]</span> 
      </p>
      <p id="rfc.section.2.1.p.4">Only implementations of the final, published RFC can identify themselves as "HTTP/2.0". Until such an RFC exists, implementations
         MUST NOT identify themselves using "HTTP/2.0".
      </p>
      <p id="rfc.section.2.1.p.5">Examples and text throughout the rest of this document use "HTTP/2.0" as a matter of editorial convenience only. Implementations
         of draft versions MUST NOT identify using this string.
      </p>
      <p id="rfc.section.2.1.p.6">Implementations of draft versions of the protocol MUST add the string "-draft-" and the corresponding draft number to the
         identifier before the separator ('/'). For example, draft-ietf-httpbis-http2-03 is identified using the string "HTTP-draft-03/2.0".
      </p>
      <p id="rfc.section.2.1.p.7">Non-compatible experiments that are based on these draft versions MUST instead replace the string "draft" with a different
         identifier. For example, an experimental implementation of packet mood-based encoding based on draft-ietf-httpbis-http2-07
         might identify itself as "HTTP-emo-07/2.0". Note that any label MUST conform to the "token" syntax defined in <a href="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/22/p1-messaging.html#field.components" title="Field value components">Section 3.2.6</a> of <a href="#HTTP-p1"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[HTTP-p1]</cite></a>. Experimenters are encouraged to coordinate their experiments on the ietf-http-wg@w3.org mailing list.
      </p>
      <h2 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2</a>&nbsp;<a id="discover-http" href="#discover-http">Starting HTTP/2.0 for "http:" URIs</a></h2>
      <p id="rfc.section.2.2.p.1">A client that makes a request to an "http:" URI without prior knowledge about support for HTTP/2.0 uses the HTTP Upgrade mechanism
         (<a href="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/22/p1-messaging.html#header.upgrade" title="Upgrade">Section 6.7</a> of <a href="#HTTP-p1"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[HTTP-p1]</cite></a>). The client makes an HTTP/1.1 request that includes an Upgrade header field identifying HTTP/2.0.
      </p>
      <p id="rfc.section.2.2.p.2">For example:</p>
      <div id="rfc.figure.u.1"></div><pre class="text2">GET /default.htm HTTP/1.1
Host: server.example.com
Connection: Upgrade
Upgrade: HTTP/2.0
</pre><p id="rfc.section.2.2.p.4">A server that does not support HTTP/2.0 can respond to the request as though the Upgrade header field were absent:</p>
      <div id="rfc.figure.u.2"></div><pre class="text">HTTP/1.1 200 OK
Content-length: 243
Content-type: text/html
      ...
</pre><p id="rfc.section.2.2.p.6">A server that supports HTTP/2.0 can accept the upgrade with a 101 (Switching Protocols) status code. After the empty line
         that terminates the 101 response, the server can begin sending HTTP/2.0 frames. These frames MUST include a response to the
         request that initiated the Upgrade.
      </p>
      <div id="rfc.figure.u.3"></div><pre class="text">HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: HTTP/2.0

[ HTTP/2.0 connection ...
</pre><p id="rfc.section.2.2.p.8">The first HTTP/2.0 frame sent by the server is a SETTINGS frame (<a href="#SETTINGS" title="SETTINGS">Section&nbsp;3.8.5</a>). Upon receiving the 101 response, the client sends a connection header (<a href="#ConnectionHeader" title="Connection Header">Section&nbsp;3.2</a>), which includes a SETTINGS frame.
      </p>
      <h2 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3</a>&nbsp;<a id="discover-https" href="#discover-https">Starting HTTP/2.0 for "https:" URIs</a></h2>
      <p id="rfc.section.2.3.p.1">A client that makes a request to an "https:" URI without prior knowledge about support for HTTP/2.0 uses <a href="#RFC5246">TLS</a> <cite title="The Transport Layer Security (TLS) Protocol Version 1.2">[RFC5246]</cite> with the <a href="#TLSALPN">application layer protocol negotiation extension</a> <cite title="Transport Layer Security (TLS) Application Layer Protocol Negotiation Extension">[TLSALPN]</cite>.
      </p>
      <p id="rfc.section.2.3.p.2">Once TLS negotiation is complete, both the client and the server send a connection header (<a href="#ConnectionHeader" title="Connection Header">Section&nbsp;3.2</a>).
      </p>
      <h2 id="rfc.section.2.4"><a href="#rfc.section.2.4">2.4</a>&nbsp;<a id="known-http" href="#known-http">Starting HTTP/2.0 with Prior Knowledge</a></h2>
      <p id="rfc.section.2.4.p.1">A client can learn that a particular server supports HTTP/2.0 by other means. A client MAY immediately send HTTP/2.0 frames
         to a server that is known to support HTTP/2.0. This only affects the resolution of "http:" URIs, servers supporting HTTP/2.0
         are required to support <a href="#TLSALPN">protocol negotiation in TLS</a> <cite title="Transport Layer Security (TLS) Application Layer Protocol Negotiation Extension">[TLSALPN]</cite> for "https:" URIs.
      </p>
      <p id="rfc.section.2.4.p.2">Prior support for HTTP/2.0 is not a strong signal that a given server will support HTTP/2.0 for future connections. It is
         possible for server configurations to change or for configurations to differ between instances in clustered server. Interception
         proxies (a.k.a. "transparent" proxies) are another source of variability.
      </p>
      <h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a>&nbsp;<a id="FramingLayer" href="#FramingLayer">HTTP/2.0 Framing Layer</a></h1>
      <h2 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1</a>&nbsp;Connection
      </h2>
      <p id="rfc.section.3.1.p.1">The HTTP/2.0 connection is an Application Level protocol running on top of a TCP connection (<a href="#RFC0793"><cite title="Transmission Control Protocol">[RFC0793]</cite></a>). The client is the TCP connection initiator.
      </p>
      <p id="rfc.section.3.1.p.2">HTTP/2.0 connections are persistent. That is, for best performance, it is expected a clients will not close connections until
         it is determined that no further communication with a server is necessary (for example, when a user navigates away from a
         particular web page), or until the server closes the connection.
      </p>
      <p id="rfc.section.3.1.p.3">Servers are encouraged to maintain open connections for as long as possible, but are permitted to terminate idle connections
         if necessary. When either endpoint chooses to close the transport-level TCP connection, the terminating endpoint MUST first
         send a GOAWAY (<a href="#GOAWAY" title="GOAWAY">Section&nbsp;3.8.8</a>) frame so that both endpoints can reliably determine whether previously sent frames have been processed and gracefully complete
         or terminate any necessary remaining tasks.
      </p>
      <h2 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2</a>&nbsp;<a id="ConnectionHeader" href="#ConnectionHeader">Connection Header</a></h2>
      <p id="rfc.section.3.2.p.1">Upon establishment of a TCP connection and determination that HTTP/2.0 will be used by both peers to communicate, each endpoint
         MUST send a connection header as a final confirmation and to establish the default parameters for the HTTP/2.0 connection.
      </p>
      <p id="rfc.section.3.2.p.2">The client connection header is a sequence of 24 octets (in hex notation)</p>
      <div id="rfc.figure.u.4"></div><pre class="inline">464f4f202a20485454502f322e300d0a0d0a42410d0a0d0a</pre><p id="rfc.section.3.2.p.4">(the string <samp>FOO * HTTP/2.0\r\n\r\nBA\r\n\r\n</samp>) followed by a SETTINGS frame (<a href="#SETTINGS" title="SETTINGS">Section&nbsp;3.8.5</a>). The client sends the client connection header immediately upon receipt of a 101 Switching Protocols response (indicating
         a successful upgrade), or after receiving a TLS Finished message from the server. If starting an HTTP/2.0 connection with
         prior knowledge of server support for the protocol, the client connection header is sent upon connection establishment.
      </p>
      <p id="rfc.section.3.2.p.5"> </p>
      <ul class="empty">
         <li>The client connection header is selected so that a large proportion of HTTP/1.1 or HTTP/1.0 servers and intermediaries do
            not attempt to process further frames. Note that this does not address the concerns raised in <a href="#TALKING"><cite title="Talking to Yourself for Fun and Profit">[TALKING]</cite></a>.
         </li>
      </ul>
      <p id="rfc.section.3.2.p.6">The server connection header consists of just a SETTINGS frame (<a href="#SETTINGS" title="SETTINGS">Section&nbsp;3.8.5</a>) that MUST be the first frame the server sends in the HTTP/2.0 connection.
      </p>
      <p id="rfc.section.3.2.p.7">To avoid unnecessary latency, clients are permitted to send additional frames to the server immediately after sending the
         client connection header, without waiting to receive the server connection header. It is important to note, however, that
         the server connection header SETTINGS frame might include parameters that necessarily alter how a client is expected to communicate
         with the server. Upon receiving the SETTINGS frame, the client is expected to honor any parameters established.
      </p>
      <p id="rfc.section.3.2.p.8">Clients and servers MUST terminate the TCP connection if either peer does not begin with a valid connection header. A GOAWAY frame (<a href="#GOAWAY" title="GOAWAY">Section&nbsp;3.8.8</a>) MAY be omitted if it is clear that the peer is not using HTTP/2.0.
      </p>
      <h2 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3</a>&nbsp;Framing
      </h2>
      <p id="rfc.section.3.3.p.1">Once the HTTP/2.0 connection is established, clients and servers can begin exchanging frames.</p>
      <h3 id="rfc.section.3.3.1"><a href="#rfc.section.3.3.1">3.3.1</a>&nbsp;<a id="FrameHeader" href="#FrameHeader">Frame Header</a></h3>
      <p id="rfc.section.3.3.1.p.1">HTTP/2.0 frames share a common base format consisting of an 8-byte header followed by 0 to 65535 bytes of data.</p>
      <div id="rfc.figure.1"></div><pre class="inline"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Length (16)           |   Type (8)    |   Flags (8)   |
+-+-------------+---------------+-------------------------------+
|R|                 Stream Identifier (31)                      |
+-+-------------------------------------------------------------+
|                     Frame Data (0...)                       ...
+---------------------------------------------------------------+
</pre><p class="figure">Figure 1: Frame Header</p>
      <p id="rfc.section.3.3.1.p.3">The fields of the frame header are defined as: </p>
      <dl>
         <dt>Length:</dt>
         <dd>The length of the frame data expressed as an unsigned 16-bit integer. The 8 bytes of the frame header are not included in
            this value.
         </dd>
         <dt>Type:</dt>
         <dd>The 8-bit type of the frame. The frame type determines how the remainder of the frame header and data are interpreted. Implementations
            MUST ignore unsupported and unrecognized frame types.
         </dd>
         <dt>Flags:</dt>
         <dd>An 8-bit field reserved for frame-type specific boolean flags. <br><br> The least significant bit (0x1) - the FINAL bit - is defined for all frame types as an indication that this frame is the last
            the endpoint will send for the identified stream. Setting this flag causes the stream to enter the half-closed state (<a href="#StreamHalfClose" title="Stream half-close">Section&nbsp;3.4.3</a>). Implementations MUST process the FINAL bit for all frames whose stream identifier field is not 0x0. The FINAL bit MUST NOT
            be set on frames that use a stream identifier of 0. <br><br> The remaining flags can be assigned semantics specific to the indicated frame type. Flags that have no defined semantics for
            a particular frame type MUST be ignored, and MUST be left unset (0) when sending.
         </dd>
         <dt>R:</dt>
         <dd>A reserved 1-bit field. The semantics of this bit are undefined and the bit MUST remain unset (0) when sending and MUST be
            ignored when receiving.
         </dd>
         <dt>Stream Identifier:</dt>
         <dd>A 31-bit stream identifier (see <a href="#StreamCreation" title="Stream Creation">Section&nbsp;3.4.1</a>). A value 0 is reserved for frames that are associated with the connection as a whole as opposed to an individual stream.
         </dd>
      </dl>
      <p id="rfc.section.3.3.1.p.4">The structure and content of the remaining frame data is dependent entirely on the frame type.</p>
      <h3 id="rfc.section.3.3.2"><a href="#rfc.section.3.3.2">3.3.2</a>&nbsp;<a id="FrameSize" href="#FrameSize">Frame Size</a></h3>
      <p id="rfc.section.3.3.2.p.1">Implementations with limited resources might not be capable of processing large frame sizes. Such implementations MAY choose
         to place additional limits on the maximum frame size. However, all implementations MUST be capable of receiving and processing
         frames containing at least 8192 octets of data. <span class="comment" id="rfc.comment.2">[<a href="#rfc.comment.2" class="smpl">rfc.comment.2</a>: Ed. Question: Does this minimum include the 8-byte header or just the frame data?]</span></p>
      <p id="rfc.section.3.3.2.p.2">An implementation MUST terminate a stream immediately if it is unable to process a frame due it's size. This is done by sending
         an RST_STREAM frame (<a href="#RST_STREAM" title="RST_STREAM">Section&nbsp;3.8.4</a>) containing the FRAME_TOO_LARGE error code.
      </p>
      <p id="rfc.section.3.3.2.p.3"> <span class="comment" id="rfc.comment.3">[<a href="#rfc.comment.3" class="smpl">rfc.comment.3</a>: <a href="https://github.com/http2/http2-spec/issues/28">Issue 28</a>: Need a way to signal the maximum frame size; no way to RST_STREAM on non-stream-related frames.]</span> 
      </p>
      <h2 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4</a>&nbsp;Streams
      </h2>
      <p id="rfc.section.3.4.p.1">A "stream" is an independent, bi-directional sequence of frames exchanged between the client and server within an HTTP/2.0
         connection. Streams have several important characteristics: 
      </p>
      <ul>
         <li>Streams can be established and used unilaterally or shared by either the client or server.</li>
         <li>Streams can be rejected or cancelled by either endpoint.</li>
         <li>Multiple types of frames can be sent by either endpoint within a single stream.</li>
         <li>The order in which frames are sent within a stream is significant. Recipients are required to process frames in the order
            they are received.
         </li>
         <li>Streams optionally carry a set of name-value header pairs that are expressed within the headers block of HEADERS+PRIORITY,
            HEADERS, or PUSH_PROMISE frames.
         </li>
         <li>A single HTTP/2.0 connection can contain multiple concurrently active streams, with either endpoint interleaving frames from
            multiple streams.
         </li>
      </ul>
      <h3 id="rfc.section.3.4.1"><a href="#rfc.section.3.4.1">3.4.1</a>&nbsp;<a id="StreamCreation" href="#StreamCreation">Stream Creation</a></h3>
      <p id="rfc.section.3.4.1.p.1">There is no coordination or shared action between the client and server required to create a stream. Rather, new streams are
         established by sending a frame whose stream identifier field references a previously unused stream identifier.
      </p>
      <p id="rfc.section.3.4.1.p.2">All streams are identified by an unsigned 31-bit integer. Streams initiated by a client use odd numbered stream identifiers;
         those initiated by the server use even numbered stream identifiers. A stream identifier of zero MUST NOT be used to establish
         a new stream.
      </p>
      <p id="rfc.section.3.4.1.p.3">The identifier of a newly established stream MUST be numerically greater than all previously established streams from that
         endpoint within the HTTP/2.0 connection, unless the identifier has been reserved using a PUSH_PROMISE (<a href="#PUSH_PROMISE" title="PUSH_PROMISE">Section&nbsp;3.8.6</a>) frame. An endpoint that receives an unexpected stream identifier MUST respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;3.5.1</a>) of type PROTOCOL_ERROR.
      </p>
      <p id="rfc.section.3.4.1.p.4">A peer can limit the total number of concurrently active streams using the SETTINGS_MAX_CONCURRENT_STREAMS parameters within
         a SETTINGS frame. The maximum concurrent streams setting is specific to each endpoint and applies only to the peer. That is,
         clients specify the maximum number of concurrent streams the server can initiate, and servers specify the maximum number of
         concurrent streams the client can initiate. Peer endpoints MUST NOT exceed this limit. All concurrently active streams initiated
         by an endpoint, including streams that are half-open (<a href="#StreamHalfClose" title="Stream half-close">Section&nbsp;3.4.3</a>) in any direction, count toward that endpoint's limit.
      </p>
      <p id="rfc.section.3.4.1.p.5">Stream identifiers cannot be reused within a connection. Long-lived connections can cause an endpoint to exhaust the available
         range of stream identifiers. A client that is unable to establish a new stream identifier can establish a new connection for
         new streams.
      </p>
      <p id="rfc.section.3.4.1.p.6">Either endpoint can request the early termination of an unwanted stream by sending an RST_STREAM frame (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;3.5.2</a>) with an error code of either REFUSED_STREAM (if no frames have been processed) or CANCEL (if at least one frame has been processed).
         Such termination might not take effect immediately as the peer might have sent additional frames on the stream prior to receiving
         the termination request.
      </p>
      <h3 id="rfc.section.3.4.2"><a href="#rfc.section.3.4.2">3.4.2</a>&nbsp;<a id="StreamPriority" href="#StreamPriority">Stream priority</a></h3>
      <p id="rfc.section.3.4.2.p.1">The endpoint establishing a new stream can assign a priority for the stream. Priority is represented as an unsigned 31-bit
         integer. 0 represents the highest priority and 2<sup>31</sup>-1 represents the lowest priority.
      </p>
      <p id="rfc.section.3.4.2.p.2">The purpose of this value is to allow the initiating endpoint to request that frames for the stream be processed with higher
         priority relative to any other concurrently active streams. That is, if an endpoint receives interleaved frames for multiple
         streams, the endpoint ought to make a best-effort attempt at processing frames for higher priority streams before processing
         those for lower priority streams.
      </p>
      <p id="rfc.section.3.4.2.p.3">Explicitly setting the priority for a stream does not guarantee any particular processing order for the stream relative to
         any other stream. Nor is there is any mechanism provided by which the initiator of a stream can force or require a receiving
         endpoint to process frames from one stream before processing frames from another.
      </p>
      <h3 id="rfc.section.3.4.3"><a href="#rfc.section.3.4.3">3.4.3</a>&nbsp;<a id="StreamHalfClose" href="#StreamHalfClose">Stream half-close</a></h3>
      <p id="rfc.section.3.4.3.p.1">When an endpoint sends a frame for a stream with the FINAL flag set, the stream is considered to be half-closed for that endpoint.
         Subsequent frames MUST NOT be sent by that endpoint for the half closed stream for the remaining duration of the HTTP/2.0
         connection. When both endpoints have sent frames with the FINAL flag set, the stream is considered to be fully closed.
      </p>
      <p id="rfc.section.3.4.3.p.2">If an endpoint receives additional frames for a stream that was previously half-closed by the sending peer, the recipient
         MUST respond with a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;3.5.2</a>) of type STREAM_CLOSED.
      </p>
      <p id="rfc.section.3.4.3.p.3">An endpoint that has not yet half-closed a stream by sending the FINAL flag can continue sending frames on the stream.</p>
      <p id="rfc.section.3.4.3.p.4">It is not necessary for an endpoint to half-close a stream for which it has not sent any frames. This allows endpoints to
         use fully unidirectional streams that do not require explicit action or acknowledgement from the receiver.
      </p>
      <h3 id="rfc.section.3.4.4"><a href="#rfc.section.3.4.4">3.4.4</a>&nbsp;<a id="StreamClose" href="#StreamClose">Stream close</a></h3>
      <p id="rfc.section.3.4.4.p.1">Streams can be terminated in the following ways: </p>
      <dl>
         <dt>Normal termination:</dt>
         <dd>Normal stream termination occurs when both client and server have half-closed the stream by sending a frame containing a FINAL flag (<a href="#FrameHeader" title="Frame Header">Section&nbsp;3.3.1</a>).
         </dd>
         <dt>Half-close on unidirectional stream:</dt>
         <dd>A stream that only has frames sent in one direction can be tentatively considered to be closed once a frame containing a FINAL
            flag is sent. The active sender on the stream MUST be prepared to receive frames after closing the stream.
         </dd>
         <dt>Abrupt termination:</dt>
         <dd>Either peer can send a RST_STREAM control frame at any time to terminate an active stream. RST_STREAM contains an error code
            to indicate the reason for termination. A RST_STREAM indicates that the sender will transmit no further data on the stream
            and that the receiver is advised to cease transmission on it. <br><br> The sender of a RST_STREAM frame MUST allow for frames that have already been sent by the peer prior to the RST_STREAM being
            processed. If in-transit frames alter connection state, these frames cannot be safely discarded. See Stream Error Handling (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;3.5.2</a>) for more details.
         </dd>
         <dt>TCP connection teardown:</dt>
         <dd>If the TCP connection is torn down while un-closed streams exist, then the endpoint MUST assume that the stream was abnormally
            interrupted and may be incomplete.
         </dd>
      </dl>
      <h2 id="rfc.section.3.5"><a href="#rfc.section.3.5">3.5</a>&nbsp;Error Handling
      </h2>
      <p id="rfc.section.3.5.p.1">HTTP/2.0 framing permits two classes of error: </p>
      <ul>
         <li>An error condition that renders the entire connection unusable is a connection error.</li>
         <li>An error in an individual stream is a stream error.</li>
      </ul>
      <h3 id="rfc.section.3.5.1"><a href="#rfc.section.3.5.1">3.5.1</a>&nbsp;<a id="ConnectionErrorHandler" href="#ConnectionErrorHandler">Connection Error Handling</a></h3>
      <p id="rfc.section.3.5.1.p.1">A connection error is any error which prevents further processing of the framing layer or which corrupts any connection state.</p>
      <p id="rfc.section.3.5.1.p.2">An endpoint that encounters a connection error MUST first send a GOAWAY (<a href="#GOAWAY" title="GOAWAY">Section&nbsp;3.8.8</a>) frame with the stream identifier of the last stream that it successfully received from its peer. The GOAWAY frame includes
         an error code that indicates why the connection is terminating. After sending the GOAWAY frame, the endpoint MUST close the
         TCP connection.
      </p>
      <p id="rfc.section.3.5.1.p.3">It is possible that the GOAWAY will not be reliably received by the receiving endpoint. In the event of a connection error,
         GOAWAY only provides a best-effort attempt to communicate with the peer about why the connection is being terminated.
      </p>
      <p id="rfc.section.3.5.1.p.4">An endpoint can end a connection at any time. In particular, an endpoint MAY choose to treat a stream error as a connection
         error if the error is recurrent. Endpoints SHOULD send a GOAWAY frame when ending a connection, as long as circumstances permit
         it.
      </p>
      <h3 id="rfc.section.3.5.2"><a href="#rfc.section.3.5.2">3.5.2</a>&nbsp;<a id="StreamErrorHandler" href="#StreamErrorHandler">Stream Error Handling</a></h3>
      <p id="rfc.section.3.5.2.p.1">A stream error is an error related to a specific stream identifier that does not affect processing of other streams at the
         framing layer.
      </p>
      <p id="rfc.section.3.5.2.p.2">An endpoint that detects a stream error sends a RST_STREAM (<a href="#RST_STREAM" title="RST_STREAM">Section&nbsp;3.8.4</a>) frame that contains the stream identifier of the stream where the error occurred. The RST_STREAM frame includes an error code
         that indicates the type of error.
      </p>
      <p id="rfc.section.3.5.2.p.3">A RST_STREAM is the last frame that an endpoint can send on a stream. The peer that sends the RST_STREAM frame MUST be prepared
         to receive any frames that were sent or enqueued for sending by the remote peer. These frames can be ignored, except where
         they modify connection state (such as the state maintained for header compression (<a href="#HeaderBlock" title="Header Blocks">Section&nbsp;3.7</a>)).
      </p>
      <p id="rfc.section.3.5.2.p.4">Normally, an endpoint SHOULD NOT send more than one RST_STREAM frame for any stream. However, an endpoint MAY send additional
         RST_STREAM frames if it receives frames on a closed stream after more than a round trip time. This behavior is permitted to
         deal with misbehaving implementations.
      </p>
      <p id="rfc.section.3.5.2.p.5">An endpoint MUST NOT send a RST_STREAM in response to an RST_STREAM frame, to avoid looping.</p>
      <h3 id="rfc.section.3.5.3"><a href="#rfc.section.3.5.3">3.5.3</a>&nbsp;<a id="ErrorCodes" href="#ErrorCodes">Error Codes</a></h3>
      <p id="rfc.section.3.5.3.p.1">Error codes are 32-bit fields that are used in RST_STREAM and GOAWAY frames to convey the reasons for the stream or connection
         error.
      </p>
      <p id="rfc.section.3.5.3.p.2">Error codes share a common code space. Some error codes only apply to specific conditions and have no defined semantics in
         certain frame types.
      </p>
      <p id="rfc.section.3.5.3.p.3">The following error codes are defined: </p>
      <dl>
         <dt>NO_ERROR (0):</dt>
         <dd>The associated condition is not as a result of an error. For example, a GOAWAY might include this code to indicate graceful
            shutdown of a connection.
         </dd>
         <dt>PROTOCOL_ERROR (1):</dt>
         <dd>The endpoint detected an unspecific protocol error. This error is for use when a more specific error code is not available.</dd>
         <dt>INTERNAL_ERROR (2):</dt>
         <dd>The endpoint encountered an unexpected internal error.</dd>
         <dt>FLOW_CONTROL_ERROR (3):</dt>
         <dd>The endpoint detected that its peer violated the flow control protocol.</dd>
         <dt>INVALID_STREAM (4):</dt>
         <dd>The endpoint received a frame for an inactive stream.</dd>
         <dt>STREAM_CLOSED (5):</dt>
         <dd>The endpoint received a frame after a stream was half-closed.</dd>
         <dt>FRAME_TOO_LARGE (6):</dt>
         <dd>The endpoint received a frame that was larger than the maximum size that it supports.</dd>
         <dt>REFUSED_STREAM (7):</dt>
         <dd>The endpoint is refusing the stream before processing its payload.</dd>
         <dt>CANCEL (8):</dt>
         <dd>Used by the creator of a stream to indicate that the stream is no longer needed.</dd>
         <dt>COMPRESSION_ERROR (9):</dt>
         <dd>The endpoint is unable to maintain the compression context for the connection.</dd>
      </dl>
      <h2 id="rfc.section.3.6"><a href="#rfc.section.3.6">3.6</a>&nbsp;<a id="flowcontrol" href="#flowcontrol">Stream Flow Control</a></h2>
      <p id="rfc.section.3.6.p.1">Using streams for multiplexing introduces contention over use of the TCP connection, resulting in blocked streams. A flow
         control scheme ensures that streams on the same connection do not destructively interfere with each other.
      </p>
      <p id="rfc.section.3.6.p.2">HTTP/2.0 provides for flow control through use of the WINDOW_UPDATE (<a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">Section&nbsp;3.8.10</a>) frame type.
      </p>
      <h3 id="rfc.section.3.6.1"><a href="#rfc.section.3.6.1">3.6.1</a>&nbsp;<a id="fc-principles" href="#fc-principles">Flow Control Principles</a></h3>
      <p id="rfc.section.3.6.1.p.1">Experience with TCP congestion control has shown that algorithms can evolve over time to become more sophisticated without
         requiring protocol changes. TCP congestion control and its evolution is clearly different from HTTP/2.0 flow control, though
         the evolution of TCP congestion control algorithms shows that a similar approach could be feasible for HTTP/2.0 flow control.
      </p>
      <p id="rfc.section.3.6.1.p.2">HTTP/2.0 stream flow control aims to allow for future improvements to flow control algorithms without requiring protocol changes.
         Flow control in HTTP/2.0 has the following characteristics: 
      </p>
      <ol>
         <li>Flow control is hop-by-hop, not end-to-end.</li>
         <li>Flow control is based on window update frames. Receivers advertise how many octets they are prepared to receive on a stream.
            This is a credit-based scheme.
         </li>
         <li>Flow control is directional with overall control provided by the receiver. A receiver MAY choose to set any window size that
            it desires for each stream and for the entire connection. A sender MUST respect flow control limits imposed by a receiver.
            Clients, servers and intermediaries all independently advertise their flow control preferences as a receiver and abide by
            the flow control limits set by their peer when sending.
         </li>
         <li>The initial value for the flow control window is 65536 bytes for both new streams and the overall connection.</li>
         <li>The frame type determines whether flow control applies to a frame. Of the frames specified in this document, only data frames
            are subject to flow control; all other frame types do not consume space in the advertised flow control window. This ensures
            that important control frames are not blocked by flow control.
         </li>
         <li>Flow control can be disabled by a receiver. A receiver can choose to either disable flow control for a stream or connection
            by declaring an infinite flow control limit.
         </li>
         <li>HTTP/2.0 standardizes only the format of the window update frame (<a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">Section&nbsp;3.8.10</a>). This does not stipulate how a receiver decides when to send this frame or the value that it sends. Nor does it specify how
            a sender chooses to send packets. Implementations are able to select any algorithm that suits their needs.
         </li>
      </ol>
      <p id="rfc.section.3.6.1.p.3">Implementations are also responsible for managing how requests and responses are sent based on priority; choosing how to avoid
         head of line blocking for requests; and managing the creation of new streams. Algorithm choices for these could interact with
         any flow control algorithm.
      </p>
      <h3 id="rfc.section.3.6.2"><a href="#rfc.section.3.6.2">3.6.2</a>&nbsp;Appropriate Use of Flow Control
      </h3>
      <p id="rfc.section.3.6.2.p.1">Flow control is defined to protect endpoints (client, server or intermediary) that are operating under resource constraints.
         For example, a proxy needs to share memory between many connections, and also might have a slow upstream connection and a
         fast downstream one. Flow control addresses cases where the receiver is unable process data on one stream, yet wants to continue
         to process other streams in the same connection.
      </p>
      <p id="rfc.section.3.6.2.p.2">Deployments that do not require this capability SHOULD disable flow control for data that is being received. Note that flow
         control cannot be disabled for sending. Sending data is always subject to the flow control window advertised by the receiver.
      </p>
      <p id="rfc.section.3.6.2.p.3">Deployments with constrained resources (for example, memory) MAY employ flow control to limit the amount of memory a peer
         can consume. Note, however, that this can lead to suboptimal use of available network resources if flow control is enabled
         without knowledge of the bandwidth-delay product (see <a href="#RFC1323"><cite title="TCP Extensions for High Performance">[RFC1323]</cite></a>).
      </p>
      <p id="rfc.section.3.6.2.p.4">Even with full awareness of the current bandwidth-delay product, implementation of flow control is difficult. However, it
         can ensure that constrained resources are protected without any reduction in connection utilization.
      </p>
      <h2 id="rfc.section.3.7"><a href="#rfc.section.3.7">3.7</a>&nbsp;<a id="HeaderBlock" href="#HeaderBlock">Header Blocks</a></h2>
      <p id="rfc.section.3.7.p.1">The header block is found in the HEADERS, HEADERS+PRIORITY and PUSH_PROMISE frames. The header block consists of a set of
         header fields, which are name-value pairs. Headers are compressed using black magic.
      </p>
      <p id="rfc.section.3.7.p.2">Compression of header fields is a work in progress, as is the format of this block.</p>
      <p id="rfc.section.3.7.p.3">The contents of header blocks MUST be processed by the compression context, even if stream has been reset or the frame is
         discarded. If header blocks cannot be processed, the receiver MUST treat the connection with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;3.5.1</a>) of type COMPRESSION_ERROR.
      </p>
      <h2 id="rfc.section.3.8"><a href="#rfc.section.3.8">3.8</a>&nbsp;<a id="frame-types" href="#frame-types">Frame Types</a></h2>
      <p id="rfc.section.3.8.p.1">This specification defines a number of frame types, each identified by a unique 8-bit type code. Each frame type serves a
         distinct purpose either in the establishment and management of the connection as a whole, or of individual streams.
      </p>
      <p id="rfc.section.3.8.p.2">The transmission of specific frame types can alter the state of a connection. If endpoints fail to maintain a synchronized
         view of the connection state, successful communication within the connection will no longer be possible. Therefore, it is
         important that endpoints have a shared comprehension of how the state is affected by the use any given frame. Accordingly,
         while it is expected that new frame types will be introduced by extensions to this protocol, only frames defined by this document
         are permitted to alter the connection state.
      </p>
      <h3 id="rfc.section.3.8.1"><a href="#rfc.section.3.8.1">3.8.1</a>&nbsp;<a id="DataFrames" href="#DataFrames">DATA Frames</a></h3>
      <p id="rfc.section.3.8.1.p.1">DATA frames (type=0x0) convey arbitrary, variable-length sequences of octets associated with a stream. One or more DATA frames
         are used, for instance, to carry HTTP request or response payloads.
      </p>
      <p id="rfc.section.3.8.1.p.2">The DATA frame does not define any type-specific flags.</p>
      <p id="rfc.section.3.8.1.p.3">DATA frames MUST be associated with a stream. If a DATA frame is received whose stream identifier field is 0x0, the recipient
         MUST respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;3.5.1</a>) of type PROTOCOL_ERROR.
      </p>
      <h3 id="rfc.section.3.8.2"><a href="#rfc.section.3.8.2">3.8.2</a>&nbsp;<a id="HEADERS_PRIORITY" href="#HEADERS_PRIORITY">HEADERS+PRIORITY</a></h3>
      <p id="rfc.section.3.8.2.p.1">The HEADERS+PRIORITY frame (type=0x1) allows the sender to set header fields and stream priority at the same time.</p>
      <div id="rfc.figure.2"></div><pre class="inline"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|X|                   Priority (31)                             |
+-+-------------------------------------------------------------+
|                    Header Block (*)                         ...
+---------------------------------------------------------------+
</pre><p class="figure">Figure 2: HEADERS+PRIORITY Frame Payload</p>
      <p id="rfc.section.3.8.2.p.3">The HEADERS+PRIORITY frame is identical to the HEADERS frame (<a href="#HEADERS" title="HEADERS">Section&nbsp;3.8.9</a>), preceded by a single reserved bit and a 31-bit priority; see <a href="#StreamPriority" title="Stream priority">Section&nbsp;3.4.2</a>.
      </p>
      <p id="rfc.section.3.8.2.p.4">HEADERS+PRIORITY uses the same flags as the HEADERS frame, except that a HEADERS+PRIORITY frame with a CONTINUES bit MUST
         be followed by another HEADERS+PRIORITY frame. See HEADERS frame (<a href="#HEADERS" title="HEADERS">Section&nbsp;3.8.9</a>) for any flags.
      </p>
      <p id="rfc.section.3.8.2.p.5">HEADERS+PRIORITY frames MUST be associated with a stream. If a HEADERS+PRIORITY frame is received whose stream identifier
         field is 0x0, the recipient MUST respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;3.5.1</a>) of type PROTOCOL_ERROR.
      </p>
      <p id="rfc.section.3.8.2.p.6">The HEADERS+PRIORITY frame modifies the connection state as defined in <a href="#HeaderBlock" title="Header Blocks">Section&nbsp;3.7</a>.
      </p>
      <h3 id="rfc.section.3.8.3"><a href="#rfc.section.3.8.3">3.8.3</a>&nbsp;<a id="PRIORITY" href="#PRIORITY">PRIORITY</a></h3>
      <p id="rfc.section.3.8.3.p.1">The PRIORITY frame (type=0x2) specifies the sender-advised priority of a stream. It can be sent at any time for an existing
         stream. This enables reprioritisation of existing streams.
      </p>
      <div id="rfc.figure.3"></div><pre class="inline"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|X|                   Priority (31)                             |
+-+-------------------------------------------------------------+
</pre><p class="figure">Figure 3: PRIORITY Frame Payload</p>
      <p id="rfc.section.3.8.3.p.3">The payload of a PRIORITY frame contains a single reserved bit and a 31-bit priority.</p>
      <p id="rfc.section.3.8.3.p.4">The PRIORITY frame is associated with an existing stream. If a PRIORITY frame is received with a stream identifier of 0x0,
         the recipient MUST respond with a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;3.5.2</a>) of type PROTOCOL_ERROR.
      </p>
      <h3 id="rfc.section.3.8.4"><a href="#rfc.section.3.8.4">3.8.4</a>&nbsp;<a id="RST_STREAM" href="#RST_STREAM">RST_STREAM</a></h3>
      <p id="rfc.section.3.8.4.p.1">The RST_STREAM frame (type=0x3) allows for abnormal termination of a stream. When sent by the initiator of a stream, it indicates
         that they wish to cancel the stream. When sent by the receiver of a stream, it indicates that either the receiver is rejecting
         the stream, requesting that the stream be cancelled or that an error condition has occurred.
      </p>
      <div id="rfc.figure.4"></div><pre class="inline"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Error Code (32)                       |
+---------------------------------------------------------------+
</pre><p class="figure">Figure 4: RST_STREAM Frame Payload</p>
      <p id="rfc.section.3.8.4.p.3">The RST_STREAM frame contains a single unsigned, 32-bit integer identifying the error code (<a href="#ErrorCodes" title="Error Codes">Section&nbsp;3.5.3</a>). The error code indicates why the stream is being terminated.
      </p>
      <p id="rfc.section.3.8.4.p.4">No type-flags are defined.</p>
      <p id="rfc.section.3.8.4.p.5">The RST_STREAM frame fully terminates the referenced stream and causes it to enter the closed state. After receiving a RST_STREAM
         on a stream, the receiver MUST NOT send additional frames for that stream. However, after sending the RST_STREAM, the sending
         endpoint MUST be prepared to receive and process additional frames sent on the stream that might have been sent by the peer
         prior to the arrival of the RST_STREAM.
      </p>
      <p id="rfc.section.3.8.4.p.6">RST_STREAM frames MUST be associated with a stream. If a RST_STREAM frame is received whose stream identifier field is 0x0
         the recipient MUST respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;3.5.1</a>) of type PROTOCOL_ERROR.
      </p>
      <h3 id="rfc.section.3.8.5"><a href="#rfc.section.3.8.5">3.8.5</a>&nbsp;<a id="SETTINGS" href="#SETTINGS">SETTINGS</a></h3>
      <p id="rfc.section.3.8.5.p.1">The SETTINGS frame (type=0x4) conveys configuration parameters that affect how endpoints communicate. The parameters are either
         constraints on peer behavior or preferences.
      </p>
      <p id="rfc.section.3.8.5.p.2">SETTINGS frames MUST be sent at the start of a connection, and MAY be sent at any other time by either endpoint over the lifetime
         of the connection.
      </p>
      <p id="rfc.section.3.8.5.p.3">Implementations MUST support all of the settings defined by this specification and MAY support additional settings defined
         by extensions. Unsupported or unrecognized settings MUST be ignored. New settings MUST NOT be defined or implemented in a
         way that requires endpoints to understand them in order to communicate successfully.
      </p>
      <p id="rfc.section.3.8.5.p.4">A SETTINGS frame is not required to include every defined setting; senders can include only those parameters for which it
         has accurate values and a need to convey. When multiple parameters are sent, they SHOULD be sent in order of numerically lowest
         ID to highest ID. A single SETTINGS frame MUST NOT contain multiple values for the same ID. If the receiver of a SETTINGS
         frame discovers multiple values for the same ID, it MUST ignore all values for that ID except the first one.
      </p>
      <p id="rfc.section.3.8.5.p.5">Over the lifetime of a connection, an endpoint MAY send multiple SETTINGS frames containing previously unspecified parameters
         or new values for parameters whose values have already been established. Only the most recent value provided setting value
         applies.
      </p>
      <p id="rfc.section.3.8.5.p.6">The SETTINGS frame defines the following flag: </p>
      <dl>
         <dt>CLEAR_PERSISTED (0x2):</dt>
         <dd>Bit 2 being set indicates a request to clear any previously persisted settings before processing the settings. Clients MUST
            NOT set this flag.
         </dd>
      </dl>
      <p id="rfc.section.3.8.5.p.7">SETTINGS frames always apply to a connection, never a single stream. The stream identifier for a settings frame MUST be zero.
         If an endpoint receives a SETTINGS frame whose stream identifier field is anything other than 0x0, the endpoint MUST respond
         with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;3.5.1</a>) of type PROTOCOL_ERROR.
      </p>
      <h4 id="rfc.section.3.8.5.1"><a href="#rfc.section.3.8.5.1">3.8.5.1</a>&nbsp;<a id="SettingFormat" href="#SettingFormat">Setting Format</a></h4>
      <p id="rfc.section.3.8.5.1.p.1">The payload of a SETTINGS frame consists of zero or more settings. Each setting consists of an 8-bit flags field specifying
         per-item instructions, an unsigned 24-bit setting identifier, and an unsigned 32-bit value.
      </p>
      <div id="rfc.figure.5"></div><pre class="inline"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|SettingFlags(8)|             Setting Identifier (24)           |
+---------------+-----------------------------------------------+
|                        Value (32)                             |
+---------------------------------------------------------------+
</pre><p class="figure">Figure 5: Setting Format</p>
      <p id="rfc.section.3.8.5.1.p.3">Two flags are defined for the 8-bit flags field: </p>
      <dl>
         <dt>PERSIST_VALUE (0x1):</dt>
         <dd>Bit 1 (the least significant bit) being set indicates a request from the server to the client to persist this setting. A client
            MUST NOT set this flag.
         </dd>
         <dt>PERSISTED (0x2):</dt>
         <dd>Bit 2 being set indicates that this setting is a persisted setting being returned by the client to the server. This also indicates
            that this setting is not a client setting, but a value previously set by the server. A server MUST NOT set this flag.
         </dd>
      </dl>
      <h4 id="rfc.section.3.8.5.2"><a href="#rfc.section.3.8.5.2">3.8.5.2</a>&nbsp;Setting Persistence
      </h4>
      <p id="rfc.section.3.8.5.2.p.1"> <span class="comment" id="rfc.comment.4">[<a href="#rfc.comment.4" class="smpl">rfc.comment.4</a>: Note that persistence of settings is under discussion in the WG and might be removed in a future version of this document.]</span> 
      </p>
      <p id="rfc.section.3.8.5.2.p.2">A server endpoint can request that configuration parameters sent to a client in a SETTINGS frame are to be persisted by the
         client across HTTP/2.0 connections and returned to the server in any new SETTINGS frame the client sends to the server in
         the current connection or any future connections.
      </p>
      <p id="rfc.section.3.8.5.2.p.3">Persistence is requested on a per-setting basis by setting the PERSIST_VALUE flag (0x1).</p>
      <p id="rfc.section.3.8.5.2.p.4">Client endpoints are not permitted to make such requests. Servers MUST ignore any attempt by clients to request that a server
         persist configuration parameters.
      </p>
      <p id="rfc.section.3.8.5.2.p.5">Persistence of configuration parameters is done on a per-origin basis (see <a href="#RFC6454"><cite title="The Web Origin Concept">[RFC6454]</cite></a>). That is, when a client establishes a connection with a server, and the server requests that the client maintain persistent
         settings, the client SHOULD return the persisted settings on all future connections to the same origin, IP address and TCP
         port.
      </p>
      <p id="rfc.section.3.8.5.2.p.6">Whenever the client sends a SETTINGS frame in the current connection, or establishes a new connection with the same origin,
         persisted configuration parameters are sent with the PERSISTED flag (0x2) set for each persisted parameter.
      </p>
      <p id="rfc.section.3.8.5.2.p.7">Persisted settings accumulate until the server requests that all previously persisted settings are to be cleared by setting
         the CLEAR_PERSISTED (0x2) flag on the SETTINGS frame.
      </p>
      <p id="rfc.section.3.8.5.2.p.8">For example, if the server sends IDs 1, 2, and 3 with the FLAG_SETTINGS_PERSIST_VALUE in a first SETTINGS frame, and then
         sends IDs 4 and 5 with the FLAG_SETTINGS_PERSIST_VALUE in a subsequent SETTINGS frame, the client will return values for all
         5 settings (1, 2, 3, 4, and 5 in this example) to the server.
      </p>
      <h4 id="rfc.section.3.8.5.3"><a href="#rfc.section.3.8.5.3">3.8.5.3</a>&nbsp;<a id="SettingValues" href="#SettingValues">Defined Settings</a></h4>
      <p id="rfc.section.3.8.5.3.p.1">The following settings are defined: </p>
      <dl>
         <dt>SETTINGS_UPLOAD_BANDWIDTH (1):</dt>
         <dd>
            <p>indicates the sender's estimated upload bandwidth for this connection. The value is an the integral number of kilobytes per
               second that the sender predicts as an expected maximum upload channel capacity.
            </p>
         </dd>
         <dt>SETTINGS_DOWNLOAD_BANDWIDTH (2):</dt>
         <dd>
            <p>indicates the sender's estimated download bandwidth for this connection. The value is an integral number of kilobytes per
               second that the sender predicts as an expected maximum download channel capacity.
            </p>
         </dd>
         <dt>SETTINGS_ROUND_TRIP_TIME (3):</dt>
         <dd>
            <p>indicates the sender's estimated round-trip-time for this connection. The round trip time is defined as the minimum amount
               of time to send a control frame from this client to the remote and receive a response. The value is represented in milliseconds.
            </p>
         </dd>
         <dt>SETTINGS_MAX_CONCURRENT_STREAMS (4):</dt>
         <dd>
            <p>indicates the maximum number of concurrent streams that the sender will allow. This limit is directional: it applies to the
               number of streams that the sender permits the receiver to create. By default there is no limit. It is recommended that this
               value be no smaller than 100, so as to not unnecessarily limit parallelism.
            </p>
         </dd>
         <dt>SETTINGS_CURRENT_CWND (5):</dt>
         <dd>
            <p>indicates the sender's current TCP CWND value.</p>
         </dd>
         <dt>SETTINGS_DOWNLOAD_RETRANS_RATE (6):</dt>
         <dd>
            <p>indicates the sender's retransmission rate (bytes retransmitted / total bytes transmitted).</p>
         </dd>
         <dt>SETTINGS_INITIAL_WINDOW_SIZE (7):</dt>
         <dd>
            <p>indicates the sender's initial stream window size (in bytes) for new streams.</p>
         </dd>
         <dt>SETTINGS_FLOW_CONTROL_OPTIONS (10):</dt>
         <dd>
            <p>indicates that streams directed to the sender will not be subject to flow control. The least significant bit (0x1) is set
               to indicate that new streams are not flow controlled. All other bits are reserved.
            </p>
            <p>This setting applies to all streams, including existing streams.</p>
            <p>These bits cannot be cleared once set, see <a href="#EndFlowControl" title="Ending Flow Control">Section&nbsp;3.8.10.4</a>.
            </p>
         </dd>
      </dl>
      <h3 id="rfc.section.3.8.6"><a href="#rfc.section.3.8.6">3.8.6</a>&nbsp;<a id="PUSH_PROMISE" href="#PUSH_PROMISE">PUSH_PROMISE</a></h3>
      <p id="rfc.section.3.8.6.p.1">The PUSH_PROMISE frame (type=0x5) is used to notify the peer endpoint in advance of streams the sender intends to initiate.
         The PUSH_PROMISE frame includes the unsigned 31-bit identifier of the stream the endpoint plans to create along with a minimal
         set of headers that provide additional context for the stream. <a href="#PushResources" title="Server Push Transactions">Section&nbsp;4.3</a> contains a thorough description of the use of PUSH_PROMISE frames.
      </p>
      <div id="rfc.figure.6"></div><pre class="inline"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|X|                Promised-Stream-ID (31)                      |
+-+-------------------------------------------------------------+
|                    Header Block (*)                         ...
+---------------------------------------------------------------+
</pre><p class="figure">Figure 6: PUSH_PROMISE Payload Format</p>
      <p id="rfc.section.3.8.6.p.3">The payload of a PUSH_PROMISE includes a "Promised-Stream-ID". This unsigned 31-bit integer identifies the stream the endpoint
         intends to start sending frames for. The promised stream identifier MUST be a valid choice for the next stream sent by the
         sender (see new stream identifier (<a href="#StreamCreation" title="Stream Creation">Section&nbsp;3.4.1</a>)).
      </p>
      <p id="rfc.section.3.8.6.p.4">PUSH_PROMISE frames MUST be associated with an existing stream. If the stream identifier field specifies the value 0x0, a
         recipient MUST respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;3.5.1</a>) of type PROTOCOL_ERROR.
      </p>
      <p id="rfc.section.3.8.6.p.5">The state of promised streams is bound to the state of the original associated stream on which the PUSH_PROMISE frame were
         sent. If the originating stream state changes to fully closed, all associated promised streams fully close as well. <span class="comment" id="rfc.comment.5">[<a href="#rfc.comment.5" class="smpl">rfc.comment.5</a>: Ed. Note: We need clarification on this point. How synchronized are the lifecycles of streams and associated promised streams?]</span> 
      </p>
      <p id="rfc.section.3.8.6.p.6">PUSH_PROMISE uses the same flags as the HEADERS frame, except that a PUSH_PROMISE frame with a CONTINUES bit MUST be followed
         by another PUSH_PROMISE frame. See HEADERS frame (<a href="#HEADERS" title="HEADERS">Section&nbsp;3.8.9</a>) for any flags.
      </p>
      <p id="rfc.section.3.8.6.p.7">Promised streams are not required to be used in order promised. The PUSH_PROMISE only reserves stream identifiers for later
         use.
      </p>
      <p id="rfc.section.3.8.6.p.8">Recipients of PUSH_PROMISE frames can choose to reject promised streams by returning a RST_STREAM referencing the promised
         stream identifier back to the sender of the PUSH_PROMISE.
      </p>
      <p id="rfc.section.3.8.6.p.9">The PUSH_PROMISE frame modifies the connection state as defined in <a href="#HeaderBlock" title="Header Blocks">Section&nbsp;3.7</a>.
      </p>
      <h3 id="rfc.section.3.8.7"><a href="#rfc.section.3.8.7">3.8.7</a>&nbsp;<a id="PING" href="#PING">PING</a></h3>
      <p id="rfc.section.3.8.7.p.1">The PING frame (type=0x6) is a mechanism for measuring a minimal round-trip time from the sender, as well as determining whether
         an idle connection is still functional. PING frames can be sent from any endpoint.
      </p>
      <p id="rfc.section.3.8.7.p.2">PING frames consist of an arbitrary, variable-length sequence of octets. Receivers of a PING send a response PING frame with
         the PONG flag set and precisely the same sequence of octets back to the sender as soon as possible.
      </p>
      <p id="rfc.section.3.8.7.p.3">Processing of PING frames SHOULD be performed with the highest priority if there are additional frames waiting to be processed.</p>
      <p id="rfc.section.3.8.7.p.4">The PING frame defines one type-specific flag: </p>
      <dl>
         <dt>PONG (0x2):</dt>
         <dd>Bit 2 being set indicates that this PING frame is a PING response. An endpoint MUST set this flag in PING responses. An endpoint
            MUST NOT respond to PING frames containing this flag.
         </dd>
      </dl>
      <p id="rfc.section.3.8.7.p.5">PING frames are not associated with any individual stream. If a PING frame is received with a stream identifier field value
         other than 0x0, the recipient MUST respond with a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;3.5.1</a>) of type PROTOCOL_ERROR.
      </p>
      <h3 id="rfc.section.3.8.8"><a href="#rfc.section.3.8.8">3.8.8</a>&nbsp;<a id="GOAWAY" href="#GOAWAY">GOAWAY</a></h3>
      <p id="rfc.section.3.8.8.p.1">The GOAWAY frame (type=0x7) informs the remote peer to stop creating streams on this connection. It can be sent from the client
         or the server. Once sent, the sender will ignore frames sent on new streams for the remainder of the connection. Receivers
         of a GOAWAY frame MUST NOT open additional streams on the connection, although a new connection can be established for new
         streams. The purpose of this frame is to allow an endpoint to gracefully stop accepting new streams (perhaps for a reboot
         or maintenance), while still finishing processing of previously established streams.
      </p>
      <p id="rfc.section.3.8.8.p.2">There is an inherent race condition between an endpoint starting new streams and the remote sending a GOAWAY frame. To deal
         with this case, the GOAWAY contains the stream identifier of the last stream which was processed on the sending endpoint in
         this connection. If the receiver of the GOAWAY used streams that are newer than the indicated stream identifier, they were
         not processed by the sender and the receiver may treat the streams as though they had never been created at all (hence the
         receiver may want to re-create the streams later on a new connection).
      </p>
      <p id="rfc.section.3.8.8.p.3">Endpoints should always send a GOAWAY frame before closing a connection so that the remote can know whether a stream has been
         partially processed or not. (For example, if an HTTP client sends a POST at the same time that a server closes a connection,
         the client cannot know if the server started to process that POST request if the server does not send a GOAWAY frame to indicate
         where it stopped working).
      </p>
      <p id="rfc.section.3.8.8.p.4">After sending a GOAWAY frame, the sender can ignore frames for new streams.</p>
      <p id="rfc.section.3.8.8.p.5"> <span class="comment" id="rfc.comment.6">[<a href="#rfc.comment.6" class="smpl">rfc.comment.6</a>: Issue: connection state that is established by those "ignored" frames cannot be ignored without the state in the two peers
            becoming unsynchronized.]</span> 
      </p>
      <div id="rfc.figure.7"></div><pre class="inline"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|X|                  Last-Stream-ID (31)                        |
+-+-------------------------------------------------------------+
|                      Error Code (32)                          |
+---------------------------------------------------------------+
</pre><p class="figure">Figure 7: GOAWAY Payload Format</p>
      <p id="rfc.section.3.8.8.p.7">The GOAWAY frame does not define any type-specific flags.</p>
      <p id="rfc.section.3.8.8.p.8">The GOAWAY frame applies to the connection, not a specific stream. The stream identifier MUST be zero.</p>
      <p id="rfc.section.3.8.8.p.9">The last stream identifier in the GOAWAY frame contains the highest numbered stream identifier for which the sender of the
         GOAWAY frame has received frames on and might have taken some action on. All streams up to and including the identified stream
         might have been processed in some way. The last stream identifier is set to 0 if no streams were processed. 
      </p>
      <ul class="empty">
         <li>Note: In this case, "processed" means that some data from the stream was passed to some higher layer of software that might
            have taken some action as a result.
         </li>
      </ul>
      <p id="rfc.section.3.8.8.p.10">On streams with lower or equal numbered identifiers that do not close completely prior to the connection being closed, re-attempting
         requests, transactions, or any protocol activity is not possible (with the exception of idempotent actions like HTTP GET,
         PUT, or DELETE). Any protocol activity that uses higher numbered streams can be safely retried using a new connection.
      </p>
      <p id="rfc.section.3.8.8.p.11">Activity on streams numbered lower or equal to the last stream identifier might still complete successfully. The sender of
         a GOAWAY frame gracefully shut down a connection by sending a GOAWAY frame, maintaining the connection in an open state until
         all in-progress streams complete.
      </p>
      <p id="rfc.section.3.8.8.p.12">The last stream ID MUST be 0 if no streams were acted upon.</p>
      <p id="rfc.section.3.8.8.p.13">The GOAWAY frame also contains a 32-bit error code (<a href="#ErrorCodes" title="Error Codes">Section&nbsp;3.5.3</a>) that contains the reason for closing the connection.
      </p>
      <h3 id="rfc.section.3.8.9"><a href="#rfc.section.3.8.9">3.8.9</a>&nbsp;<a id="HEADERS" href="#HEADERS">HEADERS</a></h3>
      <p id="rfc.section.3.8.9.p.1">The HEADERS frame (type=0x8) provides header fields for a stream. Any number of HEADERS frames can may be sent on an existing
         stream at any time.
      </p>
      <p id="rfc.section.3.8.9.p.2">Additional type-specific flags for the HEADERS frame are: </p>
      <dl>
         <dt>CONTINUES (0x2):</dt>
         <dd>The CONTINUES bit indicates that this frame does not contain the entire payload necessary to provide a complete set of headers. <br><br> The payload for a complete set of headers is provided by a sequence of HEADERS frames, terminated by a HEADERS frame without
            the CONTINUES bit. Once the sequence terminates, the payload of all HEADERS frames are concatenated and interpreted as a single
            block. <br><br> A HEADERS frame that includes a CONTINUES bit MUST be followed by a HEADERS frame for the same stream. A receiver MUST treat
            the receipt of any other type of frame or a frame on a different stream as a connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;3.5.1</a>) of type PROTOCOL_ERROR.
         </dd>
      </dl>
      <p id="rfc.section.3.8.9.p.3">The payload of a HEADERS frame contains a Headers Block (<a href="#HeaderBlock" title="Header Blocks">Section&nbsp;3.7</a>).
      </p>
      <p id="rfc.section.3.8.9.p.4">The HEADERS frame is associated with an existing stream. If a HEADERS frame is received with a stream identifier of 0x0, the
         recipient MUST respond with a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;3.5.2</a>) of type PROTOCOL_ERROR.
      </p>
      <p id="rfc.section.3.8.9.p.5">The HEADERS frame changes the connection state as defined in <a href="#HeaderBlock" title="Header Blocks">Section&nbsp;3.7</a>.
      </p>
      <h3 id="rfc.section.3.8.10"><a href="#rfc.section.3.8.10">3.8.10</a>&nbsp;<a id="WINDOW_UPDATE" href="#WINDOW_UPDATE">WINDOW_UPDATE</a></h3>
      <p id="rfc.section.3.8.10.p.1">The WINDOW_UPDATE frame (type=0x9) is used to implement flow control.</p>
      <p id="rfc.section.3.8.10.p.2">Flow control operates at two levels: on each individual stream and on the entire connection.</p>
      <p id="rfc.section.3.8.10.p.3">Both types of flow control are hop by hop; that is, only between the two endpoints. Intermediaries do not forward WINDOW_UPDATE
         frames between dependent connections. However, throttling of data transfer by any receiver can indirectly cause the propagation
         of flow control information toward the original sender.
      </p>
      <p id="rfc.section.3.8.10.p.4">Flow control only applies to frames that are identified as being subject to flow control. Of the frame types defined in this
         document, this includes only DATA frame. Frames that are exempt from flow control MUST be accepted and processed, unless the
         receiver is unable to assign resources to handling the frame. A receiver MAY respond with a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;3.5.2</a>) or connection error (<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section&nbsp;3.5.1</a>) of type FLOW_CONTROL_ERROR if it is unable accept a frame.
      </p>
      <p id="rfc.section.3.8.10.p.5">The following additional flags are defined for the WINDOW_UPDATE frame: </p>
      <dl>
         <dt>END_FLOW_CONTROL (0x2):</dt>
         <dd>Bit 2 being set indicates that flow control for the identified stream or connection has been ended; subsequent frames do not
            need to be flow controlled.
         </dd>
      </dl>
      <p id="rfc.section.3.8.10.p.6">The WINDOW_UPDATE frame can be specific to a stream or to the entire connection. In the former case, the frame's stream identifier
         indicates the affected stream; in the latter, the value "0" indicates that the entire connection is the subject of the frame.
      </p>
      <p id="rfc.section.3.8.10.p.7">The payload of a WINDOW_UPDATE frame is a 32-bit value indicating the additional number of bytes that the sender can transmit
         in addition to the existing flow control window. The legal range for this field is 1 to 2<sup>31</sup> - 1 (0x7fffffff) bytes; the most significant bit of this value is reserved.
      </p>
      <h4 id="rfc.section.3.8.10.1"><a href="#rfc.section.3.8.10.1">3.8.10.1</a>&nbsp;The Flow Control Window
      </h4>
      <p id="rfc.section.3.8.10.1.p.1">Flow control in HTTP/2.0 is implemented using a window kept by each sender on every stream. The flow control window is a simple
         integer value that indicates how many bytes of data the sender is permitted to transmit; as such, its size is a measure of
         the buffering capability of the receiver.
      </p>
      <p id="rfc.section.3.8.10.1.p.2">Two flow control windows are applicable; the stream flow control window and the connection flow control window. The sender
         MUST NOT send a flow controlled frame with a length that exceeds the space available in either of the flow control windows
         advertised by the receiver. Frames with zero length with the FINAL flag set (for example, an empty data frame) MAY be sent
         if there is no available space in either flow control window.
      </p>
      <p id="rfc.section.3.8.10.1.p.3">For flow control calculations, the 8 byte frame header is not counted.</p>
      <p id="rfc.section.3.8.10.1.p.4">After sending a flow controlled frame, the sender reduces the space available in both windows by the length of the transmitted
         frame.
      </p>
      <p id="rfc.section.3.8.10.1.p.5">The receiver of a frame sends a WINDOW_UPDATE frame as it consumes data and frees up space in flow control windows. Separate
         WINDOW_UPDATE frames are sent for the stream and connection level flow control windows.
      </p>
      <p id="rfc.section.3.8.10.1.p.6">A sender that receives a WINDOW_UPDATE frame updates the corresponding window by the amount specified in the frame.</p>
      <p id="rfc.section.3.8.10.1.p.7">A sender MUST NOT allow a flow control window to exceed 2<sup>31</sup> - 1 bytes. If a sender receives a WINDOW_UPDATE that causes a flow control window to exceed this maximum it MUST terminate
         either the stream or the connection, as appropriate. For streams, the sender sends a RST_STREAM with the error code of FLOW_CONTROL_ERROR
         code; for the connection, a GOAWAY frame with a FLOW_CONTROL_ERROR code.
      </p>
      <p id="rfc.section.3.8.10.1.p.8">Flow controlled frames from the sender and WINDOW_UPDATE frames from the receiver are completely asynchronous with respect
         to each other. This property allows a receiver to aggressively update the window size kept by the sender to prevent streams
         from stalling.
      </p>
      <h4 id="rfc.section.3.8.10.2"><a href="#rfc.section.3.8.10.2">3.8.10.2</a>&nbsp;Initial Flow Control Window Size
      </h4>
      <p id="rfc.section.3.8.10.2.p.1">When a HTTP/2.0 connection is first established, new streams are created with an initial flow control window size of 65535
         bytes. The connection flow control window is 65536 bytes. Both endpoints can adjust the initial window size for new streams
         by including a value for SETTINGS_INITIAL_WINDOW_SIZE in the SETTINGS frame that forms part of the connection header.
      </p>
      <p id="rfc.section.3.8.10.2.p.2">Prior to receiving a SETTINGS frame that sets a value for SETTINGS_INITIAL_WINDOW_SIZE, a client can only use the default
         initial window size when sending flow controlled frames. Similarly, the connection flow control window is set to the default
         initial window size until a WINDOW_UPDATE frame is received.
      </p>
      <p id="rfc.section.3.8.10.2.p.3">A SETTINGS frame can alter the initial flow control window size for all current streams. When the value of SETTINGS_INITIAL_WINDOW_SIZE
         changes, a receiver MUST adjust the size of all flow control windows that it maintains by the difference between the new value
         and the old value.
      </p>
      <p id="rfc.section.3.8.10.2.p.4">A change to SETTINGS_INITIAL_WINDOW_SIZE could cause the available space in a flow control window to become negative. A sender
         MUST track the negative flow control window, and MUST NOT send new flow controlled frames until it receives WINDOW_UPDATE
         frames that cause the flow control window to become positive.
      </p>
      <p id="rfc.section.3.8.10.2.p.5">For example, if the server sets the initial window size to be 16KB, and the client sends 64KB immediately on connection establishment,
         the client will recalculate the available flow control window to be -48KB on receipt of the SETTINGS frame. The client retains
         a negative flow control window until WINDOW_UPDATE frames restore the window to being positive, after which the client can
         resume sending.
      </p>
      <h4 id="rfc.section.3.8.10.3"><a href="#rfc.section.3.8.10.3">3.8.10.3</a>&nbsp;Reducing the Stream Window Size
      </h4>
      <p id="rfc.section.3.8.10.3.p.1">A receiver that wishes to use a smaller flow control window than the current size can send a new SETTINGS frame. However,
         the receiver MUST be prepared to receive data that exceeds this window size, since the sender might send data that exceeds
         the lower limit prior to processing the SETTINGS frame.
      </p>
      <p id="rfc.section.3.8.10.3.p.2">A receiver has two options for handling streams that exceed flow control limits: </p>
      <ol>
         <li>The receiver can immediately send RST_STREAM with FLOW_CONTROL_ERROR error code for the affected streams.</li>
         <li>The receiver can accept the streams and tolerate the resulting head of line blocking, sending WINDOW_UPDATE frames as it consumes
            data.
         </li>
      </ol>
      <p> If a receiver decides to accept streams, both sides MUST recompute the available flow control window based on the initial
         window size sent in the SETTINGS.
      </p>
      <h4 id="rfc.section.3.8.10.4"><a href="#rfc.section.3.8.10.4">3.8.10.4</a>&nbsp;<a id="EndFlowControl" href="#EndFlowControl">Ending Flow Control</a></h4>
      <p id="rfc.section.3.8.10.4.p.1">After a receiver reads in a frame that marks the end of a stream (for example, a data stream with a FINAL flag set), it MUST
         cease transmission of WINDOW_UPDATE frames for that stream. A sender is not obligated to maintain the available flow control
         window for streams that it is no longer sending on.
      </p>
      <p id="rfc.section.3.8.10.4.p.2">Flow control can be disabled for all streams or the connection using the SETTINGS_FLOW_CONTROL_OPTIONS setting. An implementation
         that does not wish to perform flow control can use this in the initial SETTINGS exchange.
      </p>
      <p id="rfc.section.3.8.10.4.p.3">Flow control can be disabled for an individual stream or the overall connection by sending a WINDOW_UPDATE with the END_FLOW_CONTROL
         flag set. The payload of a WINDOW_UPDATE frame that has the END_FLOW_CONTROL flag set is ignored.
      </p>
      <p id="rfc.section.3.8.10.4.p.4">Flow control cannot be enabled again once disabled. Any attempt to re-enable flow control - by sending a WINDOW_UPDATE or
         by clearing the bits on the SETTINGS_FLOW_CONTROL_OPTIONS setting - MUST be rejected with a FLOW_CONTROL_ERROR error code.
      </p>
      <h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a>&nbsp;<a id="HTTPLayer" href="#HTTPLayer">HTTP Message Exchanges</a></h1>
      <p id="rfc.section.4.p.1">HTTP/2.0 is intended to be as compatible as possible with current web-based applications. This means that, from the perspective
         of the server business logic or application API, the features of HTTP are unchanged. To achieve this, all of the application
         request and response header semantics are preserved, although the syntax of conveying those semantics has changed. Thus, the
         rules from HTTP/1.1 (<a href="#HTTP-p1"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[HTTP-p1]</cite></a>, <a href="#HTTP-p2"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[HTTP-p2]</cite></a>, <a href="#HTTP-p4"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests">[HTTP-p4]</cite></a>, <a href="#HTTP-p5"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Range Requests">[HTTP-p5]</cite></a>, <a href="#HTTP-p6"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[HTTP-p6]</cite></a>, and <a href="#HTTP-p7"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Authentication">[HTTP-p7]</cite></a>) apply with the changes in the sections below.
      </p>
      <h2 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1</a>&nbsp;Connection Management
      </h2>
      <p id="rfc.section.4.1.p.1">Clients SHOULD NOT open more than one HTTP/2.0 connection to a given origin (<a href="#RFC6454"><cite title="The Web Origin Concept">[RFC6454]</cite></a>) concurrently.
      </p>
      <p id="rfc.section.4.1.p.2">Note that it is possible for one HTTP/2.0 connection to be finishing (e.g. a GOAWAY frame has been sent, but not all streams
         have finished), while another HTTP/2.0 connection is starting.
      </p>
      <h2 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2</a>&nbsp;HTTP Request/Response
      </h2>
      <h3 id="rfc.section.4.2.1"><a href="#rfc.section.4.2.1">4.2.1</a>&nbsp;HTTP Header Fields and HTTP/2.0 Headers
      </h3>
      <p id="rfc.section.4.2.1.p.1">At the application level, HTTP uses name-value pairs in its header fields. Because HTTP/2.0 merges the existing HTTP header
         fields with HTTP/2.0 headers, there is a possibility that some HTTP applications already use a particular header field name.
         To avoid any conflicts, all header fields introduced for layering HTTP over HTTP/2.0 are prefixed with ":". ":" is not a valid
         sequence in HTTP/1.* header field naming, preventing any possible conflict.
      </p>
      <h3 id="rfc.section.4.2.2"><a href="#rfc.section.4.2.2">4.2.2</a>&nbsp;<a id="HttpRequest" href="#HttpRequest">Request</a></h3>
      <p id="rfc.section.4.2.2.p.1">The client initiates a request by sending a HEADERS+PRIORITY frame. Requests that do not contain a body MUST set the FINAL
         flag, indicating that the client intends to send no further data on this stream, unless the server intends to push resources
         (see <a href="#PushResources" title="Server Push Transactions">Section&nbsp;4.3</a>). HEADERS+PRIORITY frame does not contain the FINAL flag for requests that contain a body. The body of a request follows
         as a series of DATA frames. The last DATA frame sets the FINAL flag to indicate the end of the body.
      </p>
      <p id="rfc.section.4.2.2.p.2">The header fields included in the HEADERS+PRIORITY frame contain all of the HTTP header fields associated with an HTTP request.
         The definitions of these headers are largely unchanged relative to HTTP/1.1, with a few notable exceptions: 
      </p>
      <ul>
         <li>The HTTP/1.1 request-line has been split into two separate header fields named :method and :path, whose values specify the
            HTTP method for the request and the request-target, respectively. The HTTP-version component of the request-line is removed
            entirely from the headers.
         </li>
         <li>The host and optional port portions of the request URI (see <a href="#RFC3986"><cite title="Uniform Resource Identifier (URI): Generic Syntax">[RFC3986]</cite></a>, Section 3.2), is specified using the new :host header field. <span class="comment" id="rfc.comment.7">[<a href="#rfc.comment.7" class="smpl">rfc.comment.7</a>: Ed. Note: it needs to be clarified whether or not this replaces the existing HTTP/1.1 Host header.]</span></li>
         <li>A new :scheme header field has been added to specify the scheme portion of the request-target (e.g. "https")</li>
         <li>All header field names MUST be lowercased, and the definitions of all header field names defined by HTTP/1.1 are updated to
            be all lowercase.
         </li>
         <li>The Connection, Host, Keep-Alive, Proxy-Connection, and Transfer-Encoding header fields are no longer valid and MUST NOT be
            sent.
         </li>
      </ul>
      <p id="rfc.section.4.2.2.p.3">All HTTP Requests MUST include the ":method", ":path", ":host", and ":scheme" header fields.</p>
      <p id="rfc.section.4.2.2.p.4">Header fields whose names begin with ":" (whether defined in this document or future extensions to this document) MUST appear
         before any other header fields.
      </p>
      <p id="rfc.section.4.2.2.p.5">If a client sends a HEADERS+PRIORITY frame that omits a mandatory header, the server MUST reply with a HTTP 400 Bad Request
         reply. <span class="comment" id="rfc.comment.8">[<a href="#rfc.comment.8" class="smpl">rfc.comment.8</a>: Ed: why PROTOCOL_ERROR on missing ":status" in the response, but HTTP 400 here?]</span> 
      </p>
      <p id="rfc.section.4.2.2.p.6">If a server receives a request where the sum of the data frame payload lengths does not equal the size of the Content-Length
         header field, the server MUST return a 400 (Bad Request) error.
      </p>
      <p id="rfc.section.4.2.2.p.7">Although POSTs are inherently chunked, POST requests SHOULD also be accompanied by a Content-Length header field. First, it
         informs the server of how much data to expect, which the server can use to track overall progress and provide appropriate
         user feedback. More importantly, some HTTP server implementations fail to correctly process requests that omit the Content-Length
         header field. Many existing clients send a Content-Length header field, and some server implementations have come to depend
         upon its presence.
      </p>
      <p id="rfc.section.4.2.2.p.8">A client provides priority in requests as a hint to the server. A server SHOULD attempt to provide responses to higher priority
         requests before lower priority requests. A server could send lower priority responses during periods that higher priority
         responses are unavailable to ensure better utilization of a connection.
      </p>
      <p id="rfc.section.4.2.2.p.9">If the server receives a data frame prior to a HEADERS+PRIORITY frame the server MUST treat this as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;3.5.2</a>) of type PROTOCOL_ERROR.
      </p>
      <h3 id="rfc.section.4.2.3"><a href="#rfc.section.4.2.3">4.2.3</a>&nbsp;<a id="HttpResponse" href="#HttpResponse">Response</a></h3>
      <p id="rfc.section.4.2.3.p.1">The server responds to a client request using the same stream identifier that was used by the request. An HTTP response begins
         with a HEADERS frame. An HTTP response body consists of a series of DATA frames. The last data frame contains a FINAL flag
         to indicate the end of the response. A response that contains no body (such as a 204 or 304 response) consists only of a HEADERS
         frame that contains the FINAL flag to indicate no further data will be sent on the stream.
      </p>
      <p id="rfc.section.4.2.3.p.2"> </p>
      <ul class="empty">
         <li>The response status line is unfolded into name-value pairs like other HTTP header fields and must be present: 
            <dl>
               <dt>":status":</dt>
               <dd>The HTTP response status code (e.g. "200" or "200 OK")</dd>
            </dl> 
         </li>
         <li>All header field names starting with ":" (whether defined in this document or future extensions to this document) MUST appear
            before any other header fields.
         </li>
         <li>All header field names MUST be all lowercase.</li>
         <li>The Connection, Keep-Alive, Proxy-Connection, and Transfer-Encoding header fields are not valid and MUST NOT be sent.</li>
         <li>Responses MAY be accompanied by a Content-Length header field for advisory purposes. This allows clients to learn the full
            size of an entity prior to receiving all the data frames. This can help in, for example, reporting progress.
         </li>
         <li>If a client receives a response where the sum of the data frame payload length does not equal the size of the Content-Length
            header field, the client MUST ignore the content length header field. <span class="comment" id="rfc.comment.9">[<a href="#rfc.comment.9" class="smpl">rfc.comment.9</a>: Ed: See <a href="https://github.com/http2/http2-spec/issues/46">issue 46</a>.]</span> 
         </li>
      </ul>
      <p id="rfc.section.4.2.3.p.3">If a client receives a response with an absent or duplicated status header, the client MUST treat this as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;3.5.2</a>) of type PROTOCOL_ERROR.
      </p>
      <p id="rfc.section.4.2.3.p.4">If the client receives a data frame prior to a HEADERS frame the client MUST treat this as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;3.5.2</a>) of type PROTOCOL_ERROR.
      </p>
      <p id="rfc.section.4.2.3.p.5">Clients MUST support gzip compression. Regardless of the value of the Accept-Encoding header field, a server MAY send responses
         with gzip or deflate encoding. A compressed response MUST still bear an appropriate Content-Encoding header field.
      </p>
      <h2 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3</a>&nbsp;<a id="PushResources" href="#PushResources">Server Push Transactions</a></h2>
      <p id="rfc.section.4.3.p.1">HTTP/2.0 enables a server to send multiple replies to a client for a single request. The rationale for this feature is that
         sometimes a server knows that it will need to send multiple resources in response to a single request. Without server push
         features, the client must first download the primary resource, then discover the secondary resource(s), and request them.
      </p>
      <p id="rfc.section.4.3.p.2">Server push is an optional feature. The SETTINGS_MAX_CONCURRENT_STREAMS setting from the client limits the number of resources
         that can be concurrently pushed by a server. Server push can be disabled by clients that do not wish to receive pushed resources
         by advertising a SETTINGS_MAX_CONCURRENT_STREAMS SETTING (<a href="#SETTINGS" title="SETTINGS">Section&nbsp;3.8.5</a>) of zero. This prevents servers from creating the streams necessary to push resources.
      </p>
      <p id="rfc.section.4.3.p.3">Clients receiving a pushed response MUST validate that the server is authorized to push the resource using the same-origin
         policy (<a href="#RFC6454"><cite title="The Web Origin Concept">[RFC6454]</cite></a>, <a href="http://tools.ietf.org/html/rfc6454#section-3">Section 3</a>). For example, a HTTP/2.0 connection to <samp>example.com</samp> is generally <span class="comment" id="rfc.comment.10">[<a href="#rfc.comment.10" class="smpl">rfc.comment.10</a>: Ed: weaselly use of "generally", needs better definition]</span> not permitted to push a response for <samp>www.example.org</samp>.
      </p>
      <p id="rfc.section.4.3.p.4">A client that accepts pushed resources caches those resources as though they were responses to GET requests.</p>
      <p id="rfc.section.4.3.p.5">Pushing of resources avoids the round-trip delay, but also creates a potential race where a server can be pushing content
         which a client is in the process of requesting. The PUSH_PROMISE frame reduces the chances of this condition occurring, while
         retaining the performance benefit.
      </p>
      <p id="rfc.section.4.3.p.6">Pushed responses are associated with a request at the HTTP/2.0 framing layer. The PUSH_PROMISE is sent on the stream for the
         associated request, which allows a receiver to correlate the pushed resource with a request. The pushed stream inherits all
         of the request header fields from the associated stream with the exception of resource identification header fields (<samp>:host</samp>, <samp>:scheme</samp>, and <samp>:path</samp>), which are provided as part of the PUSH_PROMISE frame.
      </p>
      <p id="rfc.section.4.3.p.7">Pushed resources always have an associated <samp>:method</samp> of <samp>GET</samp>. A cache MUST store these inherited and implied request header fields with the cached resource.
      </p>
      <h3 id="rfc.section.4.3.1"><a href="#rfc.section.4.3.1">4.3.1</a>&nbsp;Server implementation
      </h3>
      <p id="rfc.section.4.3.1.p.1">A server pushes resources in association with a request from the client. Prior to closing the response stream, the server
         sends a PUSH_PROMISE for each resource that it intends to push. The PUSH_PROMISE includes header fields that allow the client
         to identify the resource (<samp>:scheme</samp>, <samp>:host</samp>, and <samp>:path</samp>).
      </p>
      <p id="rfc.section.4.3.1.p.2">A server can push multiple resources in response to a request, but all pushed resources MUST be promised on the response stream
         for the associated request. A server cannot send a PUSH_PROMISE on a new stream or a half-closed stream.
      </p>
      <p id="rfc.section.4.3.1.p.3">The server SHOULD include any header fields in a PUSH_PROMISE that would allow a cache to determine if the resource is already
         cached (see <a href="#HTTP-p6"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[HTTP-p6]</cite></a>, <a href="http://tools.ietf.org/html/draft-ietf-httpbis-p6-cache-22#section-4">Section 4</a>).
      </p>
      <p id="rfc.section.4.3.1.p.4">After sending a PUSH_PROMISE, the server commences transmission of a pushed resource. A pushed resource uses a server-initiated
         stream. The server sends frames on this stream in the same order as an HTTP response (<a href="#HttpResponse" title="Response">Section&nbsp;4.2.3</a>): a HEADERS frame followed by DATA frames.
      </p>
      <p id="rfc.section.4.3.1.p.5">Many uses of server push are to send content that a client is likely to discover a need for based on the content of a response
         representation. To minimize the chances that a client will make a request for resources that are being pushed - causing duplicate
         copies of a resource to be sent by the server - a PUSH_PROMISE frame SHOULD be sent prior to any content in the response representation
         that might allow a client to discover the pushed resource and request it.
      </p>
      <p id="rfc.section.4.3.1.p.6">The server MUST only push resources that could have been returned from a GET request.</p>
      <p id="rfc.section.4.3.1.p.7">Note: A server does not need to have all response header fields available at the time it issues a PUSH_PROMISE frame. All
         remaining header fields are included in the HEADERS frame. The HEADERS frame MUST NOT duplicate header fields from the PUSH_PROMISE
         frames.
      </p>
      <h3 id="rfc.section.4.3.2"><a href="#rfc.section.4.3.2">4.3.2</a>&nbsp;Client implementation
      </h3>
      <p id="rfc.section.4.3.2.p.1">When fetching a resource the client has 3 possibilities: </p>
      <ol>
         <li>the resource is not being pushed</li>
         <li>the resource is being pushed, but the data has not yet arrived</li>
         <li>the resource is being pushed, and the data has started to arrive</li>
      </ol>
      <p id="rfc.section.4.3.2.p.2">A client SHOULD NOT issue GET requests for a resource that has been promised. A client is instead advised to wait for the
         pushed resource to arrive.
      </p>
      <p id="rfc.section.4.3.2.p.3">When a client receives a PUSH_PROMISE frame from the server without the <samp>:host</samp>, <samp>:scheme</samp>, and <samp>:path</samp> header fields, it MUST treat this as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;3.5.2</a>) of type PROTOCOL_ERROR.
      </p>
      <p id="rfc.section.4.3.2.p.4">To cancel individual server push streams, the client can issue a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;3.5.2</a>) of type CANCEL. After receiving a PUSH_PROMISE frame, the client is able to cancel the pushed resource before receiving any
         frames on the promised stream. The server ceases transmission of the pushed resource; if the server has not commenced transmission,
         it does not start.
      </p>
      <p id="rfc.section.4.3.2.p.5">To cancel all server push streams related to a request, the client may issue a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;3.5.2</a>) of type CANCEL on the associated-stream-id. By cancelling that stream, the server MUST immediately stop sending frames for
         any streams with in-association-to for the original stream. <span class="comment" id="rfc.comment.11">[<a href="#rfc.comment.11" class="smpl">rfc.comment.11</a>: Ed: Triggering side-effects on stream reset is going to be problematic for the framing layer. Purely from a design perspective,
            it's a layering violation. More practically speaking, the base request stream might already be removed. Special handling logic
            would be required.]</span> 
      </p>
      <p id="rfc.section.4.3.2.p.6">A client can choose to time out pushed streams if the server does not provide the resource in a timely fashion. A stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;3.5.2</a>) of type CANCEL can be used to stop a timed out push.
      </p>
      <p id="rfc.section.4.3.2.p.7">If the server sends a HEADERS frame containing header fields that duplicate values on a previous HEADERS or PUSH_PROMISE frames
         on the same stream, the client MUST treat this as a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;3.5.2</a>) of type PROTOCOL_ERROR.
      </p>
      <p id="rfc.section.4.3.2.p.8">If the server sends a HEADERS frame after sending a data frame for the same stream, the client MAY ignore the HEADERS frame.
         Ignoring the HEADERS frame after a data frame prevents handling of HTTP's trailing header fields (<a href="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/22/p1-messaging.html#header.trailer" title="Trailer">Section 4.1.1</a> of <a href="#HTTP-p1"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[HTTP-p1]</cite></a>).
      </p>
      <h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a>&nbsp;Design Rationale and Notes
      </h1>
      <p id="rfc.section.5.p.1">Authors' notes: The notes in this section have no bearing on the HTTP/2.0 protocol as specified within this document, and
         none of these notes should be considered authoritative about how the protocol works. However, these notes may prove useful
         in future debates about how to resolve protocol ambiguities or how to evolve the protocol going forward. They may be removed
         before the final draft.
      </p>
      <h2 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1</a>&nbsp;Separation of Framing Layer and Application Layer
      </h2>
      <p id="rfc.section.5.1.p.1">Readers may note that this specification sometimes blends the framing layer (<a href="#FramingLayer" title="HTTP/2.0 Framing Layer">Section&nbsp;3</a>) with requirements of a specific application - HTTP (<a href="#HTTPLayer" title="HTTP Message Exchanges">Section&nbsp;4</a>). This is reflected in the request/response nature of the streams and the definition of the HEADERS which are very similar
         to HTTP, and other areas as well.
      </p>
      <p id="rfc.section.5.1.p.2">This blending is intentional - the primary goal of this protocol is to create a low-latency protocol for use with HTTP. Isolating
         the two layers is convenient for description of the protocol and how it relates to existing HTTP implementations. However,
         the ability to reuse the HTTP/2.0 framing layer is a non goal.
      </p>
      <h2 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2</a>&nbsp;Error handling - Framing Layer
      </h2>
      <p id="rfc.section.5.2.p.1">Error handling at the HTTP/2.0 layer splits errors into two groups: Those that affect an individual HTTP/2.0 stream, and those
         that do not.
      </p>
      <p id="rfc.section.5.2.p.2">When an error is confined to a single stream, but general framing is intact, HTTP/2.0 attempts to use the RST_STREAM as a
         mechanism to invalidate the stream but move forward without aborting the connection altogether.
      </p>
      <p id="rfc.section.5.2.p.3">For errors occurring outside of a single stream context, HTTP/2.0 assumes the entire connection is hosed. In this case, the
         endpoint detecting the error should initiate a connection close.
      </p>
      <h2 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3</a>&nbsp;One Connection per Domain
      </h2>
      <p id="rfc.section.5.3.p.1">HTTP/2.0 attempts to use fewer connections than other protocols have traditionally used. The rationale for this behavior is
         because it is very difficult to provide a consistent level of service (e.g. TCP slow-start), prioritization, or optimal compression
         when the client is connecting to the server through multiple channels.
      </p>
      <p id="rfc.section.5.3.p.2">Through lab measurements, we have seen consistent latency benefits by using fewer connections from the client. The overall
         number of packets sent by HTTP/2.0 can be as much as 40% less than HTTP. Handling large numbers of concurrent connections
         on the server also does become a scalability problem, and HTTP/2.0 reduces this load.
      </p>
      <p id="rfc.section.5.3.p.3">The use of multiple connections is not without benefit, however. Because HTTP/2.0 multiplexes multiple, independent streams
         onto a single stream, it creates a potential for head-of-line blocking problems at the transport level. In tests so far, the
         negative effects of head-of-line blocking (especially in the presence of packet loss) is outweighed by the benefits of compression
         and prioritization.
      </p>
      <h2 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4</a>&nbsp;Fixed vs Variable Length Fields
      </h2>
      <p id="rfc.section.5.4.p.1">HTTP/2.0 favors use of fixed length 32bit fields in cases where smaller, variable length encodings could have been used. To
         some, this seems like a tragic waste of bandwidth. HTTP/2.0 chooses the simple encoding for speed and simplicity.
      </p>
      <p id="rfc.section.5.4.p.2">The goal of HTTP/2.0 is to reduce latency on the network. The overhead of HTTP/2.0 frames is generally quite low. Each data
         frame is only an 8 byte overhead for a 1452 byte payload (~0.6%). At the time of this writing, bandwidth is already plentiful,
         and there is a strong trend indicating that bandwidth will continue to increase. With an average worldwide bandwidth of 1Mbps,
         and assuming that a variable length encoding could reduce the overhead by 50%, the latency saved by using a variable length
         encoding would be less than 100 nanoseconds. More interesting are the effects when the larger encodings force a packet boundary,
         in which case a round-trip could be induced. However, by addressing other aspects of HTTP/2.0 and TCP interactions, we believe
         this is completely mitigated.
      </p>
      <h2 id="rfc.section.5.5"><a href="#rfc.section.5.5">5.5</a>&nbsp;Server Push
      </h2>
      <p id="rfc.section.5.5.p.1">A subtle but important point is that server push streams must be declared before the associated stream is closed. The reason
         for this is so that proxies have a lifetime for which they can discard information about previous streams. If a pushed stream
         could associate itself with an already-closed stream, then endpoints would not have a specific lifecycle for when they could
         disavow knowledge of the streams which went before.
      </p>
      <h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a>&nbsp;Security Considerations
      </h1>
      <h2 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1</a>&nbsp;Server Authority and Same-Origin
      </h2>
      <p id="rfc.section.6.1.p.1">This specification uses the same-origin policy (<a href="#RFC6454"><cite title="The Web Origin Concept">[RFC6454]</cite></a>, <a href="http://tools.ietf.org/html/rfc6454#section-3">Section 3</a>) to determine whether an origin server is permitted to provide content.
      </p>
      <p id="rfc.section.6.1.p.2">A server that is contacted using TLS is authenticated based on the certificate that it offers in the TLS handshake (see <a href="#RFC2818"><cite title="HTTP Over TLS">[RFC2818]</cite></a>, <a href="http://tools.ietf.org/html/rfc2818#section-3">Section 3</a>). A server is considered authoritative for an "https:" resource if it has been successfully authenticated for the domain
         part of the origin of the resource that it is providing.
      </p>
      <p id="rfc.section.6.1.p.3">A server is considered authoritative for an "http:" resource if the connection is established to a resolved IP address for
         the domain in the origin of the resource.
      </p>
      <p id="rfc.section.6.1.p.4">A client MUST NOT use, in any way, resources provided by a server that is not authoritative for those resources.</p>
      <h2 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2</a>&nbsp;Cross-Protocol Attacks
      </h2>
      <p id="rfc.section.6.2.p.1">When using TLS, we believe that HTTP/2.0 introduces no new cross-protocol attacks. TLS encrypts the contents of all transmission
         (except the handshake itself), making it difficult for attackers to control the data which could be used in a cross-protocol
         attack. <span class="comment" id="rfc.comment.12">[<a href="#rfc.comment.12" class="smpl">rfc.comment.12</a>: Issue: This is no longer true]</span> 
      </p>
      <h2 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3</a>&nbsp;Cacheability of Pushed Resources
      </h2>
      <p id="rfc.section.6.3.p.1">Pushed resources are synthesized responses without an explicit request; the request for a pushed resource is synthesized from
         the request that triggered the push, plus resource identification information provided by the server. Request header fields
         are necessary for HTTP cache control validations (such as the Vary header field) to work. For this reason, caches MUST inherit
         request header fields from the associated stream for the push. This includes the Cookie header field.
      </p>
      <p id="rfc.section.6.3.p.2">Caching resources that are pushed is possible, based on the guidance provided by the origin server in the Cache-Control header
         field. However, this can cause issues if a single server hosts more than one tenant. For example, a server might offer multiple
         users each a small portion of its URI space.
      </p>
      <p id="rfc.section.6.3.p.3">Where multiple tenants share space on the same server, that server MUST ensure that tenants are not able to push representations
         of resources that they do not have authority over. Failure to enforce this would allow a tenant to provide a representation
         that would be served out of cache, overriding the actual representation that the authoritative tenant provides.
      </p>
      <p id="rfc.section.6.3.p.4">Pushed resources for which an origin server is not authoritative are never cached or used.</p>
      <h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a>&nbsp;Privacy Considerations
      </h1>
      <h2 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1</a>&nbsp;Long Lived Connections
      </h2>
      <p id="rfc.section.7.1.p.1">HTTP/2.0 aims to keep connections open longer between clients and servers in order to reduce the latency when a user makes
         a request. The maintenance of these connections over time could be used to expose private information. For example, a user
         using a browser hours after the previous user stopped using that browser may be able to learn about what the previous user
         was doing. This is a problem with HTTP in its current form as well, however the short lived connections make it less of a
         risk.
      </p>
      <h2 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2</a>&nbsp;SETTINGS frame
      </h2>
      <p id="rfc.section.7.2.p.1">The HTTP/2.0 SETTINGS frame allows servers to store out-of-band transmitted information about the communication between client
         and server on the client. Although this is intended only to be used to reduce latency, renegade servers could use it as a
         mechanism to store identifying information about the client in future requests.
      </p>
      <p id="rfc.section.7.2.p.2">Clients implementing privacy modes can disable client-persisted SETTINGS storage.</p>
      <p id="rfc.section.7.2.p.3">Clients MUST clear persisted SETTINGS information when clearing the cookies.</p>
      <h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a>&nbsp;IANA Considerations
      </h1>
      <p id="rfc.section.8.p.1">This document establishes registries for frame types, error codes and settings.</p>
      <h2 id="rfc.section.8.1"><a href="#rfc.section.8.1">8.1</a>&nbsp;Frame Type Registry
      </h2>
      <p id="rfc.section.8.1.p.1">This document establishes a registry for HTTP/2.0 frame types. The "HTTP/2.0 Frame Type" registry operates under the <a href="#RFC5226">"IETF Review" policy</a> <cite title="Guidelines for Writing an IANA Considerations Section in RFCs">[RFC5226]</cite>.
      </p>
      <p id="rfc.section.8.1.p.2">Frame types are an 8-bit value. When reviewing new frame type registrations, special attention is advised for any frame type-specific
         flags that are defined. Frame flags can interact with existing flags and could prevent the creation of globally applicable
         flags.
      </p>
      <p id="rfc.section.8.1.p.3">Initial values for the "HTTP/2.0 Frame Type" registry are shown in <a href="#IanaInitialFrameType">Table&nbsp;1</a>.
      </p>
      <div id="rfc.table.1">
         <div id="IanaInitialFrameType"></div>
         <table class="tt full center" cellpadding="3" cellspacing="0">
            <caption>Table 1</caption>
            <thead>
               <tr>
                  <th>Frame Type</th>
                  <th>Name</th>
                  <th>Flags</th>
               </tr>
            </thead>
            <tbody>
               <tr>
                  <td class="left">0</td>
                  <td class="left">DATA</td>
                  <td class="left">-</td>
               </tr>
               <tr>
                  <td class="left">1</td>
                  <td class="left">HEADERS+PRIORITY</td>
                  <td class="left">CONTINUES(2)</td>
               </tr>
               <tr>
                  <td class="left">2</td>
                  <td class="left">PRIORITY</td>
                  <td class="left">-</td>
               </tr>
               <tr>
                  <td class="left">3</td>
                  <td class="left">RST_STREAM</td>
                  <td class="left">-</td>
               </tr>
               <tr>
                  <td class="left">4</td>
                  <td class="left">SETTINGS</td>
                  <td class="left">CLEAR_PERSISTED(2)</td>
               </tr>
               <tr>
                  <td class="left">5</td>
                  <td class="left">PUSH_PROMISE</td>
                  <td class="left">CONTINUES(2)</td>
               </tr>
               <tr>
                  <td class="left">6</td>
                  <td class="left">PING</td>
                  <td class="left">PONG(2)</td>
               </tr>
               <tr>
                  <td class="left">7</td>
                  <td class="left">GOAWAY</td>
                  <td class="left">-</td>
               </tr>
               <tr>
                  <td class="left">8</td>
                  <td class="left">HEADERS</td>
                  <td class="left">CONTINUES(2)</td>
               </tr>
               <tr>
                  <td class="left">9</td>
                  <td class="left">WINDOW_UPDATE</td>
                  <td class="left">END_FLOW_CONTROL(2)</td>
               </tr>
            </tbody>
         </table>
      </div>
      <h2 id="rfc.section.8.2"><a href="#rfc.section.8.2">8.2</a>&nbsp;Error Code Registry
      </h2>
      <p id="rfc.section.8.2.p.1">This document establishes a registry for HTTP/2.0 error codes. The "HTTP/2.0 Error Code" registry manages a 32-bit space.
         The "HTTP/2.0 Error Code" registry operates under the <a href="#RFC5226">"Expert Review" policy</a> <cite title="Guidelines for Writing an IANA Considerations Section in RFCs">[RFC5226]</cite>.
      </p>
      <p id="rfc.section.8.2.p.2">Registrations for error codes are required to include a description of the error code. An expert reviewer is advised to examine
         new registrations for possible duplication with existing error codes. Use of existing registrations is to be encouraged, but
         not mandated.
      </p>
      <p id="rfc.section.8.2.p.3">New registrations are advised to provide the following information: </p>
      <dl>
         <dt>Error Code:</dt>
         <dd>The 32-bit error code value.</dd>
         <dt>Name:</dt>
         <dd>A name for the error code. Specifying an error code name is optional.</dd>
         <dt>Description:</dt>
         <dd>A description of the conditions where the error code is applicable.</dd>
         <dt>Specification:</dt>
         <dd>An optional reference for a specification that defines the error code.</dd>
      </dl>
      <p id="rfc.section.8.2.p.4">An initial set of error code registrations can be found in <a href="#ErrorCodes" title="Error Codes">Section&nbsp;3.5.3</a>.
      </p>
      <h2 id="rfc.section.8.3"><a href="#rfc.section.8.3">8.3</a>&nbsp;Settings Registry
      </h2>
      <p id="rfc.section.8.3.p.1">This document establishes a registry for HTTP/2.0 settings. The "HTTP/2.0 Settings" registry manages a 24-bit space. The "HTTP/2.0
         Settings" registry operates under the <a href="#RFC5226">"Expert Review" policy</a> <cite title="Guidelines for Writing an IANA Considerations Section in RFCs">[RFC5226]</cite>.
      </p>
      <p id="rfc.section.8.3.p.2">Registrations for settings are required to include a description of the setting. An expert reviewer is advised to examine
         new registrations for possible duplication with existing settings. Use of existing registrations is to be encouraged, but
         not mandated.
      </p>
      <p id="rfc.section.8.3.p.3">New registrations are advised to provide the following information: </p>
      <dl>
         <dt>Setting:</dt>
         <dd>The 24-bit setting value.</dd>
         <dt>Name:</dt>
         <dd>A name for the setting. Specifying a name is optional.</dd>
         <dt>Flags:</dt>
         <dd>Any setting-specific flags that apply, including their value and semantics.</dd>
         <dt>Description:</dt>
         <dd>A description of the setting. This might include the range of values, any applicable units and how to act upon a value when
            it is provided.
         </dd>
         <dt>Specification:</dt>
         <dd>An optional reference for a specification that defines the setting.</dd>
      </dl>
      <p id="rfc.section.8.3.p.4">An initial set of settings registrations can be found in <a href="#SettingValues" title="Defined Settings">Section&nbsp;3.8.5.3</a>.
      </p>
      <h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a>&nbsp;Acknowledgements
      </h1>
      <p id="rfc.section.9.p.1">This document includes substantial input from the following individuals: </p>
      <ul>
         <li>Adam Langley, Wan-Teh Chang, Jim Morrison, Mark Nottingham, Alyssa Wilk, Costin Manolache, William Chan, Vitaliy Lvin, Joe
            Chan, Adam Barth, Ryan Hamilton, Gavin Peters, Kent Alstad, Kevin Lindsay, Paul Amer, Fan Yang, Jonathan Leighton (SPDY contributors).
         </li>
         <li>Gabriel Montenegro and Willy Tarreau (Upgrade mechanism)</li>
         <li>William Chan, Salvatore Loreto, Osama Mazahir, Gabriel Montenegro, Jitu Padhye, Roberto Peon, Rob Trace (Flow control)</li>
         <li>Mark Nottingham, Julian Reschke, James Snell (Editorial)</li>
      </ul>
      <h1 id="rfc.references"><a id="rfc.section.10" href="#rfc.section.10">10.</a> References
      </h1>
      <h2 id="rfc.references.1"><a href="#rfc.section.10.1" id="rfc.section.10.1">10.1</a> Normative References
      </h2>
      <table>
         <tr>
            <td class="reference"><b id="HTTP-p1">[HTTP-p1]</b></td>
            <td class="top">Fielding, R. and J. Reschke, “<a href="http://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-22">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-p1-messaging-22 (work in progress), February&nbsp;2013.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="HTTP-p2">[HTTP-p2]</b></td>
            <td class="top">Fielding, R. and J. Reschke, “<a href="http://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-22">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-p2-semantics-22 (work in progress), February&nbsp;2013.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="HTTP-p4">[HTTP-p4]</b></td>
            <td class="top"><a href="mailto:fielding@gbiv.com" title="Adobe Systems Incorporated">Fielding, R., Ed.</a> and <a href="mailto:julian.reschke@greenbytes.de" title="greenbytes GmbH">J. Reschke, Ed.</a>, “<a href="http://tools.ietf.org/html/draft-ietf-httpbis-p4-conditional-22">Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-p4-conditional-22 (work in progress), February&nbsp;2013.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="HTTP-p5">[HTTP-p5]</b></td>
            <td class="top"><a href="mailto:fielding@gbiv.com" title="Adobe Systems Incorporated">Fielding, R., Ed.</a>, <a href="mailto:ylafon@w3.org" title="World Wide Web Consortium">Lafon, Y., Ed.</a>, and <a href="mailto:julian.reschke@greenbytes.de" title="greenbytes GmbH">J. Reschke, Ed.</a>, “<a href="http://tools.ietf.org/html/draft-ietf-httpbis-p5-range-22">Hypertext Transfer Protocol (HTTP/1.1): Range Requests</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-p5-range-22 (work in progress), February&nbsp;2013.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="HTTP-p6">[HTTP-p6]</b></td>
            <td class="top"><a href="mailto:fielding@gbiv.com" title="Adobe Systems Incorporated">Fielding, R., Ed.</a>, <a href="mailto:mnot@mnot.net" title="Akamai">Nottingham, M., Ed.</a>, and <a href="mailto:julian.reschke@greenbytes.de" title="greenbytes GmbH">J. Reschke, Ed.</a>, “<a href="http://tools.ietf.org/html/draft-ietf-httpbis-p6-cache-22">Hypertext Transfer Protocol (HTTP/1.1): Caching</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-p6-cache-22 (work in progress), February&nbsp;2013.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="HTTP-p7">[HTTP-p7]</b></td>
            <td class="top"><a href="mailto:fielding@gbiv.com" title="Adobe Systems Incorporated">Fielding, R., Ed.</a> and <a href="mailto:julian.reschke@greenbytes.de" title="greenbytes GmbH">J. Reschke, Ed.</a>, “<a href="http://tools.ietf.org/html/draft-ietf-httpbis-p7-auth-22">Hypertext Transfer Protocol (HTTP/1.1): Authentication</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-p7-auth-22 (work in progress), February&nbsp;2013.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC0793">[RFC0793]</b></td>
            <td class="top">Postel, J., “<a href="http://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>”, STD&nbsp;7, RFC&nbsp;793, September&nbsp;1981.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC2119">[RFC2119]</b></td>
            <td class="top"><a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, “<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC2818">[RFC2818]</b></td>
            <td class="top">Rescorla, E., “<a href="http://tools.ietf.org/html/rfc2818">HTTP Over TLS</a>”, RFC&nbsp;2818, May&nbsp;2000.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC3986">[RFC3986]</b></td>
            <td class="top">Berners-Lee, T., Fielding, R., and L. Masinter, “<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>”, STD&nbsp;66, RFC&nbsp;3986, January&nbsp;2005.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC5226">[RFC5226]</b></td>
            <td class="top">Narten, T. and H. Alvestrand, “<a href="http://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>”, BCP&nbsp;26, RFC&nbsp;5226, May&nbsp;2008.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC5246">[RFC5246]</b></td>
            <td class="top">Dierks, T. and E. Rescorla, “<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>”, RFC&nbsp;5246, August&nbsp;2008.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC6454">[RFC6454]</b></td>
            <td class="top">Barth, A., “<a href="http://tools.ietf.org/html/rfc6454">The Web Origin Concept</a>”, RFC&nbsp;6454, December&nbsp;2011.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="TLSALPN">[TLSALPN]</b></td>
            <td class="top">Friedl, S., Popov, A., Langley, A., and E. Stephan, “<a href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg-01">Transport Layer Security (TLS) Application Layer Protocol Negotiation Extension</a>”, Internet-Draft&nbsp;draft-ietf-tls-applayerprotoneg-01 (work in progress), April&nbsp;2013.
            </td>
         </tr>
      </table>
      <h2 id="rfc.references.2"><a href="#rfc.section.10.2" id="rfc.section.10.2">10.2</a> Informative References
      </h2>
      <table>
         <tr>
            <td class="reference"><b id="RFC1323">[RFC1323]</b></td>
            <td class="top">Jacobson, V., Braden, B., and D. Borman, “<a href="http://tools.ietf.org/html/rfc1323">TCP Extensions for High Performance</a>”, RFC&nbsp;1323, May&nbsp;1992.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="TALKING">[TALKING]</b></td>
            <td class="top">Huang, L-S., Chen, E., Barth, A., Rescorla, E., and C. Jackson, “<a href="http://w2spconf.com/2011/papers/websocket.pdf">Talking to Yourself for Fun and Profit</a>”, 2011, &lt;<a href="http://w2spconf.com/2011/papers/websocket.pdf">http://w2spconf.com/2011/papers/websocket.pdf</a>&gt;.
            </td>
         </tr>
      </table>
      <div class="avoidbreak">
         <h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
         <address class="vcard"><span class="vcardline"><span class="fn">Mike Belshe</span><span class="n hidden"><span class="family-name">Belshe</span><span class="given-name">Mike</span></span></span><span class="org vcardline">Twist</span><span class="vcardline">Email: <a href="mailto:mbelshe@chromium.org"><span class="email">mbelshe@chromium.org</span></a></span></address>
         <address class="vcard"><span class="vcardline"><span class="fn">Roberto Peon</span><span class="n hidden"><span class="family-name">Peon</span><span class="given-name">Roberto</span></span></span><span class="org vcardline">Google, Inc</span><span class="vcardline">Email: <a href="mailto:fenix@google.com"><span class="email">fenix@google.com</span></a></span></address>
         <address class="vcard"><span class="vcardline"><span class="fn">Martin Thomson</span>
               (editor)
               <span class="n hidden"><span class="family-name">Thomson</span><span class="given-name">Martin</span></span></span><span class="org vcardline">Microsoft</span><span class="adr"><span class="street-address vcardline">3210 Porter Drive</span><span class="vcardline"><span class="locality">Palo Alto</span>, <span class="postal-code">94304</span></span><span class="country-name vcardline">US</span></span><span class="vcardline">Email: <a href="mailto:martin.thomson@skype.net"><span class="email">martin.thomson@skype.net</span></a></span></address>
         <address class="vcard"><span class="vcardline"><span class="fn">Alexey Melnikov</span>
               (editor)
               <span class="n hidden"><span class="family-name">Melnikov</span><span class="given-name">Alexey</span></span></span><span class="org vcardline">Isode Ltd</span><span class="adr"><span class="street-address vcardline">5 Castle Business Village</span><span class="street-address vcardline">36 Station Road</span><span class="vcardline"><span class="locality">Hampton</span>, <span class="region">Middlesex</span>&nbsp;<span class="postal-code">TW12 2BX</span></span><span class="country-name vcardline">UK</span></span><span class="vcardline">Email: <a href="mailto:Alexey.Melnikov@isode.com"><span class="email">Alexey.Melnikov@isode.com</span></a></span></address>
      </div>
      <h1 id="rfc.section.A" class="np"><a href="#rfc.section.A">A.</a>&nbsp;<a id="change.log" href="#change.log">Change Log (to be removed by RFC Editor before publication)</a></h1>
      <h2 id="rfc.section.A.1"><a href="#rfc.section.A.1">A.1</a>&nbsp;<a id="changes.since.draft-ietf-httpbis-http2-03" href="#changes.since.draft-ietf-httpbis-http2-03">Since draft-ietf-httpbis-http2-03</a></h2>
      <p id="rfc.section.A.1.p.1">Added PRIORITY frame.</p>
      <h2 id="rfc.section.A.2"><a href="#rfc.section.A.2">A.2</a>&nbsp;<a id="changes.since.draft-ietf-httpbis-http2-02" href="#changes.since.draft-ietf-httpbis-http2-02">Since draft-ietf-httpbis-http2-02</a></h2>
      <p id="rfc.section.A.2.p.1">Added continuations to frames carrying header blocks.</p>
      <p id="rfc.section.A.2.p.2">Replaced use of "session" with "connection" to avoid confusion with other HTTP stateful concepts, like cookies.</p>
      <p id="rfc.section.A.2.p.3">Removed "message".</p>
      <p id="rfc.section.A.2.p.4">Switched to TLS ALPN from NPN.</p>
      <p id="rfc.section.A.2.p.5">Editorial changes.</p>
      <h2 id="rfc.section.A.3"><a href="#rfc.section.A.3">A.3</a>&nbsp;<a id="changes.since.draft-ietf-httpbis-http2-01" href="#changes.since.draft-ietf-httpbis-http2-01">Since draft-ietf-httpbis-http2-01</a></h2>
      <p id="rfc.section.A.3.p.1">Added IANA considerations section for frame types, error codes and settings.</p>
      <p id="rfc.section.A.3.p.2">Removed data frame compression.</p>
      <p id="rfc.section.A.3.p.3">Added PUSH_PROMISE.</p>
      <p id="rfc.section.A.3.p.4">Added globally applicable flags to framing.</p>
      <p id="rfc.section.A.3.p.5">Removed zlib-based header compression mechanism.</p>
      <p id="rfc.section.A.3.p.6">Updated references.</p>
      <p id="rfc.section.A.3.p.7">Clarified stream identifier reuse.</p>
      <p id="rfc.section.A.3.p.8">Removed CREDENTIALS frame and associated mechanisms.</p>
      <p id="rfc.section.A.3.p.9">Added advice against naive implementation of flow control.</p>
      <p id="rfc.section.A.3.p.10">Added session header section.</p>
      <p id="rfc.section.A.3.p.11">Restructured frame header. Removed distinction between data and control frames.</p>
      <p id="rfc.section.A.3.p.12">Altered flow control properties to include session-level limits.</p>
      <p id="rfc.section.A.3.p.13">Added note on cacheability of pushed resources and multiple tenant servers.</p>
      <p id="rfc.section.A.3.p.14">Changed protocol label form based on discussions.</p>
      <h2 id="rfc.section.A.4"><a href="#rfc.section.A.4">A.4</a>&nbsp;<a id="changes.since.draft-ietf-httpbis-http2-00" href="#changes.since.draft-ietf-httpbis-http2-00">Since draft-ietf-httpbis-http2-00</a></h2>
      <p id="rfc.section.A.4.p.1">Changed title throughout.</p>
      <p id="rfc.section.A.4.p.2">Removed section on Incompatibilities with SPDY draft#2.</p>
      <p id="rfc.section.A.4.p.3">Changed INTERNAL_ERROR on GOAWAY to have a value of 2 &lt;<a href="https://groups.google.com/forum/?fromgroups#!topic/spdy-dev/cfUef2gL3iU">https://groups.google.com/forum/?fromgroups#!topic/spdy-dev/cfUef2gL3iU</a>&gt;.
      </p>
      <p id="rfc.section.A.4.p.4">Replaced abstract and introduction.</p>
      <p id="rfc.section.A.4.p.5">Added section on starting HTTP/2.0, including upgrade mechanism.</p>
      <p id="rfc.section.A.4.p.6">Removed unused references.</p>
      <p id="rfc.section.A.4.p.7">Added flow control principles (<a href="#fc-principles" title="Flow Control Principles">Section&nbsp;3.6.1</a>) based on &lt;<a href="http://tools.ietf.org/html/draft-montenegro-httpbis-http2-fc-principles-01">http://tools.ietf.org/html/draft-montenegro-httpbis-http2-fc-principles-01</a>&gt;.
      </p>
      <h2 id="rfc.section.A.5"><a href="#rfc.section.A.5">A.5</a>&nbsp;<a id="changes.since.draft-mbelshe-httpbis-spdy-00" href="#changes.since.draft-mbelshe-httpbis-spdy-00">Since draft-mbelshe-httpbis-spdy-00</a></h2>
      <p id="rfc.section.A.5.p.1">Adopted as base for draft-ietf-httpbis-http2.</p>
      <p id="rfc.section.A.5.p.2">Updated authors/editors list.</p>
      <p id="rfc.section.A.5.p.3">Added status note.</p>
   </body>
</html>