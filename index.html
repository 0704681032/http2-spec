<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en">
   <head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>Hypertext Transfer Protocol version 2.0</title><script>
var buttonsAdded = false;

function init() {
  var fb = document.createElement("div");
  fb.className = "feedback noprint";
  fb.setAttribute("onclick", "feedback();");
  fb.appendChild(document.createTextNode("feedback"));

  var bodyl = document.getElementsByTagName("body");
  bodyl.item(0).appendChild(fb);
}

function feedback() {
  toggleButtonsToElementsByName("h1");
  toggleButtonsToElementsByName("h2");
  toggleButtonsToElementsByName("h3");
  toggleButtonsToElementsByName("h4");
  
  buttonsAdded = !buttonsAdded;
}

function toggleButtonsToElementsByName(name) {
  var list = document.getElementsByTagName(name);
  for (var i = 0; i < list.length; i++) {
    toggleButton(list.item(i));
  }
}

function toggleButton(node) {
  if (! buttonsAdded) {
  
    // docname
    var template = "mailto:ietf-http-wg@w3.org?subject={docname},%20%22{section}%22&body=<{ref}>:";

    var id = node.getAttribute("id");
    // better id available?
    var titlelinks = node.getElementsByTagName("a");
    for (var i = 0; i < titlelinks.length; i++) {
      var tl = titlelinks.item(i);
      if (tl.getAttribute("id")) {
        id = tl.getAttribute("id");
      }
    }

    // ref
    var ref = window.location.toString();
    var hash = ref.indexOf("#");
    if (hash != -1) {
      ref = ref.substring(0, hash);
    }
    if (id != "") {
      ref += "#" + id;
    }
    
    // docname
    var docname = "draft-ietf-httpbis-http2-latest";

    // section
    var section = node.textContent;
    section = section.replace("\u00a0", " ");
    
    // build URI from template
    var uri = template.replace("{docname}", encodeURIComponent(docname));
    uri = uri.replace("{section}", encodeURIComponent(section));
    uri = uri.replace("{ref}", encodeURIComponent(ref));
  
    var button = document.createElement("a");
    button.className = "fbbutton noprint";
    button.setAttribute("href", uri);
    button.appendChild(document.createTextNode("send feedback"));
    node.appendChild(button);
  }
  else {
    var buttons = node.getElementsByTagName("a");
    for (var i = 0; i < buttons.length; i++) {
      var b = buttons.item(i);
      if (b.className == "fbbutton noprint") {
        node.removeChild(b);
      }
    }
  }
}</script><style type="text/css" title="Xml2Rfc (sans serif)">
a {
  text-decoration: none;
}
a.smpl {
  color: black;
}
a:hover {
  text-decoration: underline;
}
a:active {
  text-decoration: underline;
}
address {
  margin-top: 1em;
  margin-left: 2em;
  font-style: normal;
}
body {
  color: black;
  font-family: verdana, helvetica, arial, sans-serif;
  font-size: 10pt;
  margin-right: 2em;
}
cite {
  font-style: normal;
}
dl {
  margin-left: 2em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}
dl p {
  margin-left: 0em;
}
dt {
  margin-top: .5em;
}
h1 {
  font-size: 14pt;
  line-height: 21pt;
  page-break-after: avoid;
}
h1.np {
  page-break-before: always;
}
h1 a {
  color: #333333;
}
h2 {
  font-size: 12pt;
  line-height: 15pt;
  page-break-after: avoid;
}
h3, h4, h5, h6 {
  font-size: 10pt;
  page-break-after: avoid;
}
h2 a, h3 a, h4 a, h5 a, h6 a {
  color: black;
}
img {
  margin-left: 3em;
}
li {
  margin-left: 2em;
}
ol {
  margin-left: 2em;
}
ol.la {
  list-style-type: lower-alpha;
}
ol.ua {
  list-style-type: upper-alpha;
}
ol p {
  margin-left: 0em;
}
p {
  margin-left: 2em;
}
pre {
  margin-left: 3em;
  background-color: lightyellow;
  padding: .25em;
  page-break-inside: avoid;
}
pre.text2 {
  border-style: dotted;
  border-width: 1px;
  background-color: #f0f0f0;
  width: 69em;
}
pre.inline {
  background-color: white;
  padding: 0em;
}
pre.text {
  border-style: dotted;
  border-width: 1px;
  background-color: #f8f8f8;
  width: 69em;
}
pre.drawing {
  border-style: solid;
  border-width: 1px;
  background-color: #f8f8f8;
  padding: 2em;
}
sup {
  font-size: 60%;
}
table {
  margin-left: 2em;
}
table.header {
  border-spacing: 1px;
  width: 95%;
  font-size: 10pt;
  color: white;
}
td.top {
  vertical-align: top;
}
td.topnowrap {
  vertical-align: top;
  white-space: nowrap; 
}
table.header td {
  background-color: gray;
  width: 50%;
}
td.reference {
  vertical-align: top;
  white-space: nowrap;
  padding-right: 1em;
}
thead {
  display:table-header-group;
}
ul.toc, ul.toc ul {
  list-style: none;
  margin-left: 1.5em;
  padding-left: 0em;
}
ul.toc li {
  line-height: 150%;
  font-weight: bold;
  font-size: 10pt;
  margin-left: 0em;
}
ul.toc li li {
  line-height: normal;
  font-weight: normal;
  font-size: 9pt;
  margin-left: 0em;
}
li.excluded {
  font-size: 0pt;
}
ul p {
  margin-left: 0em;
}
ul.ind, ul.ind ul {
  list-style: none;
  margin-left: 1.5em;
  padding-left: 0em;
  page-break-before: avoid;
}
ul.ind li {
  font-weight: bold;
  line-height: 200%;
  margin-left: 0em;
}
ul.ind li li {
  font-weight: normal;
  line-height: 150%;
  margin-left: 0em;
}
.avoidbreak {
  page-break-inside: avoid;
}

.comment {
  background-color: yellow;
}
.center {
  text-align: center;
}
.error {
  color: red;
  font-style: italic;
  font-weight: bold;
}
.figure {
  font-weight: bold;
  text-align: center;
  font-size: 9pt;
}
.filename {
  color: #333333;
  font-weight: bold;
  font-size: 12pt;
  line-height: 21pt;
  text-align: center;
}
.fn {
  font-weight: bold;
}
.hidden {
  display: none;
}
.left {
  text-align: left;
}
.right {
  text-align: right;
}
.title {
  color: #990000;
  font-size: 18pt;
  line-height: 18pt;
  font-weight: bold;
  text-align: center;
  margin-top: 36pt;
}
.vcardline {
  display: block;
}
.warning {
  font-size: 14pt;
  background-color: yellow;
}
.feedback {
  position: fixed;
  bottom: 1%;
  right: 1%;
  padding: 3px 5px;
  color: white;
  border-radius: 5px;
  background: #a00000;
  border: 1px solid silver;
}
.fbbutton {
  margin-left: 1em;
  color: #303030;
  font-size: small;
  font-weight: normal;
  background: #d0d000;
  padding: 1px 4px;
  border: 1px solid silver;
  border-radius: 5px;
}

@media print {
  .noprint {
    display: none;
  }
  
  a {
    color: black;
    text-decoration: none;
  }

  table.header {
    width: 90%;
  }

  td.header {
    width: 50%;
    color: black;
    background-color: white;
    vertical-align: top;
    font-size: 12pt;
  }

  ul.toc a:nth-child(2)::after {
    content: leader('.') target-counter(attr(href), page);
  }
  
  ul.ind li li a {
    content: target-counter(attr(href), page);
  }
  
  .print2col {
    column-count: 2;
    -moz-column-count: 2;
    column-fill: auto;
  }
}

@page {
  @top-left {
       content: "Internet-Draft"; 
  } 
  @top-right {
       content: "March 2013"; 
  } 
  @top-center {
       content: "HTTP/2.0"; 
  } 
  @bottom-left {
       content: "Belshe, et al."; 
  } 
  @bottom-center {
       content: "Expires September 23, 2013"; 
  } 
  @bottom-right {
       content: "[Page " counter(page) "]"; 
  } 
}

@page:first { 
    @top-left {
      content: normal;
    }
    @top-right {
      content: normal;
    }
    @top-center {
      content: normal;
    }
}
</style><link rel="Contents" href="#rfc.toc">
      <link rel="Author" href="#rfc.authors">
      <link rel="Copyright" href="#rfc.copyrightnotice">
      <link rel="Index" href="#rfc.index">
      <link rel="Chapter" title="1 Introduction" href="#rfc.section.1">
      <link rel="Chapter" title="2 Starting HTTP/2.0" href="#rfc.section.2">
      <link rel="Chapter" title="3 HTTP/2.0 Framing Layer" href="#rfc.section.3">
      <link rel="Chapter" title="4 HTTP Message Exchanges" href="#rfc.section.4">
      <link rel="Chapter" title="5 Design Rationale and Notes" href="#rfc.section.5">
      <link rel="Chapter" title="6 Security Considerations" href="#rfc.section.6">
      <link rel="Chapter" title="7 Privacy Considerations" href="#rfc.section.7">
      <link rel="Chapter" title="8 Acknowledgements" href="#rfc.section.8">
      <link rel="Chapter" href="#rfc.section.9" title="9 References">
      <link rel="Appendix" title="A Change Log (to be removed by RFC Editor before publication)" href="#rfc.section.A">
      <meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.591, 2013/02/27 12:53:51, XSLT vendor: SAXON 9.1.0.8 from Saxonica http://www.saxonica.com/">
      <meta name="keywords" content="HTTP">
      <link rel="schema.dct" href="http://purl.org/dc/terms/">
      <meta name="dct.creator" content="Belshe, M.">
      <meta name="dct.creator" content="Peon, R.">
      <meta name="dct.creator" content="Thomson, M.">
      <meta name="dct.creator" content="Melnikov, A.">
      <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-httpbis-http2-latest">
      <meta name="dct.issued" scheme="ISO8601" content="2013-03-22">
      <meta name="dct.abstract" content="This specification describes an optimised expression of the syntax of the Hypertext Transfer Protocol (HTTP). The HTTP/2.0 encapsulation enables more efficient transfer of representations by providing compressed header fields, simultaneous requests, and also introduces unsolicited push of representations from server to client. This document is an alternative to, but does not obsolete the HTTP message format. HTTP semantics remain unchanged.">
      <meta name="description" content="This specification describes an optimised expression of the syntax of the Hypertext Transfer Protocol (HTTP). The HTTP/2.0 encapsulation enables more efficient transfer of representations by providing compressed header fields, simultaneous requests, and also introduces unsolicited push of representations from server to client. This document is an alternative to, but does not obsolete the HTTP message format. HTTP semantics remain unchanged.">
   </head>
   <body onload="init();">
      <table class="header">
         <tbody>
            <tr>
               <td class="left">HTTPbis Working Group</td>
               <td class="right">M. Belshe</td>
            </tr>
            <tr>
               <td class="left">Internet-Draft</td>
               <td class="right">Twist</td>
            </tr>
            <tr>
               <td class="left">Intended status: Standards Track</td>
               <td class="right">R. Peon</td>
            </tr>
            <tr>
               <td class="left">Expires: September 23, 2013</td>
               <td class="right">Google, Inc</td>
            </tr>
            <tr>
               <td class="left"></td>
               <td class="right">M. Thomson, Editor</td>
            </tr>
            <tr>
               <td class="left"></td>
               <td class="right">Microsoft</td>
            </tr>
            <tr>
               <td class="left"></td>
               <td class="right">A. Melnikov, Editor</td>
            </tr>
            <tr>
               <td class="left"></td>
               <td class="right">Isode Ltd</td>
            </tr>
            <tr>
               <td class="left"></td>
               <td class="right">March 22, 2013</td>
            </tr>
         </tbody>
      </table>
      <p class="title">Hypertext Transfer Protocol version 2.0<br><span class="filename">draft-ietf-httpbis-http2-latest</span></p>
      <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1> 
      <p>This specification describes an optimised expression of the syntax of the Hypertext Transfer Protocol (HTTP). The HTTP/2.0
         encapsulation enables more efficient transfer of representations by providing compressed header fields, simultaneous requests,
         and also introduces unsolicited push of representations from server to client.
      </p>  
      <p>This document is an alternative to, but does not obsolete the HTTP message format. HTTP semantics remain unchanged.</p> 
      <h1 id="rfc.note.1"><a href="#rfc.note.1">Editorial Note (To be removed by RFC Editor)</a></h1> 
      <p>Discussion of this draft takes place on the HTTPBIS working group mailing list (ietf-http-wg@w3.org), which is archived at &lt;<a href="http://lists.w3.org/Archives/Public/ietf-http-wg/">http://lists.w3.org/Archives/Public/ietf-http-wg/</a>&gt;.
      </p>  
      <p>Working Group information and related documents can be found at &lt;<a href="http://tools.ietf.org/wg/httpbis/">http://tools.ietf.org/wg/httpbis/</a>&gt; (Wiki) and &lt;<a href="https://github.com/http2/http2-spec">https://github.com/http2/http2-spec</a>&gt; (source code and issues tracker).
      </p>  
      <p>The changes in this draft are summarized in <a href="#changes.since.draft-ietf-httpbis-http2-01" title="Since draft-ietf-httpbis-http2-01">Appendix&nbsp;A.1</a>.
      </p> 
      <h1><a id="rfc.status" href="#rfc.status">Status of This Memo</a></h1>
      <p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
      <p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute
         working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.
      </p>
      <p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other
         documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work
         in progress”.
      </p>
      <p>This Internet-Draft will expire on September 23, 2013.</p>
      <h1><a id="rfc.copyrightnotice" href="#rfc.copyrightnotice">Copyright Notice</a></h1>
      <p>Copyright © 2013 IETF Trust and the persons identified as the document authors. All rights reserved.</p>
      <p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights
         and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License
         text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified
         BSD License.
      </p>
      <hr class="noprint">
      <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
      <ul class="toc">
         <li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#intro">Introduction</a><ul>
               <li><a href="#rfc.section.1.1">1.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.1.1">Document Organization</a></li>
               <li><a href="#rfc.section.1.2">1.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.1.2">Conventions and Terminology</a></li>
            </ul>
         </li>
         <li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#starting">Starting HTTP/2.0</a><ul>
               <li><a href="#rfc.section.2.1">2.1</a>&nbsp;&nbsp;&nbsp;<a href="#versioning">HTTP/2.0 Version Identification</a></li>
               <li><a href="#rfc.section.2.2">2.2</a>&nbsp;&nbsp;&nbsp;<a href="#discover-http">Starting HTTP/2.0 for "http:" URIs</a></li>
               <li><a href="#rfc.section.2.3">2.3</a>&nbsp;&nbsp;&nbsp;<a href="#discover-https">Starting HTTP/2.0 for "https:" URIs</a></li>
               <li><a href="#rfc.section.2.4">2.4</a>&nbsp;&nbsp;&nbsp;<a href="#known-http">Starting HTTP/2.0 with Prior Knowledge</a></li>
            </ul>
         </li>
         <li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#FramingLayer">HTTP/2.0 Framing Layer</a><ul>
               <li><a href="#rfc.section.3.1">3.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.1">Session</a></li>
               <li><a href="#rfc.section.3.2">3.2</a>&nbsp;&nbsp;&nbsp;<a href="#SessionHeader">Session Header</a></li>
               <li><a href="#rfc.section.3.3">3.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.3">Framing</a><ul>
                     <li><a href="#rfc.section.3.3.1">3.3.1</a>&nbsp;&nbsp;&nbsp;<a href="#frame-header">Frame Header</a></li>
                     <li><a href="#rfc.section.3.3.2">3.3.2</a>&nbsp;&nbsp;&nbsp;<a href="#FrameSize">Frame Processing</a></li>
                  </ul>
               </li>
               <li><a href="#rfc.section.3.4">3.4</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.4">Streams</a><ul>
                     <li><a href="#rfc.section.3.4.1">3.4.1</a>&nbsp;&nbsp;&nbsp;<a href="#StreamCreation">Stream Creation</a></li>
                     <li><a href="#rfc.section.3.4.2">3.4.2</a>&nbsp;&nbsp;&nbsp;<a href="#StreamPriority">Stream priority</a></li>
                     <li><a href="#rfc.section.3.4.3">3.4.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.4.3">Stream headers</a></li>
                     <li><a href="#rfc.section.3.4.4">3.4.4</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.4.4">Stream data exchange</a></li>
                     <li><a href="#rfc.section.3.4.5">3.4.5</a>&nbsp;&nbsp;&nbsp;<a href="#StreamHalfClose">Stream half-close</a></li>
                     <li><a href="#rfc.section.3.4.6">3.4.6</a>&nbsp;&nbsp;&nbsp;<a href="#StreamClose">Stream close</a></li>
                  </ul>
               </li>
               <li><a href="#rfc.section.3.5">3.5</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.5">Error Handling</a><ul>
                     <li><a href="#rfc.section.3.5.1">3.5.1</a>&nbsp;&nbsp;&nbsp;<a href="#SessionErrorHandler">Session Error Handling</a></li>
                     <li><a href="#rfc.section.3.5.2">3.5.2</a>&nbsp;&nbsp;&nbsp;<a href="#StreamErrorHandler">Stream Error Handling</a></li>
                  </ul>
               </li>
               <li><a href="#rfc.section.3.6">3.6</a>&nbsp;&nbsp;&nbsp;<a href="#flowcontrol">Stream Flow Control</a><ul>
                     <li><a href="#rfc.section.3.6.1">3.6.1</a>&nbsp;&nbsp;&nbsp;<a href="#fc-principles">Flow Control Principles</a></li>
                     <li><a href="#rfc.section.3.6.2">3.6.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.6.2">Appropriate Use of Flow Control</a></li>
                  </ul>
               </li>
               <li><a href="#rfc.section.3.7">3.7</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.7">Frame Types</a><ul>
                     <li><a href="#rfc.section.3.7.1">3.7.1</a>&nbsp;&nbsp;&nbsp;<a href="#DataFrames">Data Frames</a></li>
                     <li><a href="#rfc.section.3.7.2">3.7.2</a>&nbsp;&nbsp;&nbsp;<a href="#HEADERS_PRIORITY">HEADERS+PRIORITY</a></li>
                     <li><a href="#rfc.section.3.7.3">3.7.3</a>&nbsp;&nbsp;&nbsp;<a href="#RST_STREAM">RST_STREAM</a></li>
                     <li><a href="#rfc.section.3.7.4">3.7.4</a>&nbsp;&nbsp;&nbsp;<a href="#PUSH_PROMISE">PUSH_PROMISE</a></li>
                     <li><a href="#rfc.section.3.7.5">3.7.5</a>&nbsp;&nbsp;&nbsp;<a href="#SETTINGS">SETTINGS</a></li>
                     <li><a href="#rfc.section.3.7.6">3.7.6</a>&nbsp;&nbsp;&nbsp;<a href="#PING">PING</a></li>
                     <li><a href="#rfc.section.3.7.7">3.7.7</a>&nbsp;&nbsp;&nbsp;<a href="#GOAWAY">GOAWAY</a></li>
                     <li><a href="#rfc.section.3.7.8">3.7.8</a>&nbsp;&nbsp;&nbsp;<a href="#HEADERS">HEADERS</a></li>
                     <li><a href="#rfc.section.3.7.9">3.7.9</a>&nbsp;&nbsp;&nbsp;<a href="#WINDOW_UPDATE">WINDOW_UPDATE</a><ul>
                           <li><a href="#rfc.section.3.7.9.1">3.7.9.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.7.9.1">The Flow Control Window</a></li>
                           <li><a href="#rfc.section.3.7.9.2">3.7.9.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.7.9.2">Initial Flow Control Window Size</a></li>
                           <li><a href="#rfc.section.3.7.9.3">3.7.9.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.7.9.3">Reducing the Stream Window Size</a></li>
                           <li><a href="#rfc.section.3.7.9.4">3.7.9.4</a>&nbsp;&nbsp;&nbsp;<a href="#EndFlowControl">Ending Flow Control</a></li>
                        </ul>
                     </li>
                     <li><a href="#rfc.section.3.7.10">3.7.10</a>&nbsp;&nbsp;&nbsp;<a href="#HeaderBlock">Header Block</a></li>
                  </ul>
               </li>
            </ul>
         </li>
         <li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#HTTPLayer">HTTP Message Exchanges</a><ul>
               <li><a href="#rfc.section.4.1">4.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.1">Connection Management</a><ul>
                     <li><a href="#rfc.section.4.1.1">4.1.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.1.1">Use of GOAWAY</a></li>
                  </ul>
               </li>
               <li><a href="#rfc.section.4.2">4.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.2">HTTP Request/Response</a><ul>
                     <li><a href="#rfc.section.4.2.1">4.2.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.2.1">HTTP Header Fields and HTTP/2.0 Headers</a></li>
                     <li><a href="#rfc.section.4.2.2">4.2.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.2.2">Request</a></li>
                     <li><a href="#rfc.section.4.2.3">4.2.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.2.3">Response</a></li>
                     <li><a href="#rfc.section.4.2.4">4.2.4</a>&nbsp;&nbsp;&nbsp;<a href="#Authentication">Authentication</a><ul>
                           <li><a href="#rfc.section.4.2.4.1">4.2.4.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.2.4.1">Stateless Authentication</a></li>
                           <li><a href="#rfc.section.4.2.4.2">4.2.4.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.2.4.2">Stateful Authentication</a></li>
                        </ul>
                     </li>
                  </ul>
               </li>
               <li><a href="#rfc.section.4.3">4.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.3">Server Push Transactions</a><ul>
                     <li><a href="#rfc.section.4.3.1">4.3.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.3.1">Server implementation</a></li>
                     <li><a href="#rfc.section.4.3.2">4.3.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.3.2">Client implementation</a></li>
                  </ul>
               </li>
            </ul>
         </li>
         <li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5">Design Rationale and Notes</a><ul>
               <li><a href="#rfc.section.5.1">5.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.1">Separation of Framing Layer and Application Layer</a></li>
               <li><a href="#rfc.section.5.2">5.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.2">Error handling - Framing Layer</a></li>
               <li><a href="#rfc.section.5.3">5.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.3">One Connection Per Domain</a></li>
               <li><a href="#rfc.section.5.4">5.4</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.4">Fixed vs Variable Length Fields</a></li>
               <li><a href="#rfc.section.5.5">5.5</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.5">Data Compression</a></li>
               <li><a href="#rfc.section.5.6">5.6</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.6">Server Push</a></li>
            </ul>
         </li>
         <li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.6">Security Considerations</a><ul>
               <li><a href="#rfc.section.6.1">6.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.6.1">Use of Same-origin constraints</a></li>
               <li><a href="#rfc.section.6.2">6.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.6.2">Cross-Protocol Attacks</a></li>
               <li><a href="#rfc.section.6.3">6.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.6.3">Cacheability of Pushed Resources</a></li>
            </ul>
         </li>
         <li><a href="#rfc.section.7">7.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.7">Privacy Considerations</a><ul>
               <li><a href="#rfc.section.7.1">7.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.7.1">Long Lived Connections</a></li>
               <li><a href="#rfc.section.7.2">7.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.7.2">SETTINGS frame</a></li>
            </ul>
         </li>
         <li><a href="#rfc.section.8">8.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.8">Acknowledgements</a></li>
         <li><a href="#rfc.section.9">9.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a><ul>
               <li><a href="#rfc.section.9.1">9.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.1">Normative References</a></li>
               <li><a href="#rfc.section.9.2">9.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.2">Informative References</a></li>
            </ul>
         </li>
         <li><a href="#rfc.authors">Authors' Addresses</a></li>
         <li><a href="#rfc.section.A">A.</a>&nbsp;&nbsp;&nbsp;<a href="#change.log">Change Log (to be removed by RFC Editor before publication)</a><ul>
               <li><a href="#rfc.section.A.1">A.1</a>&nbsp;&nbsp;&nbsp;<a href="#changes.since.draft-ietf-httpbis-http2-01">Since draft-ietf-httpbis-http2-01</a></li>
               <li><a href="#rfc.section.A.2">A.2</a>&nbsp;&nbsp;&nbsp;<a href="#changes.since.draft-ietf-httpbis-http2-00">Since draft-ietf-httpbis-http2-00</a></li>
               <li><a href="#rfc.section.A.3">A.3</a>&nbsp;&nbsp;&nbsp;<a href="#changes.since.draft-mbelshe-httpbis-spdy-00">Since draft-mbelshe-httpbis-spdy-00</a></li>
            </ul>
         </li>
         <li><a href="#rfc.index">Index</a></li>
      </ul>
      <ul class="toc">
         <li>Figures
            
            <ul>
               <li><a href="#rfc.figure.1">Figure 1: Frame Header</a></li>
               <li><a href="#rfc.figure.2">Figure 2: HEADERS+PRIORITY Frame Payload</a></li>
               <li><a href="#rfc.figure.3">Figure 3: RST_STREAM Frame Payload</a></li>
               <li><a href="#rfc.figure.4">Figure 4: SETTINGS ID/Value Pair</a></li>
               <li><a href="#rfc.figure.5">Figure 5: SETTINGS ID/Value Pair</a></li>
            </ul>
         </li>
      </ul>
      <h1 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a id="intro" href="#intro">Introduction</a></h1>
      <p id="rfc.section.1.p.1">The Hypertext Transfer Protocol (HTTP) is a wildly successful protocol. The HTTP/1.1 message encapsulation (<a href="#HTTP-p1" id="rfc.xref.HTTP-p1.1"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[HTTP-p1]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/22/p1-messaging.html#http.message" title="Message Format">Section 3</a>) is optimized for implementation simplicity and accessibility, not application performance. As such it has several characteristics
         that have a negative overall effect on application performance.
      </p>
      <p id="rfc.section.1.p.2">The HTTP/1.1 encapsulation ensures that only one request can be delivered at a time on a given connection. HTTP/1.1 pipelining,
         which is not widely deployed, only partially addresses these concerns. Clients that need to make multiple requests therefore
         use commonly multiple connections to a server or servers in order to reduce the overall latency of those requests. <span class="comment" id="rfc.comment.1">[<a href="#rfc.comment.1" class="smpl">rfc.comment.1</a>: Need to tune the anti-pipelining comments here.]</span> 
      </p>
      <p id="rfc.section.1.p.3">Furthermore, HTTP/1.1 header fields are represented in an inefficient fashion, which, in addition to generating more or larger
         network packets, can cause the small initial TCP window to fill more quickly than is ideal. This results in excessive latency
         where multiple requests are made on a new TCP connection.
      </p>
      <p id="rfc.section.1.p.4">This document defines an optimized mapping of the HTTP semantics to a TCP connection. This optimization reduces the latency
         costs of HTTP by allowing parallel requests on the same connection and by using an efficient coding for HTTP header fields.
         Prioritization of requests lets more important requests complete faster, further improving application performance.
      </p>
      <p id="rfc.section.1.p.5">HTTP/2.0 applications have an improved impact on network congestion due to the use of fewer TCP connections to achieve the
         same effect. Fewer TCP connections compete more fairly with other flows. Long-lived connections are also more able to take
         better advantage of the available network capacity, rather than operating in the slow start phase of TCP.
      </p>
      <p id="rfc.section.1.p.6">The HTTP/2.0 encapsulation also enables more efficient processing of messages by providing efficient message framing. Processing
         of header fields in HTTP/2.0 messages is more efficient (for entities that process many messages).
      </p>
      <h2 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1</a>&nbsp;Document Organization
      </h2>
      <p id="rfc.section.1.1.p.1">The HTTP/2.0 Specification is split into three parts: starting HTTP/2.0 (<a href="#starting" title="Starting HTTP/2.0">Section&nbsp;2</a>), which covers how a HTTP/2.0 is started; a framing layer (<a href="#FramingLayer" title="HTTP/2.0 Framing Layer">Section&nbsp;3</a>), which multiplexes a TCP connection into independent, length-prefixed frames; and an HTTP layer (<a href="#HTTPLayer" title="HTTP Message Exchanges">Section&nbsp;4</a>), which specifies the mechanism for overlaying HTTP request/response pairs on top of the framing layer. While some of the
         framing layer concepts are isolated from the HTTP layer, building a generic framing layer has not been a goal. The framing
         layer is tailored to the needs of the HTTP protocol and server push.
      </p>
      <h2 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2</a>&nbsp;Conventions and Terminology
      </h2>
      <p id="rfc.section.1.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL"
         in this document are to be interpreted as described in <a href="#RFC2119">RFC 2119</a> <cite title="Key words for use in RFCs to Indicate Requirement Levels" id="rfc.xref.RFC2119.1">[RFC2119]</cite>.
      </p>
      <p id="rfc.section.1.2.p.2">All numeric values are in network byte order. Values are unsigned unless otherwise indicated. Literal values are provided
         in decimal or hexadecimal as appropriate. Hexadecimal literals are prefixed with <samp>0x</samp> to distinguish them from decimal literals.
      </p>
      <p id="rfc.section.1.2.p.3">The following terms are used: </p>
      <dl>
         <dt>client:</dt>
         <dd>The endpoint initiating the HTTP/2.0 session.</dd>
         <dt>connection:</dt>
         <dd>A transport-level connection between two endpoints.</dd>
         <dt>endpoint:</dt>
         <dd>Either the client or server of a connection.</dd>
         <dt>frame:</dt>
         <dd>The smallest unit of communication, each containing a frame header.</dd>
         <dt>message:</dt>
         <dd>A complete sequence of frames.</dd>
         <dt>receiver:</dt>
         <dd>An endpoint that is receiving frames.</dd>
         <dt>sender:</dt>
         <dd>An endpoint that is transmitting frames.</dd>
         <dt>server:</dt>
         <dd>The endpoint which did not initiate the HTTP/2.0 session.</dd>
         <dt>session:</dt>
         <dd>A synonym for a connection.</dd>
         <dt>session error:</dt>
         <dd>An error on the HTTP/2.0 session.</dd>
         <dt>stream:</dt>
         <dd>A bi-directional flow of bytes across a virtual channel within a HTTP/2.0 session.</dd>
         <dt>stream error:</dt>
         <dd>An error on an individual HTTP/2.0 stream.</dd>
      </dl>
      <h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a>&nbsp;<a id="starting" href="#starting">Starting HTTP/2.0</a></h1>
      <p id="rfc.section.2.p.1">Just as HTTP/1.1 does, HTTP/2.0 uses the "http:" and "https:" URI schemes. An HTTP/2.0-capable client is therefore required
         to discover whether a server (or intermediary) supports HTTP/2.0.
      </p>
      <p id="rfc.section.2.p.2">Different discovery mechanisms are defined for "http:" and "https:" URIs. Discovery for "http:" URIs is described in <a href="#discover-http" title="Starting HTTP/2.0 for &#34;http:&#34; URIs">Section&nbsp;2.2</a>; discovery for "https:" URIs is described in <a href="#discover-https" title="Starting HTTP/2.0 for &#34;https:&#34; URIs">Section&nbsp;2.3</a>.
      </p>
      <h2 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1</a>&nbsp;<a id="versioning" href="#versioning">HTTP/2.0 Version Identification</a></h2>
      <p id="rfc.section.2.1.p.1">HTTP/2.0 is identified using the string "HTTP/2.0". This identification is used in the HTTP/1.1 Upgrade header field, in the <a href="#TLSNPN">TLS-NPN</a> <cite title="Transport Layer Security (TLS) Next Protocol Negotiation Extension" id="rfc.xref.TLSNPN.1">[TLSNPN]</cite>  <span class="comment" id="rfc.comment.2">[<a href="#rfc.comment.2" class="smpl">rfc.comment.2</a>: TBD]</span> field and other places where protocol identification is required.
      </p>
      <p id="rfc.section.2.1.p.2">Negotiating "HTTP/2.0" implies the use of the transport, security, framing and message semantics described in this document.</p>
      <p id="rfc.section.2.1.p.3"> <span class="comment" id="rfc.comment.3">[<a href="#rfc.comment.3" class="smpl">rfc.comment.3</a>: Editor's Note: please remove the following text prior to the publication of a final version of this document.]</span> 
      </p>
      <p id="rfc.section.2.1.p.4">Only implementations of the final, published RFC can identify themselves as "HTTP/2.0". Until such an RFC exists, implementations
         MUST NOT identify themselves using "HTTP/2.0".
      </p>
      <p id="rfc.section.2.1.p.5">Examples and text throughout the rest of this document use "HTTP/2.0" as a matter of editorial convenience only. Implementations
         of draft versions MUST NOT identify using this string.
      </p>
      <p id="rfc.section.2.1.p.6">Implementations of draft versions of the protocol MUST add the string "-draft-" and the corresponding draft number to the
         identifier before the separator ('/'). For example, draft-ietf-httpbis-http2-03 is identified using the string "HTTP-draft-03/2.0".
      </p>
      <p id="rfc.section.2.1.p.7">Non-compatible experiments that are based on these draft versions MUST instead replace the string "draft" with a different
         identifier. For example, an experimental implementation of packet mood-based encoding based on draft-ietf-httpbis-http2-07
         might identify itself as "HTTP-emo-07/2.0". Note that any label MUST conform with the "token" syntax defined in <a href="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/22/p1-messaging.html#field.components" title="Field value components">Section 3.2.6</a> of <a href="#HTTP-p1" id="rfc.xref.HTTP-p1.2"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[HTTP-p1]</cite></a>. Experimenters are encouraged to coordinate their experiments on the ietf-http-wg@w3.org mailing list.
      </p>
      <h2 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2</a>&nbsp;<a id="discover-http" href="#discover-http">Starting HTTP/2.0 for "http:" URIs</a></h2>
      <p id="rfc.section.2.2.p.1">A client that makes a request to an "http:" URI without prior knowledge about support for HTTP/2.0 uses the HTTP Upgrade mechanism
         (<a href="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/22/p1-messaging.html#header.upgrade" title="Upgrade">Section 6.7</a> of <a href="#HTTP-p1" id="rfc.xref.HTTP-p1.3"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[HTTP-p1]</cite></a>). The client makes an HTTP/1.1 request that includes an Upgrade header field identifying HTTP/2.0.
      </p>
      <p id="rfc.section.2.2.p.2">For example:</p>
      <div id="rfc.figure.u.1"></div> <pre class="text2">GET /default.htm HTTP/1.1
Host: server.example.com
Connection: Upgrade
Upgrade: HTTP/2.0
</pre> <p id="rfc.section.2.2.p.4">A server that does not support HTTP/2.0 can respond to the request as though the Upgrade header field were absent:</p>
      <div id="rfc.figure.u.2"></div> <pre class="text">HTTP/1.1 200 OK
Content-length: 243
Content-type: text/html
      ...
</pre> <p id="rfc.section.2.2.p.6">A server that supports HTTP/2.0 can accept the upgrade with a 101 (Switching Protocols) status code. After the empty line
         that terminates the 101 response, the server can begin sending HTTP/2.0 frames. These frames MUST include a response to the
         request that initiated the Upgrade.
      </p>
      <div id="rfc.figure.u.3"></div> <pre class="text">HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: HTTP/2.0

[ HTTP/2.0 session ...
</pre> <p id="rfc.section.2.2.p.8">Once the server returns the 101 response, both the client and the server send a session header (<a href="#SessionHeader" title="Session Header">Section&nbsp;3.2</a>).
      </p>
      <h2 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3</a>&nbsp;<a id="discover-https" href="#discover-https">Starting HTTP/2.0 for "https:" URIs</a></h2>
      <p id="rfc.section.2.3.p.1">A client that makes a request to an "https:" URI without prior knowledge about support for HTTP/2.0 uses <a href="#RFC5246">TLS</a> <cite title="The Transport Layer Security (TLS) Protocol Version 1.2" id="rfc.xref.RFC5246.1">[RFC5246]</cite> with <a href="#TLSNPN">TLS-NPN</a> <cite title="Transport Layer Security (TLS) Next Protocol Negotiation Extension" id="rfc.xref.TLSNPN.2">[TLSNPN]</cite> extension. <span class="comment" id="rfc.comment.4">[<a href="#rfc.comment.4" class="smpl">rfc.comment.4</a>: TBD, maybe ALPN]</span> 
      </p>
      <p id="rfc.section.2.3.p.2">Once TLS negotiation is complete, both the client and the server send a session header (<a href="#SessionHeader" title="Session Header">Section&nbsp;3.2</a>).
      </p>
      <h2 id="rfc.section.2.4"><a href="#rfc.section.2.4">2.4</a>&nbsp;<a id="known-http" href="#known-http">Starting HTTP/2.0 with Prior Knowledge</a></h2>
      <p id="rfc.section.2.4.p.1">A client can learn that a particular server supports HTTP/2.0 by other means. A client MAY immediately send HTTP/2.0 frames
         to a server that is known to support HTTP/2.0. This only affects the resolution of "http:" URIs, servers supporting HTTP/2.0
         are required to support <a href="#TLSNPN">protocol negotiation in TLS</a> <cite title="Transport Layer Security (TLS) Next Protocol Negotiation Extension" id="rfc.xref.TLSNPN.3">[TLSNPN]</cite>.
      </p>
      <p id="rfc.section.2.4.p.2">Prior support for HTTP/2.0 is not a strong signal that a given server will support HTTP/2.0 for future sessions. It is possible
         for server configurations to change or for configurations to differ between instances in clustered server. Different "transparent"
         intermediaries - intermediaries that are not explicitly selected by either client or server - are another source of variability.
      </p>
      <h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a>&nbsp;<a id="FramingLayer" href="#FramingLayer">HTTP/2.0 Framing Layer</a></h1>
      <h2 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1</a>&nbsp;Session
      </h2>
      <p id="rfc.section.3.1.p.1">The HTTP/2.0 session runs atop TCP (<a href="#RFC0793" id="rfc.xref.RFC0793.1"><cite title="Transmission Control Protocol">[RFC0793]</cite></a>). The client is the TCP connection initiator.
      </p>
      <p id="rfc.section.3.1.p.2">HTTP/2.0 connections are persistent connections. For best performance, it is expected that clients will not close open connections
         until the user navigates away from all web pages referencing a connection, or until the server closes the connection. Servers
         are encouraged to leave connections open for as long as possible, but can terminate idle connections if necessary. When either
         endpoint closes the transport-level connection, it MUST first send a GOAWAY (<a href="#GOAWAY" title="GOAWAY">Section&nbsp;3.7.7</a>) frame so that the endpoints can reliably determine if requests finished before the close.
      </p>
      <h2 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2</a>&nbsp;<a id="SessionHeader" href="#SessionHeader">Session Header</a></h2>
      <p id="rfc.section.3.2.p.1">After opening a TCP connection and performing either an HTTP/1.1 Upgrade or TLS handshake, the client sends the client session
         header. The server replies with a server session header.
      </p>
      <p id="rfc.section.3.2.p.2">The session header provides a final confirmation that both peers agree to use the HTTP/2.0 protocol. The SETTINGS frame ensures
         that client or server configuration is known as quickly as possible.
      </p>
      <p id="rfc.section.3.2.p.3">The client session header is the 25 byte sequence 0x464f4f202a20485454502f322e300d0a0d0a4241520d0a0d0a (the string <samp>FOO * HTTP/2.0\r\n\r\nBAR\r\n\r\n</samp>) followed by a SETTINGS frame (<a href="#SETTINGS" title="SETTINGS">Section&nbsp;3.7.5</a>). The client sends the client session header immediately after receiving an HTTP/1.1 Upgrade, or after receiving a TLS Finished
         message from the server.
      </p>
      <p id="rfc.section.3.2.p.4"> </p>
      <ul class="empty">
         <li>The client session header is selected so that a large proportion of HTTP/1.1 or HTTP/1.0 servers and intermediaries do not
            attempt to process further frames. This doesn't address the concerns raised in <a href="#TALKING" id="rfc.xref.TALKING.1"><cite title="Talking to Yourself for Fun and Profit">[TALKING]</cite></a>.
         </li>
      </ul>
      <p id="rfc.section.3.2.p.5">The server session header is a SETTINGS frame (<a href="#SETTINGS" title="SETTINGS">Section&nbsp;3.7.5</a>). The server sends the server session header immediately after receiving and validating the client session header.
      </p>
      <p id="rfc.section.3.2.p.6">The client sends requests immediately after sending the session header, without waiting to receive a server session header.
         This ensures that confirming session headers does not add latency.
      </p>
      <p id="rfc.section.3.2.p.7">Both client and server MUST close the connection if it does not begin with a valid session header. A GOAWAY frame (<a href="#GOAWAY" title="GOAWAY">Section&nbsp;3.7.7</a>) MAY be omitted if it is clear that the peer is not using HTTP/2.0.
      </p>
      <h2 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3</a>&nbsp;Framing
      </h2>
      <p id="rfc.section.3.3.p.1">Once the connection is established, clients and servers exchange HTTP/2.0 frames. Frames are the basic unit of communication.</p>
      <h3 id="rfc.section.3.3.1"><a href="#rfc.section.3.3.1">3.3.1</a>&nbsp;<a id="frame-header" href="#frame-header">Frame Header</a></h3>
      <p id="rfc.section.3.3.1.p.1">HTTP/2.0 frames share a common header format. Frames have an 8 byte header with between 0 and 65535 bytes of data.</p>
      <div id="rfc.figure.1"></div> <pre class="inline"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Length (16)           |   Type (8)    |   Flags (8)   |
+-+-------------+---------------+-------------------------------+
|R|                   Identifier (31)                           |
+-+-------------------------------------------------------------+
|                     Frame Data (0...)                       ...
+---------------------------------------------------------------+
</pre> <p class="figure">Figure 1: Frame Header</p>
      <p id="rfc.section.3.3.1.p.3">The fields of the frame header are defined as: </p>
      <dl>
         <dt>Length:</dt>
         <dd>The 16-bit length of the frame payload in bytes. The length of the frame header is not included in this sum.</dd>
         <dt>Type:</dt>
         <dd>The 8-bit type of the frame. The frame type determines how the remainder of the frame header and payload are interpreted.</dd>
         <dt>Flags:</dt>
         <dd>An 8-bit field reserved for flags. The semantics of each bit in flags depends on the frame type. Bits that have undefined
            semantics are reserved.
         </dd>
         <dt>R:</dt>
         <dd>A reserved 1-bit field. The semantics of this bit are not defined.</dd>
         <dt>Identifier:</dt>
         <dd>A 31-bit identifier for the frame. The frame type determines how this identifier is interpreted. For many frame types, this
            field includes a stream number.
         </dd>
         <dt>Frame Data:</dt>
         <dd>Frames contain between 0 and 65535 bytes of data.</dd>
      </dl>
      <p id="rfc.section.3.3.1.p.4">Reserved bits in the frame header MUST be set to zero when sending and MUST be ignored when receiving frames, unless the semantics
         of the bit are known.
      </p>
      <h3 id="rfc.section.3.3.2"><a href="#rfc.section.3.3.2">3.3.2</a>&nbsp;<a id="FrameSize" href="#FrameSize">Frame Processing</a></h3>
      <p id="rfc.section.3.3.2.p.1">A frame of the maximum size might be too large for implementations with limited resources to process. Implementations MAY
         choose to support frames smaller than the maximum possible size. However, implementations MUST be able to receive frames containing
         at least 8192 octets of payload.
      </p>
      <p id="rfc.section.3.3.2.p.2">An implementation MUST immediately close a stream if it is unable to process a frame related to that stream due to it exceeding
         a size limit. The implementation MUST send a RST_STREAM frame (<a href="#RST_STREAM" title="RST_STREAM">Section&nbsp;3.7.3</a>) containing FRAME_TOO_LARGE error code if the frame size limit is exceeded.
      </p>
      <p id="rfc.section.3.3.2.p.3"> <span class="comment" id="rfc.comment.5">[<a href="#rfc.comment.5" class="smpl">rfc.comment.5</a>: <a href="https://github.com/http2/http2-spec/issues/28">Issue 28</a>: Need a way to signal the maximum frame size; no way to RST_STREAM on non-stream-related frames.]</span> 
      </p>
      <h2 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4</a>&nbsp;Streams
      </h2>
      <p id="rfc.section.3.4.p.1">Streams are independent sequences of bi-directional data divided into frames with several properties: </p>
      <ul>
         <li>Streams can be created by either the client or server.</li>
         <li>Streams optionally carry a set of name-value header pairs.</li>
         <li>Streams can concurrently send data interleaved with other streams.</li>
         <li>Streams can be established and used unilaterally.</li>
         <li>Streams can be cancelled.</li>
      </ul>
      <h3 id="rfc.section.3.4.1"><a href="#rfc.section.3.4.1">3.4.1</a>&nbsp;<a id="StreamCreation" href="#StreamCreation">Stream Creation</a></h3>
      <p id="rfc.section.3.4.1.p.1">Use of streams does not require negotiation. A stream is not created, streams are used by sending a frame on the stream.</p>
      <p id="rfc.section.3.4.1.p.2">Streams initiated by a client use odd numbered stream identifiers. Streams initiated by the server use odd numbered stream
         identifiers. A stream identifier of zero MUST NOT be used to create a new stream.
      </p>
      <p id="rfc.section.3.4.1.p.3">The stream identifier of a new stream MUST be greater than all other streams from that endpoint. If an endpoint receives the
         first frame on a stream with an identifier that is less than or equal to a previously used stream, it MUST issue a session error (<a href="#SessionErrorHandler" title="Session Error Handling">Section&nbsp;3.5.1</a>) with the status PROTOCOL_ERROR.
      </p>
      <p id="rfc.section.3.4.1.p.4">A long-lived session can result in available stream identifiers being exhausted. An endpoint that is unable to create a new
         stream identifier can establish a new session for any new streams.
      </p>
      <p id="rfc.section.3.4.1.p.5">An endpoint cannot prevent the creation of a new stream, but it can request the early termination of an unwanted stream. Upon
         receipt of a frame, the recipient can terminate the corresponding stream by sending a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;3.5.2</a>) with the error code REFUSED_STREAM. This cannot prevent the initiating endpoint from sending frames for that stream prior
         to receiving this request.
      </p>
      <h3 id="rfc.section.3.4.2"><a href="#rfc.section.3.4.2">3.4.2</a>&nbsp;<a id="StreamPriority" href="#StreamPriority">Stream priority</a></h3>
      <p id="rfc.section.3.4.2.p.1">The creator of a stream assigns a priority for that stream. Priority is represented as a 31 bit integer. 0 represents the
         highest priority and 2<sup>31</sup>-1 represents the lowest priority.
      </p>
      <p id="rfc.section.3.4.2.p.2">The sender and recipient SHOULD use best-effort to process streams in the order of highest priority to lowest priority. <span class="comment" id="rfc.comment.6">[<a href="#rfc.comment.6" class="smpl">rfc.comment.6</a>: ED: toothless, useless "SHOULD": reword]</span> 
      </p>
      <h3 id="rfc.section.3.4.3"><a href="#rfc.section.3.4.3">3.4.3</a>&nbsp;Stream headers
      </h3>
      <p id="rfc.section.3.4.3.p.1">Streams carry optional sets of pair headers which carry metadata about the stream. After the stream has been created, and
         as long as the sender is not closed (<a href="#StreamClose" title="Stream close">Section&nbsp;3.4.6</a>) or half-closed (<a href="#StreamHalfClose" title="Stream half-close">Section&nbsp;3.4.5</a>), each side may send HEADERS frame(s) containing the header data. Header data can be sent in multiple HEADERS frames, and
         HEADERS frames may be interleaved with data frames.
      </p>
      <h3 id="rfc.section.3.4.4"><a href="#rfc.section.3.4.4">3.4.4</a>&nbsp;Stream data exchange
      </h3>
      <p id="rfc.section.3.4.4.p.1">Once a stream is created, it can be used to send arbitrary amounts of data. Generally this means that a series of data frames
         will be sent on the stream until a frame containing the FINAL flag is set. Once the FINAL flag has been set on a message,
         the stream is considered to be half-closed.
      </p>
      <h3 id="rfc.section.3.4.5"><a href="#rfc.section.3.4.5">3.4.5</a>&nbsp;<a id="StreamHalfClose" href="#StreamHalfClose">Stream half-close</a></h3>
      <p id="rfc.section.3.4.5.p.1">When one side of the stream sends a frame with the FINAL flag set, the stream is half-closed from that endpoint. The sender
         of the FINAL flag MUST NOT send further frames on that stream. When both sides have half-closed, the stream is closed.
      </p>
      <p id="rfc.section.3.4.5.p.2">If an endpoint receives a data frame after the stream is half-closed from the sender (e.g. the endpoint has already received
         a prior frame for the stream with the FINAL flag set), it MUST send a RST_STREAM to the sender with the status STREAM_ALREADY_CLOSED.
      </p>
      <p id="rfc.section.3.4.5.p.3">Streams that have never received packets can be considered to be half-closed in the direction that is silent. This allows
         either peer to create a unidirectional stream, which does not require an explicit close from the peer that does not transmit
         frames.
      </p>
      <h3 id="rfc.section.3.4.6"><a href="#rfc.section.3.4.6">3.4.6</a>&nbsp;<a id="StreamClose" href="#StreamClose">Stream close</a></h3>
      <p id="rfc.section.3.4.6.p.1">Streams can be terminated in the following ways:</p>
      <p id="rfc.section.3.4.6.p.2">Normal termination: </p>
      <ul class="empty">
         <li>Normal stream termination occurs when both sender and recipient have half-closed the stream by sending a frame containing
            a FINAL flag.
         </li>
      </ul>
      <p id="rfc.section.3.4.6.p.3">Half-close on unidirectional stream: </p>
      <ul class="empty">
         <li>A stream that only has frames sent in one direction can be tentatively considered to be closed once a frame containing a FINAL
            flag is sent. The active sender on the stream MUST be prepared to receive frames after closing the stream.
         </li>
      </ul>
      <p id="rfc.section.3.4.6.p.4">Abrupt termination: </p>
      <ul class="empty">
         <li>Either the client or server can send a RST_STREAM control frame at any time. A RST_STREAM contains an error code to indicate
            the reason for failure. When a RST_STREAM is sent from the stream originator, it indicates a failure to complete the stream
            and that no further data will be sent on the stream. When a RST_STREAM is sent from the stream recipient, the sender, upon
            receipt, should stop sending any data on the stream. The stream recipient should be aware that there is a race between data
            already in transit from the sender and the time the RST_STREAM is received. See Stream Error Handling (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;3.5.2</a>). <span class="comment" id="rfc.comment.7">[<a href="#rfc.comment.7" class="smpl">rfc.comment.7</a>: ED: confusing: streams are bidirectional, and both peers might be sending concurrently]</span> 
         </li>
      </ul>
      <p id="rfc.section.3.4.6.p.5">TCP connection teardown: </p>
      <ul class="empty">
         <li>If the TCP connection is torn down while un-closed streams exist, then the endpoint must assume that the stream was abnormally
            interrupted and may be incomplete.
         </li>
      </ul>
      <p id="rfc.section.3.4.6.p.6">If an endpoint receives a data frame after the stream is closed, it must send a RST_STREAM to the sender with the status PROTOCOL_ERROR.</p>
      <h2 id="rfc.section.3.5"><a href="#rfc.section.3.5">3.5</a>&nbsp;Error Handling
      </h2>
      <p id="rfc.section.3.5.p.1">The HTTP/2.0 framing layer has only two types of errors, and they are always handled consistently. Any reference in this specification
         to "issue a session error" refers to <a href="#SessionErrorHandler" title="Session Error Handling">Section&nbsp;3.5.1</a>. Any reference to "issue a stream error" refers to <a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;3.5.2</a>.
      </p>
      <h3 id="rfc.section.3.5.1"><a href="#rfc.section.3.5.1">3.5.1</a>&nbsp;<a id="SessionErrorHandler" href="#SessionErrorHandler">Session Error Handling</a></h3>
      <p id="rfc.section.3.5.1.p.1">A session error is any error which prevents further processing of the framing layer or which corrupts any session state. When
         a session error occurs, the endpoint encountering the error MUST first send a GOAWAY (<a href="#GOAWAY" title="GOAWAY">Section&nbsp;3.7.7</a>) frame with the stream identifier of the most recently received stream from the remote endpoint, and the error code for why
         the session is terminating. After sending the GOAWAY frame, the endpoint MUST close the TCP connection.
      </p>
      <p id="rfc.section.3.5.1.p.2">Note that because this GOAWAY is sent during a session error case, it is possible that the GOAWAY will not be reliably received
         by the receiving endpoint. It is a best-effort attempt to communicate with the remote about why the session is going down.
      </p>
      <h3 id="rfc.section.3.5.2"><a href="#rfc.section.3.5.2">3.5.2</a>&nbsp;<a id="StreamErrorHandler" href="#StreamErrorHandler">Stream Error Handling</a></h3>
      <p id="rfc.section.3.5.2.p.1">A stream error is an error related to a specific stream identifier which does not affect processing of other streams at the
         framing layer. Upon a stream error, the endpoint MUST send a RST_STREAM (<a href="#RST_STREAM" title="RST_STREAM">Section&nbsp;3.7.3</a>) frame which contains the stream identifier of the stream where the error occurred and a code indicating the type of error.
         After sending the RST_STREAM, the stream is closed to the sending endpoint. After sending the RST_STREAM, if the sender receives
         any frames other than a RST_STREAM for that stream identifier, it will result in sending additional RST_STREAM frames. An
         endpoint MUST NOT send a RST_STREAM in response to an RST_STREAM, as doing so would lead to RST_STREAM loops. Sending a RST_STREAM
         does not cause the HTTP/2.0 session to be closed.
      </p>
      <p id="rfc.section.3.5.2.p.2">If an endpoint has multiple RST_STREAM frames to send in succession for the same stream identifier and the same error code,
         it MAY coalesce them into a single RST_STREAM frame. (This can happen if a stream is closed, but the remote sends multiple
         data frames. There is no reason to send a RST_STREAM for each frame in succession). <span class="comment" id="rfc.comment.8">[<a href="#rfc.comment.8" class="smpl">rfc.comment.8</a>: Ed: why not suggest that endpoints stop sending RST_STREAM? One is probably enough, except for diagnosing strange error scenarios.
            Needs better justification.]</span> 
      </p>
      <h2 id="rfc.section.3.6"><a href="#rfc.section.3.6">3.6</a>&nbsp;<a id="flowcontrol" href="#flowcontrol">Stream Flow Control</a></h2>
      <p id="rfc.section.3.6.p.1">Multiplexing streams introduces contention for access to the shared TCP connection. Stream contention can result in streams
         being blocked by other streams. A flow control scheme ensures that streams do not destructively interfere with other streams
         on the same TCP connection.
      </p>
      <h3 id="rfc.section.3.6.1"><a href="#rfc.section.3.6.1">3.6.1</a>&nbsp;<a id="fc-principles" href="#fc-principles">Flow Control Principles</a></h3>
      <p id="rfc.section.3.6.1.p.1">Experience with TCP congestion control has shown that algorithms can evolve over time to become more sophisticated without
         requiring protocol changes. TCP congestion control and its evolution is clearly different from HTTP/2.0 flow control, though
         the evolution of TCP congestion control algorithms shows that a similar approach could be feasible for HTTP/2.0 flow control.
      </p>
      <p id="rfc.section.3.6.1.p.2">HTTP/2.0 stream flow control aims to allow for future improvements to flow control algorithms without requiring protocol changes.
         Flow control in HTTP/2.0 has the following characteristics: 
      </p>
      <ol>
         <li>Flow control is hop-by-hop, not end-to-end.</li>
         <li>Flow control is based on window update messages. Receivers advertise how many octets they are prepared to receive on a stream.
            This is a credit-based scheme.
         </li>
         <li>Flow control is directional with overall control provided by the receiver. A receiver MAY choose to set any window size that
            it desires for each stream and for the entire connection. A sender MUST respect flow control limits imposed by a receiver.
            Clients, servers and intermediaries all independently advertise their flow control preferences as a receiver and abide by
            the flow control limits set by their peer when sending.
         </li>
         <li>The initial value for the flow control window is 65536 bytes for both new streams and the overall connection.</li>
         <li>The frame type determines whether flow control applies to a frame. Of the frames specified in this document, only data frames
            are subject to flow control; all other frame types do not consume space in the advertised flow control window. This ensures
            that important control frames are not blocked by flow control.
         </li>
         <li>Flow control can be disabled by a receiver. A receiver can choose to either disable flow control for a stream or connection
            by declaring an infinite flow control limit.
         </li>
         <li>HTTP/2.0 standardizes only the format of the window update message (<a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">Section&nbsp;3.7.9</a>). This does not stipulate how a receiver decides when to send this message or the value that it sends. Nor does it specify
            how a sender chooses to send packets. Implementations are able to select any algorithm that suits their needs.
         </li>
      </ol>
      <p id="rfc.section.3.6.1.p.3">Implementations are also responsible for managing how requests and responses are sent based on priority; choosing how to avoid
         head of line blocking for requests; and managing the creation of new streams. Algorithm choices for these could interact with
         any flow control algorithm.
      </p>
      <h3 id="rfc.section.3.6.2"><a href="#rfc.section.3.6.2">3.6.2</a>&nbsp;Appropriate Use of Flow Control
      </h3>
      <p id="rfc.section.3.6.2.p.1">Flow control is defined to protect deployments (client, server or intermediary) that are operating under constraints. For
         example, a proxy must share memory between many connections. Flow control addresses cases where the receiver is unable process
         data on one stream, yet wants to be continue to process other streams.
      </p>
      <p id="rfc.section.3.6.2.p.2">Deployments that do not rely on this capability SHOULD disable flow control for data that is being received. Note that flow
         control cannot be disabled for sending. Sending data is always subject to the flow control window advertised by the receiver.
      </p>
      <p id="rfc.section.3.6.2.p.3">Deployments with constrained resources (for example, memory), MAY employ flow control to limit the amount of memory a peer
         can consume. This can lead to suboptimal use of available network resources if flow control is enabled without knowledge of
         the bandwidth-delay product (see <a href="#RFC1323" id="rfc.xref.RFC1323.1"><cite title="TCP Extensions for High Performance">[RFC1323]</cite></a>).
      </p>
      <p id="rfc.section.3.6.2.p.4">Implementation of flow control in full awareness of the current bandwidth-delay product is difficult, but it can ensure that
         constrained resources are protected without any reduction in connection utilization.
      </p>
      <h2 id="rfc.section.3.7"><a href="#rfc.section.3.7">3.7</a>&nbsp;Frame Types
      </h2>
      <h3 id="rfc.section.3.7.1"><a href="#rfc.section.3.7.1">3.7.1</a>&nbsp;<a id="DataFrames" href="#DataFrames">Data Frames</a></h3>
      <p id="rfc.section.3.7.1.p.1">Data frames (type=0) are used to convey HTTP message bodies. The payload of a data frame contains either a request or response
         body.
      </p>
      <p id="rfc.section.3.7.1.p.2">Valid flags for data frames are: </p>
      <dl>
         <dt>FINAL (0x1):</dt>
         <dd>Bit 1 (the least significant flag bit) being set signifies that this frame is the last frame to be transmitted on this stream
            (see Stream Close (<a href="#StreamClose" title="Stream close">Section&nbsp;3.4.6</a>)).
         </dd>
         <dt>COMPRESSED (0x2):</dt>
         <dd>Bit 2 being set indicates that the data in the frame has been compressed with ZLIB compression (<a href="#RFC1950" id="rfc.xref.RFC1950.1"><cite title="ZLIB Compressed Data Format Specification version 3.3">[RFC1950]</cite></a>).
         </dd>
      </dl>
      <p id="rfc.section.3.7.1.p.3">The identifier field in the data frame header MUST contain a stream identifier for an open stream.</p>
      <p id="rfc.section.3.7.1.p.4">Data frame processing requirements: </p>
      <ul>
         <li>If an endpoint receives a data frame for a stream-id which is not open and the endpoint has not sent a GOAWAY (<a href="#GOAWAY" title="GOAWAY">Section&nbsp;3.7.7</a>) frame, it MUST send issue a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;3.5.2</a>) with the error code INVALID_STREAM for the stream-id.
         </li>
         <li>If the endpoint that created the stream receives a data frame before receiving a HEADERS frame on that stream, it is a protocol
            error, and the recipient MUST issue a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;3.5.2</a>) with the error code PROTOCOL_ERROR for the stream-id. <span class="comment" id="rfc.comment.9">[<a href="#rfc.comment.9" class="smpl">rfc.comment.9</a>: ED: isn't this a usage problem? doesn't this belong in the HTTP-mapping section?]</span> 
         </li>
         <li>Implementers note: If an endpoint receives multiple data frames for invalid stream-ids, it MAY close the session.</li>
         <li>All HTTP/2.0 endpoints MUST accept compressed data frames. Compression of data frames is always done using zlib compression.
            Each stream initializes and uses its own compression context dedicated to use within that stream. Endpoints are encouraged
            to use application level compression rather than HTTP/2.0 stream level compression.
         </li>
         <li>Each HTTP/2.0 stream sending compressed frames creates a separate zlib context for the data streams on that stream. Thus,
            if both endpoints of a stream are compressing data on the stream, there will be two zlib contexts, one for sending and one
            for receiving.
         </li>
      </ul>
      <h3 id="rfc.section.3.7.2"><a href="#rfc.section.3.7.2">3.7.2</a>&nbsp;<a id="HEADERS_PRIORITY" href="#HEADERS_PRIORITY">HEADERS+PRIORITY</a></h3>
      <p id="rfc.section.3.7.2.p.1">The HEADERS+PRIORITY frame (type=1) allows the sender to set headers and stream priority at the same time. This MUST be used
         for each stream that is created.
      </p>
      <div id="rfc.figure.2"></div> <pre class="inline"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|X|                   Priority (31)                             |
+-+-------------------------------------------------------------+
|                    Header Block (*)                         ...
+---------------------------------------------------------------+
</pre> <p class="figure">Figure 2: HEADERS+PRIORITY Frame Payload</p>
      <p id="rfc.section.3.7.2.p.3">The HEADERS+PRIORITY frame is identical to the HEADERS frame (<a href="#HEADERS" title="HEADERS">Section&nbsp;3.7.8</a>), with a 32-bit field containing priority included before the header block.
      </p>
      <p id="rfc.section.3.7.2.p.4">The most significant bit of the priority is reserved. The 31-bit priority indicates the priority for the stream, as assigned
         by the sender, see <a href="#StreamPriority" title="Stream priority">Section&nbsp;3.4.2</a>.
      </p>
      <h3 id="rfc.section.3.7.3"><a href="#rfc.section.3.7.3">3.7.3</a>&nbsp;<a id="RST_STREAM" href="#RST_STREAM">RST_STREAM</a></h3>
      <p id="rfc.section.3.7.3.p.1">The RST_STREAM frame (type=3) allows for abnormal termination of a stream. When sent by the creator of a stream, it indicates
         the creator wishes to cancel the stream. When sent by the recipient of a stream, it indicates an error or that the recipient
         did not want to accept the stream, so the stream should be closed.
      </p>
      <div id="rfc.figure.3"></div> <pre class="inline"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Error Code (32)                       |
+---------------------------------------------------------------+
</pre> <p class="figure">Figure 3: RST_STREAM Frame Payload</p>
      <p id="rfc.section.3.7.3.p.3">The RST_STREAM frame does not define any valid flags.</p>
      <p id="rfc.section.3.7.3.p.4">The identifier field in the frame header MUST contain the stream identifier for an open stream.</p>
      <p id="rfc.section.3.7.3.p.5">The RST_STREAM frame contains a single 32-bit error code. The error code indicates why the stream is being terminated. The
         following error codes are defined: 
      </p>
      <dl>
         <dt>PROTOCOL_ERROR (1):</dt>
         <dd>This is a generic error, and should only be used if a more specific error is not available. <span class="comment" id="rfc.comment.10">[<a href="#rfc.comment.10" class="smpl">rfc.comment.10</a>: ED: Doesn't sound so generic. Someone committed a protocol violation. Might need to change the name.]</span> 
         </dd>
         <dt>INVALID_STREAM (2):</dt>
         <dd>This is returned when a frame is received for a stream which is not active.</dd>
         <dt>REFUSED_STREAM (3):</dt>
         <dd>Indicates that the stream was refused before any processing has been done on the stream.</dd>
         <dt>CANCEL (5):</dt>
         <dd>Used by the creator of a stream to indicate that the stream is no longer needed.</dd>
         <dt>INTERNAL_ERROR (6):</dt>
         <dd>This is a generic error which can be used when the implementation has internally failed, not due to anything in the protocol.</dd>
         <dt>FLOW_CONTROL_ERROR (7):</dt>
         <dd>The endpoint detected that its peer violated the flow control protocol.</dd>
         <dt>STREAM_ALREADY_CLOSED (9):</dt>
         <dd>The endpoint received a frame after a stream was half closed.</dd>
         <dt>FRAME_TOO_LARGE (11):</dt>
         <dd>The endpoint received a frame that was larger than the maximum size that it supports.</dd>
      </dl>
      <p id="rfc.section.3.7.3.p.6">After receiving a RST_STREAM on a stream, the recipient must not send additional frames for that stream, and the stream moves
         into the closed state.
      </p>
      <h3 id="rfc.section.3.7.4"><a href="#rfc.section.3.7.4">3.7.4</a>&nbsp;<a id="PUSH_PROMISE" href="#PUSH_PROMISE">PUSH_PROMISE</a></h3>
      <p id="rfc.section.3.7.4.p.1">The PUSH_PROMISE frame (type=5) allows the sender to signal a promise to create a stream and serve the referenced resource.
         Minimal data allowing the receiver to understand which resource(s) are to be pushed are to be included.
      </p>
      <div id="rfc.figure.4"></div> <pre class="inline"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|X|              Associated-Stream-ID (31)                      |
+-+-------------------------------------------------------------+
|X|                Promised-Stream-ID (31)                      |
+-+-------------------------------------------------------------+
|                    Header Block (*)                         ...
+---------------------------------------------------------------+
</pre> <p class="figure">Figure 4: SETTINGS ID/Value Pair</p>
      <p id="rfc.section.3.7.4.p.3"><span class="comment" id="rfc.comment.11">[<a href="#rfc.comment.11" class="smpl">rfc.comment.11</a>: Should this paragraph be moved or removed?]</span> Flags: Flags related to this frame. Valid flags are: 
      </p>
      <ul class="empty">
         <li>0x01 = FLAG_FIN - marks this frame as the last frame to be transmitted on this stream and puts the sender in the half-closed (<a href="#StreamHalfClose" title="Stream half-close">Section&nbsp;3.4.5</a>) state.
         </li>
      </ul>
      <p id="rfc.section.3.7.4.p.4">Associated-To-Stream-ID: The 31-bit identifier for a stream which this stream is associated to. If this stream is independent
         of all other streams, it should be 0.
      </p>
      <p id="rfc.section.3.7.4.p.5">Promised-Stream-ID: The 31-bit identifier indicating the stream-id on which the resource will be pushed. If multiple headers
         are indicated within the Header Block, each subsequent resource as indicated in the Header Block will increment the Promised-Stream-Id
         by two. The Promised-Stream-ID is subject to the same rules as any other stream-id-- when defined and transmitted, the Promised-Stream-ID
         MUST be part of a monotonically increasing sequence of stream-ids. There is no requirement that the streams referred to by
         the this frame are created in the order referenced.
      </p>
      <p id="rfc.section.3.7.4.p.6">Header Block: A set of name/value pairs carried as part of the PUSH_PROMISE. see Header Block (<a href="#HeaderBlock" title="Header Block">Section&nbsp;3.7.10</a>).
      </p>
      <p id="rfc.section.3.7.4.p.7">If an endpoint receives a PUSH_PROMISE which is larger than the implementation supports, it MAY send a RST_STREAM with error
         code FRAME_TOO_LARGE. All implementations MUST support the minimum size limits defined in . (<a href="#FrameSize" title="Frame Processing">Section&nbsp;3.3.2</a>).
      </p>
      <h3 id="rfc.section.3.7.5"><a href="#rfc.section.3.7.5">3.7.5</a>&nbsp;<a id="SETTINGS" href="#SETTINGS">SETTINGS</a></h3>
      <p id="rfc.section.3.7.5.p.1">A SETTINGS frame (type=4) contains a set of id/value pairs for communicating configuration data about how the two endpoints
         may communicate. SETTINGS frames MUST be sent at the start of a session, but they can be sent at any other time by either
         endpoint. Settings are declarative, not negotiated, each peer indicates their own configuration.
      </p>
      <p id="rfc.section.3.7.5.p.2"> <span class="comment" id="rfc.comment.12">[<a href="#rfc.comment.12" class="smpl">rfc.comment.12</a>: Note that persistence of settings is under discussion in the WG and might be removed in a future version of this document.]</span> 
      </p>
      <p id="rfc.section.3.7.5.p.3">When the server is the sender, the sender can request that configuration data be persisted by the client across HTTP/2.0 sessions
         and returned to the server in future communications.
      </p>
      <p id="rfc.section.3.7.5.p.4">Clients persist settings on a per origin basis (see <a href="#RFC6454" id="rfc.xref.RFC6454.1"><cite title="The Web Origin Concept">[RFC6454]</cite></a> for a definition of web origins). That is, when a client connects to a server, and the server persists settings within the
         client, the client SHOULD return the persisted settings on future connections to the same origin AND IP address and TCP port.
         Clients MUST NOT request servers to use the persistence features of the SETTINGS frames, and servers MUST ignore persistence
         related flags sent by a client.
      </p>
      <p id="rfc.section.3.7.5.p.5">Valid flags for the SETTINGS frame are: </p>
      <dl>
         <dt>CLEAR_PERSISTED:</dt>
         <dd>Bit 1 (the least significant bit) being set indicates a request to clear any previously persisted settings before processing
            the settings. Clients MUST NOT set this flag.
         </dd>
      </dl>
      <p id="rfc.section.3.7.5.p.6">SETTINGS frames always apply to a session, never a single stream. The identifier field in the frame header carries a count
         of the number of settings contained in the payload. <span class="comment" id="rfc.comment.13">[<a href="#rfc.comment.13" class="smpl">rfc.comment.13</a>: ED: this seems totally unnecessary.]</span> 
      </p>
      <div id="rfc.figure.5"></div> <pre class="inline"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|SettingFlags(8)|             Setting Identifier (24)           |
+---------------+-----------------------------------------------+
|                        Value (32)                             |
+---------------------------------------------------------------+
</pre> <p class="figure">Figure 5: SETTINGS ID/Value Pair</p>
      <p id="rfc.section.3.7.5.p.8">The payload of a SETTINGS frame contains zero or more settings. Each setting is comprised of the following </p>
      <dl>
         <dt>Settings Flags:</dt>
         <dd>An 8-bit flags field containing per-setting instructions. The following flags are valid: 
            <dl>
               <dt>PERSIST_VALUE (0x1):</dt>
               <dd>Bit 1 (the least significant bit) being set indicates a request from the server to the client to persist this setting. A client
                  MUST NOT set this flag.
               </dd>
               <dt>PERSISTED (0x2):</dt>
               <dd>Bit 2 being set indicates that this setting is a persisted setting being returned by the client to the server. This also indicates
                  that this setting is not a client setting, but a value previously set by the server. A server MUST NOT set this flag.
               </dd>
            </dl> All other settings flags are reserved.
         </dd>
         <dt>Setting Identifier:</dt>
         <dd>A 24-bit field that identifies the setting.</dd>
         <dt>Value:</dt>
         <dd>A 32-bit value for the setting.</dd>
      </dl>
      <p id="rfc.section.3.7.5.p.9">The following settings are defined: </p>
      <dl>
         <dt>SETTINGS_UPLOAD_BANDWIDTH (1):</dt>
         <dd>
            <p>allows the sender to send its expected upload bandwidth on this channel. This number is an estimate. The value should be the
               integral number of kilobytes per second that the sender predicts as an expected maximum upload channel capacity.
            </p>
         </dd>
         <dt>SETTINGS_DOWNLOAD_BANDWIDTH (2):</dt>
         <dd>
            <p>allows the sender to send its expected download bandwidth on this channel. This number is an estimate. The value should be
               the integral number of kilobytes per second that the sender predicts as an expected maximum download channel capacity.
            </p>
         </dd>
         <dt>SETTINGS_ROUND_TRIP_TIME (3):</dt>
         <dd>
            <p>allows the sender to send its expected round-trip-time on this channel. The round trip time is defined as the minimum amount
               of time to send a control frame from this client to the remote and receive a response. The value is represented in milliseconds.
            </p>
         </dd>
         <dt>SETTINGS_MAX_CONCURRENT_STREAMS (4):</dt>
         <dd>
            <p>allows the sender to inform the remote endpoint the maximum number of concurrent streams which it will allow. This limit is
               directional: it applies to the number of streams that the sender permits the receiver to create. By default there is no limit.
               For implementers it is recommended that this value be no smaller than 100, so as to not unnecessarily limit parallelism.
            </p>
         </dd>
         <dt>SETTINGS_CURRENT_CWND (5):</dt>
         <dd>
            <p>allows the sender to inform the remote endpoint of the current TCP CWND value.</p>
         </dd>
         <dt>SETTINGS_DOWNLOAD_RETRANS_RATE (6):</dt>
         <dd>
            <p>allows the sender to inform the remote endpoint the retransmission rate (bytes retransmitted / total bytes transmitted).</p>
         </dd>
         <dt>SETTINGS_INITIAL_WINDOW_SIZE (7):</dt>
         <dd>
            <p>allows the sender to inform the remote endpoint the initial window size (in bytes) for new streams.</p>
         </dd>
         <dt>SETTINGS_FLOW_CONTROL_OPTIONS (10):</dt>
         <dd>
            <p>This setting allows an endpoint to indicate that streams directed to them will not be subject to flow control. The least significant
               bit (0x1) is set to indicate that new streams are not flow controlled. Bit 2 (0x2) is set to indicate that the session is
               not flow controlled. All other bits are reserved.
            </p>
            <p>This setting applies to all streams, including existing streams.</p>
            <p>These bits cannot be cleared once set, see <a href="#EndFlowControl" title="Ending Flow Control">Section&nbsp;3.7.9.4</a>.
            </p>
         </dd>
      </dl>
      <p id="rfc.section.3.7.5.p.10">The message is intentionally extensible for future information which may improve client-server communications. The sender
         does not need to send every type of ID/value. It must only send those for which it has accurate values to convey. When multiple
         ID/value pairs are sent, they should be sent in order of lowest id to highest id. A single SETTINGS frame MUST not contain
         multiple values for the same ID. If the recipient of a SETTINGS frame discovers multiple values for the same ID, it MUST ignore
         all values except the first one.
      </p>
      <p id="rfc.section.3.7.5.p.11">A server may send multiple SETTINGS frames containing different ID/Value pairs. When the same ID/Value is sent twice, the
         most recent value overrides any previously sent values. If the server sends IDs 1, 2, and 3 with the FLAG_SETTINGS_PERSIST_VALUE
         in a first SETTINGS frame, and then sends IDs 4 and 5 with the FLAG_SETTINGS_PERSIST_VALUE, when the client returns the persisted
         state on its next SETTINGS frame, it SHOULD send all 5 settings (1, 2, 3, 4, and 5 in this example) to the server.
      </p>
      <h3 id="rfc.section.3.7.6"><a href="#rfc.section.3.7.6">3.7.6</a>&nbsp;<a id="PING" href="#PING">PING</a></h3>
      <p id="rfc.section.3.7.6.p.1">The PING frame (type=6) is a mechanism for measuring a minimal round-trip time from the sender. PING frames can be sent from
         the client or the server.
      </p>
      <p id="rfc.section.3.7.6.p.2">Recipients of a PING frame send an identical frame to the sender as soon as possible. PING should take highest priority if
         there is other data waiting to be sent.
      </p>
      <p id="rfc.section.3.7.6.p.3">The PING frame does not define any valid flags.</p>
      <p id="rfc.section.3.7.6.p.4">A client MUST populate the identifier field in the frame header of a PING frame with an odd numbered value. A server MUST
         populate the identifier field in the frame header of a PING frame with an even numbered value. A client MUST reply to PING
         frames with even numbered identifiers; a server MUST only reply to PING frames with odd numbered identifiers. These measures
         ensure that accidental looping of PINGs cannot occur.
      </p>
      <p id="rfc.section.3.7.6.p.5">The payload of a PING frame contains any value. A PING response MUST contain the contents of the PING request.</p>
      <h3 id="rfc.section.3.7.7"><a href="#rfc.section.3.7.7">3.7.7</a>&nbsp;<a id="GOAWAY" href="#GOAWAY">GOAWAY</a></h3>
      <p id="rfc.section.3.7.7.p.1">The GOAWAY frame (type=7) informs the remote side of the connection to stop creating streams on this session. It can be sent
         from the client or the server. Once sent, the sender will ignore frames sent on new streams for the remainder of the session.
         Recipients of a GOAWAY frame MUST NOT open additional streams on the session, although a new session can be established for
         new streams. The purpose of this message is to allow an endpoint to gracefully stop accepting new streams (perhaps for a reboot
         or maintenance), while still finishing processing of previously established streams.
      </p>
      <p id="rfc.section.3.7.7.p.2">There is an inherent race condition between an endpoint starting new streams and the remote sending a GOAWAY message. To deal
         with this case, the GOAWAY contains a last-stream-id indicating the stream identifier of the last stream which was created
         on the sending endpoint in this session. If the receiver of the GOAWAY used streams that are newer than the indicated last-stream-id,
         they were not processed by the server and the receiver may treat the stream as though it had never been created at all (hence
         the receiver may want to re-create the stream later on a new session).
      </p>
      <p id="rfc.section.3.7.7.p.3">Endpoints should always send a GOAWAY message before closing a connection so that the remote can know whether a stream has
         been partially processed or not. (For example, if an HTTP client sends a POST at the same time that a server closes a connection,
         the client cannot know if the server started to process that POST request if the server does not send a GOAWAY frame to indicate
         where it stopped working).
      </p>
      <p id="rfc.section.3.7.7.p.4">After sending a GOAWAY message, the sender can ignore frames for new streams.</p>
      <p id="rfc.section.3.7.7.p.5"> <span class="comment" id="rfc.comment.14">[<a href="#rfc.comment.14" class="smpl">rfc.comment.14</a>: Issue: session state that is established by those "ignored" messages cannot be ignored without the state in the two peers
            becoming unsynchronized.]</span> 
      </p>
      <p id="rfc.section.3.7.7.p.6">The GOAWAY frame does not define any valid flags.</p>
      <p id="rfc.section.3.7.7.p.7">The GOAWAY message applies to the session, not a specific stream. The identifier field of the frame header contains the identifier
         for the last stream that the sender of the GOAWAY frame is prepared to provide replies to. If no streams were replied to,
         this value MUST be 0.
      </p>
      <p id="rfc.section.3.7.7.p.8">The payload of a GOAWAY frame contains a 32-bit error code that contains the reason for closing the session: </p>
      <dl>
         <dt>OK (0):</dt>
         <dd>The session is closing normally.</dd>
         <dt>PROTOCOL_ERROR (1):</dt>
         <dd>This is a generic error, and should only be used if a more specific error is not available. <span class="comment" id="rfc.comment.15">[<a href="#rfc.comment.15" class="smpl">rfc.comment.15</a>: ED: bad name]</span> 
         </dd>
         <dt>INTERNAL_ERROR (2):</dt>
         <dd>The implementation has internally failed, not due to anything in the protocol.</dd>
         <dt>FLOW_CONTROL_ERROR (7):</dt>
         <dd>The endpoint detected that its peer violated the flow control protocol.</dd>
      </dl>
      <h3 id="rfc.section.3.7.8"><a href="#rfc.section.3.7.8">3.7.8</a>&nbsp;<a id="HEADERS" href="#HEADERS">HEADERS</a></h3>
      <p id="rfc.section.3.7.8.p.1">The HEADERS frame (type=8) augments a stream with additional headers. It may be optionally sent on an existing stream at any
         time. Specific application of the headers in this frame is application-dependent.
      </p>
      <p id="rfc.section.3.7.8.p.2">Valid flags for the HEADERS frame are: </p>
      <dl>
         <dt>FINAL (0x1):</dt>
         <dd>Bit 1 (the least significant bit) being set indicates that this is the last frame to be transmitted on this stream. Setting
            this bit puts the sender in the half-closed (<a href="#StreamHalfClose" title="Stream half-close">Section&nbsp;3.4.5</a>) state.
         </dd>
      </dl>
      <p id="rfc.section.3.7.8.p.3">The identifier field in the HEADERS frame header MUST contain a stream identifier for an open stream.</p>
      <p id="rfc.section.3.7.8.p.4">The body of a HEADERS frame contains a Headers Block (<a href="#HeaderBlock" title="Header Block">Section&nbsp;3.7.10</a>).
      </p>
      <h3 id="rfc.section.3.7.9"><a href="#rfc.section.3.7.9">3.7.9</a>&nbsp;<a id="WINDOW_UPDATE" href="#WINDOW_UPDATE">WINDOW_UPDATE</a></h3>
      <p id="rfc.section.3.7.9.p.1">The WINDOW_UPDATE frame (type=9) is used to implement flow control in HTTP/2.0.</p>
      <p id="rfc.section.3.7.9.p.2">Flow control in HTTP/2.0 operates at two levels: on each individual stream and on the entire session.</p>
      <p id="rfc.section.3.7.9.p.3">Flow control in HTTP/2.0 is hop by hop, that is, only between the two endpoints of a HTTP/2.0 connection. Intermediaries do
         not forward WINDOW_UPDATE messages between dependent sessions. However, throttling of data transfer by any recipient can indirectly
         cause the propagation of flow control information toward the original sender.
      </p>
      <p id="rfc.section.3.7.9.p.4">Flow control only applies to frames that are identified as being subject to flow control. Of the frames defined in this document,
         only data frames are subject to flow control. Receivers MUST either buffer or process all other frames, terminate the corresponding
         stream, or terminate the session. The stream or session is terminated with a FLOW_CONTROL_ERROR code.
      </p>
      <p id="rfc.section.3.7.9.p.5">Valid flags for the WINDOW_UPDATE frame are: </p>
      <dl>
         <dt>END_FLOW_CONTROL (0x2):</dt>
         <dd>Bit 2 being set indicates that flow control for the identified stream or session is ended and subsequent frames do not need
            to be flow controlled.
         </dd>
      </dl>
      <p id="rfc.section.3.7.9.p.6">The identifier field in the WINDOW_UPDATE frame header MUST contain a stream identifier for an open stream, or the value 0.
         A zero value indicates that the WINDOW_UPDATE applies to the session level flow control window.
      </p>
      <p id="rfc.section.3.7.9.p.7">The payload of a WINDOW_UPDATE frame contains a 32-bit value. This value is the additional number of bytes that the sender
         can transmit in addition to the existing flow control window. The legal range for this field is 1 to 2<sup>31</sup> - 1 (0x7fffffff) bytes; the most significant bit of this value is reserved.
      </p>
      <h4 id="rfc.section.3.7.9.1"><a href="#rfc.section.3.7.9.1">3.7.9.1</a>&nbsp;The Flow Control Window
      </h4>
      <p id="rfc.section.3.7.9.1.p.1">Flow control in HTTP/2.0 is implemented by a flow control window kept by the sender of each stream. The flow control window
         is a simple integer value that indicates how many bytes of data the sender is permitted to transmit. The flow control window
         size is a measure of the buffering capability of the recipient.
      </p>
      <p id="rfc.section.3.7.9.1.p.2">Two flow control windows apply to the sending of every message: the stream flow control window and the session flow control
         window. The sender MUST NOT send a flow controlled frame with a length that exceeds the space available in either of the flow
         control windows advertised by the receiver. Frames with zero length that also end a stream (for example, a data frame with
         the FINAL flag set) MAY be sent if there is no available space in either flow control window.
      </p>
      <p id="rfc.section.3.7.9.1.p.3">For flow control calculations, the 8 byte frame header is not counted.</p>
      <p id="rfc.section.3.7.9.1.p.4">After sending a flow controlled frame, the sender reduces the space available in both windows by the length of the transmitted
         frame.
      </p>
      <p id="rfc.section.3.7.9.1.p.5">The receiver of a message sends a WINDOW_UPDATE frame as it consumes data and frees up space in flow control windows. Separate
         WINDOW_UPDATE messages are sent for the stream and session level flow control windows.
      </p>
      <p id="rfc.section.3.7.9.1.p.6">A sender MUST NOT allow a flow control window to exceed 2<sup>31</sup> - 1 bytes. If a sender receives a WINDOW_UPDATE that causes a flow control window to exceed this maximum it MUST terminate
         either the stream or the session, as appropriate. For streams, the sender sends a RST_STREAM with the error code of FLOW_CONTROL_ERROR
         code; for the session, a GOAWAY message with a FLOW_CONTROL_ERROR code.
      </p>
      <p id="rfc.section.3.7.9.1.p.7">Flow controlled frames from the sender and WINDOW_UPDATE frames from the receiver are completely asynchronous with respect
         to each other. This property allows a receiver to aggressively update the window size kept by the sender to prevent streams
         from stalling.
      </p>
      <h4 id="rfc.section.3.7.9.2"><a href="#rfc.section.3.7.9.2">3.7.9.2</a>&nbsp;Initial Flow Control Window Size
      </h4>
      <p id="rfc.section.3.7.9.2.p.1">When a HTTP/2.0 connection is first established, new streams are created with an initial flow control window size of 65535
         bytes. The session flow control window is 65536 bytes. Both endpoints can adjust the initial window size for new streams by
         including a value for SETTINGS_INITIAL_WINDOW_SIZE in the SETTINGS frame that forms part of the session header.
      </p>
      <p id="rfc.section.3.7.9.2.p.2">Prior to receiving a SETTINGS frame that sets a value for SETTINGS_INITIAL_WINDOW_SIZE, a client can only use the default
         initial window size when sending flow controlled frames. Similarly, the session flow control window is set to the default
         initial window size until a WINDOW_UPDATE message is received.
      </p>
      <p id="rfc.section.3.7.9.2.p.3">A SETTINGS frame can alter the initial flow control window size for all current streams. When the value of SETTINGS_INITIAL_WINDOW_SIZE
         changes, a receiver MUST adjust the size of all flow control windows that it maintains by the difference between the new value
         and the old value.
      </p>
      <p id="rfc.section.3.7.9.2.p.4">A change to SETTINGS_INITIAL_WINDOW_SIZE could cause the available space in a flow control window to become negative. A sender
         MUST track the negative flow control window and not send new flow controlled frames until it receives WINDOW_UPDATE messages
         that cause the flow control window to become positive.
      </p>
      <p id="rfc.section.3.7.9.2.p.5">For example, if the server sets the initial window size to be 16KB, and the client sends 64KB immediately on connection establishment,
         the client will recalculate the available flow control window to be -48KB on receipt of the SETTINGS frame. The client retains
         a negative flow control window until WINDOW_UPDATE frames restore the window to being positive, after which the client can
         resume sending.
      </p>
      <h4 id="rfc.section.3.7.9.3"><a href="#rfc.section.3.7.9.3">3.7.9.3</a>&nbsp;Reducing the Stream Window Size
      </h4>
      <p id="rfc.section.3.7.9.3.p.1">A receiver that wishes to use a smaller flow control window than the current size sends a new SETTINGS frame. However, the
         receiver MUST be prepared to receive data that exceeds this window size, since the sender might send data that exceeds the
         lower limit prior to processing the SETTINGS frame.
      </p>
      <p id="rfc.section.3.7.9.3.p.2">A receiver has two options for handling streams that exceed flow control limits: </p>
      <ol>
         <li>The receiver can immediately send RST_STREAM with FLOW_CONTROL_ERROR error code for the affected streams.</li>
         <li>The receiver can accept the streams and tolerate the resulting head of line blocking, sending WINDOW_UPDATE messages as it
            consumes data.
         </li>
      </ol>
      <p> If a receiver decides to accept streams, both sides must recompute the available flow control window based on the initial
         window size sent in the SETTINGS.
      </p>
      <h4 id="rfc.section.3.7.9.4"><a href="#rfc.section.3.7.9.4">3.7.9.4</a>&nbsp;<a id="EndFlowControl" href="#EndFlowControl">Ending Flow Control</a></h4>
      <p id="rfc.section.3.7.9.4.p.1">After a recipient reads in a frame that marks the end of a stream (for example, a data stream with a FINAL flag set), it ceases
         transmission of WINDOW_UPDATE frames. A sender is not required to maintain the available flow control window for streams that
         it is no longer sending on.
      </p>
      <p id="rfc.section.3.7.9.4.p.2">Flow control can be disabled for all streams or the session using the SETTINGS_FLOW_CONTROL_OPTIONS setting. An implementation
         that does not wish to perform flow control can use this in the initial SETTINGS exchange.
      </p>
      <p id="rfc.section.3.7.9.4.p.3">Flow control can be disabled for an individual stream or the overall session by sending a WINDOW_UPDATE with the END_FLOW_CONTROL
         flag set. The payload of a WINDOW_UPDATE frame that has the END_FLOW_CONTROL flag set is ignored.
      </p>
      <p id="rfc.section.3.7.9.4.p.4">Flow control cannot be enabled again once disabled. Any attempt to re-enable flow control - by sending a WINDOW_UPDATE or
         by clearing the bits on the SETTINGS_FLOW_CONTROL_OPTIONS setting - MUST be rejected with a FLOW_CONTROL_ERROR error code.
      </p>
      <h3 id="rfc.section.3.7.10"><a href="#rfc.section.3.7.10">3.7.10</a>&nbsp;<a id="HeaderBlock" href="#HeaderBlock">Header Block</a></h3>
      <p id="rfc.section.3.7.10.p.1">The Header Block is found in the HEADERS and HEADERS+PRIORITY frames. Headers consist of a set of name-value pairs. Headers
         are compressed using TBD.
      </p>
      <p id="rfc.section.3.7.10.p.2">Compression of headers is a work in progress, as is the format of this block.</p>
      <h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a>&nbsp;<a id="HTTPLayer" href="#HTTPLayer">HTTP Message Exchanges</a></h1>
      <p id="rfc.section.4.p.1">HTTP/2.0 is intended to be as compatible as possible with current web-based applications. This means that, from the perspective
         of the server business logic or application API, the features of HTTP are unchanged. To achieve this, all of the application
         request and response header semantics are preserved, although the syntax of conveying those semantics has changed. Thus, the
         rules from HTTP/1.1 (<a href="#HTTP-p1" id="rfc.xref.HTTP-p1.4"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[HTTP-p1]</cite></a>, <a href="#HTTP-p2" id="rfc.xref.HTTP-p2.1"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[HTTP-p2]</cite></a>, <a href="#HTTP-p4" id="rfc.xref.HTTP-p4.1"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests">[HTTP-p4]</cite></a>, <a href="#HTTP-p5" id="rfc.xref.HTTP-p5.1"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Range Requests">[HTTP-p5]</cite></a>, <a href="#HTTP-p6" id="rfc.xref.HTTP-p6.1"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[HTTP-p6]</cite></a>, and <a href="#HTTP-p7" id="rfc.xref.HTTP-p7.1"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Authentication">[HTTP-p7]</cite></a>) apply with the changes in the sections below.
      </p>
      <h2 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1</a>&nbsp;Connection Management
      </h2>
      <p id="rfc.section.4.1.p.1">Clients SHOULD NOT open more than one HTTP/2.0 session to a given origin (<a href="#RFC6454" id="rfc.xref.RFC6454.2"><cite title="The Web Origin Concept">[RFC6454]</cite></a>) concurrently.
      </p>
      <p id="rfc.section.4.1.p.2">Note that it is possible for one HTTP/2.0 session to be finishing (e.g. a GOAWAY message has been sent, but not all streams
         have finished), while another HTTP/2.0 session is starting.
      </p>
      <h3 id="rfc.section.4.1.1"><a href="#rfc.section.4.1.1">4.1.1</a>&nbsp;Use of GOAWAY
      </h3>
      <p id="rfc.section.4.1.1.p.1">HTTP/2.0 provides a GOAWAY message which can be used when closing a connection from either the client or server. Without a
         server GOAWAY message, HTTP has a race condition where the client sends a request just as the server is closing the connection,
         and the client cannot know if the server received the stream or not. By using the last-stream-id in the GOAWAY, servers can
         indicate to the client if a request was processed or not.
      </p>
      <p id="rfc.section.4.1.1.p.2">Note that some servers will choose to send the GOAWAY and immediately terminate the connection without waiting for active
         streams to finish. The client will be able to determine this because HTTP/2.0 streams are deterministically closed. This abrupt
         termination will force the client to heuristically decide whether to retry the pending requests. Clients always need to be
         capable of dealing with this case because they must deal with accidental connection termination cases, which are the same
         as the server never having sent a GOAWAY.
      </p>
      <p id="rfc.section.4.1.1.p.3">More sophisticated servers will use GOAWAY to implement a graceful teardown. They will send the GOAWAY and provide some time
         for the active streams to finish before terminating the connection.
      </p>
      <p id="rfc.section.4.1.1.p.4">If a HTTP/2.0 client closes the connection, it should also send a GOAWAY message. This allows the server to know if any server-push
         streams were received by the client.
      </p>
      <p id="rfc.section.4.1.1.p.5">If the endpoint closing the connection has not received frames on any stream, the GOAWAY will contain a last-stream-id of
         0.
      </p>
      <h2 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2</a>&nbsp;HTTP Request/Response
      </h2>
      <h3 id="rfc.section.4.2.1"><a href="#rfc.section.4.2.1">4.2.1</a>&nbsp;HTTP Header Fields and HTTP/2.0 Headers
      </h3>
      <p id="rfc.section.4.2.1.p.1">At the application level, HTTP uses name-value pairs in its header fields. Because HTTP/2.0 merges the existing HTTP header
         fields with HTTP/2.0 headers, there is a possibility that some HTTP applications already use a particular header field name.
         To avoid any conflicts, all headers introduced for layering HTTP over HTTP/2.0 are prefixed with ":". ":" is not a valid sequence
         in HTTP/1.* header field naming, preventing any possible conflict.
      </p>
      <h3 id="rfc.section.4.2.2"><a href="#rfc.section.4.2.2">4.2.2</a>&nbsp;Request
      </h3>
      <p id="rfc.section.4.2.2.p.1">The client initiates a request by sending a HEADERS+PRIORITY frame. For requests that do not contain a body, the frame MUST
         set the FINAL flag, indicating that the client intends to send no further data on this stream. For requests that do contain
         a body, the HEADERS+PRIORITY frame does not contain the FINAL flag, and the body follows as a series of DATA frames. The last
         DATA frame sets the FINAL flag to indicate the end of the body.
      </p>
      <p id="rfc.section.4.2.2.p.2">The headers included in the HEADERS+PRIORITY frame contain all of the HTTP header fields that are associated with an HTTP
         request. The header block in HTTP/2.0 is mostly unchanged from today's HTTP header block, with the following differences: 
      </p>
      <ul class="empty">
         <li>The following fields that are carried in the request line in HTTP/1.1 (<a href="#HTTP-p1" id="rfc.xref.HTTP-p1.5"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[HTTP-p1]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/22/p1-messaging.html#request.line" title="Request Line">Section 3.1.1</a>) are defined as special-valued name-value pairs: 
            <ul class="empty">
               <li>":method" - the HTTP method for this request (e.g. "GET", "POST", "HEAD", etc) (<a href="#HTTP-p2" id="rfc.xref.HTTP-p2.2"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[HTTP-p2]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/22/p2-semantics.html#methods" title="Request Methods">Section 4</a>)
               </li>
               <li>":path" - the request-target for this URI with "/" prefixed (see <a href="#HTTP-p1" id="rfc.xref.HTTP-p1.6"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[HTTP-p1]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/22/p1-messaging.html#request.line" title="Request Line">Section 3.1.1</a>). For example, for "http://www.google.com/search?q=dogs" the path would be "/search?q=dogs". <span class="comment" id="rfc.comment.16">[<a href="#rfc.comment.16" class="smpl">rfc.comment.16</a>: what forms of the HTTPbis request-target are allowed here?]</span> 
               </li>
            </ul> These header fields MUST be present in HTTP requests.
         </li>
         <li>In addition, the following two name-value pairs MUST be present in every request: 
            <ul class="empty">
               <li>":host" - the host and options port portions (see <a href="#RFC3986" id="rfc.xref.RFC3986.1"><cite title="Uniform Resource Identifier (URI): Generic Syntax">[RFC3986]</cite></a>, <a href="http://tools.ietf.org/html/rfc3986#section-3.2">Section 3.2</a>) of the URI for this request (e.g. "www.google.com:1234"). This header field is the same as the HTTP 'Host' header field
                  (<a href="#HTTP-p1" id="rfc.xref.HTTP-p1.7"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[HTTP-p1]</cite></a>, <a href="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/22/p1-messaging.html#header.host" title="Host">Section 5.4</a>).
               </li>
               <li>":scheme" - the scheme portion of the URI for this request (e.g. "https")</li>
            </ul> 
         </li>
         <li>All header field names starting with ":" (whether defined in this document or future extensions to this document) MUST appear
            before any other header fields.
         </li>
         <li>Header field names MUST be all lowercase.</li>
         <li>The Connection, Host, Keep-Alive, Proxy-Connection, and Transfer-Encoding header fields are not valid and MUST not be sent.</li>
         <li>User-agents MUST support gzip compression. Regardless of the Accept-Encoding sent by the user-agent, the server may always
            send content encoded with gzip or deflate encoding.
         </li>
         <li>If a server receives a request where the sum of the data frame payload lengths does not equal the size of the Content-Length
            header field, the server MUST return a 400 (Bad Request) error.
         </li>
         <li>POST-specific changes: 
            <ul class="empty">
               <li>Although POSTs are inherently chunked, POST requests SHOULD also be accompanied by a Content-Length header field. There are
                  two reasons for this: First, it assists with upload progress meters for an improved user experience. More importantly, failure
                  to send a Content-Length header field is incompatible with many existing HTTP server implementations. Existing user agents
                  do not omit the Content-Length header field, and server implementations have come to depend upon this.
               </li>
            </ul> 
         </li>
      </ul>
      <p id="rfc.section.4.2.2.p.3">The user-agent is free to prioritize requests as it sees fit. If the user-agent cannot make progress without receiving a resource,
         it should attempt to raise the priority of that resource. Resources such as images, SHOULD generally use the lowest priority.
      </p>
      <p id="rfc.section.4.2.2.p.4">If a client sends a HEADERS+PRIORITY frame that omits a mandatory header, the server MUST reply with a HTTP 400 Bad Request
         reply.
      </p>
      <h3 id="rfc.section.4.2.3"><a href="#rfc.section.4.2.3">4.2.3</a>&nbsp;Response
      </h3>
      <p id="rfc.section.4.2.3.p.1">The server responds to a client request with a HEADERS frame. Symmetric to the client's upload stream, server will send any
         response body in a series of DATA frames. The last data frame will contain the FINAL flag to indicate the end of the stream
         and the end of the response. A response that contains no body (such as a 204 or 304 response) consists only of a HEADERS frame
         that contains the FINAL flag to indicate no further data will be sent on the stream.
      </p>
      <p id="rfc.section.4.2.3.p.2"> </p>
      <ul class="empty">
         <li>The response status line is unfolded into name-value pairs like other HTTP header fields and must be present: 
            <ul class="empty">
               <li>":status" - The HTTP response status code (e.g. "200" or "200 OK")</li>
            </ul> 
         </li>
         <li>All header field names starting with ":" (whether defined in this document or future extensions to this document) MUST appear
            before any other header fields.
         </li>
         <li>All header field names MUST be all lowercase.</li>
         <li>The Connection, Keep-Alive, Proxy-Connection, and Transfer-Encoding header fields are not valid and MUST not be sent.</li>
         <li>Responses MAY be accompanied by a Content-Length header field for advisory purposes. This allows clients to learn the full
            size of an entity prior to receiving all the data frames. This can help in, for example, reporting progress.
         </li>
         <li>If a client receives a response where the sum of the data frame payload length does not equal the size of the Content-Length
            header field, the client MUST ignore the content length header field. <span class="comment" id="rfc.comment.17">[<a href="#rfc.comment.17" class="smpl">rfc.comment.17</a>: Ed: See <a href="https://github.com/http2/http2-spec/issues/46">issue 46</a>.]</span> 
         </li>
      </ul>
      <p id="rfc.section.4.2.3.p.3">If a client receives a response without a status or without a version header, the client must reply with a RST_STREAM frame
         indicating a PROTOCOL ERROR.
      </p>
      <h3 id="rfc.section.4.2.4"><a href="#rfc.section.4.2.4">4.2.4</a>&nbsp;<a id="Authentication" href="#Authentication">Authentication</a></h3>
      <p id="rfc.section.4.2.4.p.1">When a client sends a request to an origin server that requires authentication, the server can reply with a "401 Unauthorized"
         response, and include a WWW-Authenticate challenge header field that defines the authentication scheme to be used. The client
         then retries the request with an Authorization header field appropriate to the specified authentication scheme (<a href="#HTTP-p7" id="rfc.xref.HTTP-p7.2"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Authentication">[HTTP-p7]</cite></a>).
      </p>
      <p id="rfc.section.4.2.4.p.2">There are four options for proxy authentication, Basic, Digest, NTLM and Negotiate (SPNEGO). The first two options were defined
         in <a href="#RFC2617" id="rfc.xref.RFC2617.1"><cite title="HTTP Authentication: Basic and Digest Access Authentication">[RFC2617]</cite></a>, and are stateless. The second two options were developed by Microsoft and specified in <a href="#RFC4559" id="rfc.xref.RFC4559.1"><cite title="SPNEGO-based Kerberos and NTLM HTTP Authentication in Microsoft Windows">[RFC4559]</cite></a>, and are stateful; otherwise known as multi-round authentication, or connection authentication.
      </p>
      <h4 id="rfc.section.4.2.4.1"><a href="#rfc.section.4.2.4.1">4.2.4.1</a>&nbsp;Stateless Authentication
      </h4>
      <p id="rfc.section.4.2.4.1.p.1">Stateless Authentication over HTTP/2.0 is identical to how it is performed over HTTP/1.1. If multiple HTTP/2.0 streams are
         concurrently sent to a single server, each will authenticate independently, similar to how two HTTP connections would independently
         authenticate to a proxy server.
      </p>
      <h4 id="rfc.section.4.2.4.2"><a href="#rfc.section.4.2.4.2">4.2.4.2</a>&nbsp;Stateful Authentication
      </h4>
      <p id="rfc.section.4.2.4.2.p.1">Unfortunately, the stateful authentication mechanisms were implemented and defined in a such a way that directly violates
         RFC2617 - they do not include a "realm" as part of the request. This is problematic in HTTP/2.0 because it makes it impossible
         for a client to disambiguate two concurrent server authentication challenges.
      </p>
      <p id="rfc.section.4.2.4.2.p.2">To deal with this case, HTTP/2.0 servers using Stateful Authentication MUST implement one of two changes: </p>
      <ul class="empty">
         <li>Servers can add a "realm=&lt;desired realm&gt;" header so that the two authentication requests can be disambiguated and run concurrently.
            Unfortunately, given how these mechanisms work, this is probably not practical.
         </li>
         <li>Upon sending the first stateful challenge response, the server MUST buffer and defer all further frames which are not part
            of completing the challenge until the challenge has completed. Completing the authentication challenge may take multiple round
            trips. Once the client receives a "401 Authenticate" response for a stateful authentication type, it MUST stop sending new
            requests to the server until the authentication has completed by receiving a non-401 response on at least one stream.
         </li>
      </ul>
      <h2 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3</a>&nbsp;Server Push Transactions
      </h2>
      <p id="rfc.section.4.3.p.1">HTTP/2.0 enables a server to send multiple replies to a client for a single request. The rationale for this feature is that
         sometimes a server knows that it will need to send multiple resources in response to a single request. Without server push
         features, the client must first download the primary resource, then discover the secondary resource(s), and request them.
         Pushing of resources avoids the round-trip delay, but also creates a potential race where a server can be pushing content
         which a user-agent is in the process of requesting. The following mechanics attempt to prevent the race condition while enabling
         the performance benefit.
      </p>
      <p id="rfc.section.4.3.p.2">Server push is an optional feature. Server push can be disabled by clients that do not wish to receive pushed resources by
         advertising a SETTINGS_MAX_CONCURRENT_STREAMS SETTING (<a href="#SETTINGS" title="SETTINGS">Section&nbsp;3.7.5</a>) of zero. This prevents servers from creating the streams necessary to push resources.
      </p>
      <p id="rfc.section.4.3.p.3">Browsers receiving a pushed response MUST validate that the server is authorized to push the resource using the same-origin
         policy (<a href="#RFC6454" id="rfc.xref.RFC6454.3"><cite title="The Web Origin Concept">[RFC6454]</cite></a>, <a href="http://tools.ietf.org/html/rfc6454#section-3">Section 3</a>). For example, a HTTP/2.0 connection to <samp>example.com</samp> is generally not permitted to push a response for <samp>www.example.org</samp>.
      </p>
      <p id="rfc.section.4.3.p.4">If the browser accepts a pushed response (e.g. it does not send a RST_STREAM), the browser MUST attempt to cache the pushed
         response in same way that it would cache any other response. This means validating the response headers and inserting into
         the disk cache. <span class="comment" id="rfc.comment.18">[<a href="#rfc.comment.18" class="smpl">rfc.comment.18</a>: ED: browser this, browser that; <a href="https://github.com/http2/http2-spec/issues/27">issue 27</a>]</span> 
      </p>
      <p id="rfc.section.4.3.p.5">Because pushed responses have no request, they have no request headers associated with them. <span class="comment" id="rfc.comment.19">[<a href="#rfc.comment.19" class="smpl">rfc.comment.19</a>: Is the following sentence still correct?]</span> At the framing layer, HTTP/2.0 pushed streams contain an "associated-stream-id" which indicates the requested stream for which
         the pushed stream is related. The pushed stream inherits all of the headers from the associated-stream-id with the exception
         of ":host", ":scheme", and ":path", which are provided as part of the pushed response stream headers. The browser MUST store
         these inherited and implied request headers with the cached resource.
      </p>
      <p id="rfc.section.4.3.p.6">Implementation note: With server push, it is theoretically possible for servers to push unreasonable amounts of content or
         resources to the user-agent. Browsers MUST implement throttles to protect against unreasonable push attacks. <span class="comment" id="rfc.comment.20">[<a href="#rfc.comment.20" class="smpl">rfc.comment.20</a>: Ed: insufficiently specified to implement]</span> 
      </p>
      <h3 id="rfc.section.4.3.1"><a href="#rfc.section.4.3.1">4.3.1</a>&nbsp;Server implementation
      </h3>
      <p id="rfc.section.4.3.1.p.1">When the server intends to push a resource to the user-agent, it opens a new stream by sending a HEADERS+PRIORITY frame. The
         frame MUST include headers for ":scheme", ":host", ":path", which represent the URI for the resource being pushed. Subsequent
         headers may follow in HEADERS frames. The purpose of the association is so that the user-agent can differentiate which request
         induced the pushed stream; without it, if the user-agent had two tabs open to the same page, each pushing unique content under
         a fixed URI, the user-agent would not be able to differentiate the requests.
      </p>
      <p id="rfc.section.4.3.1.p.2">The Associated-To-Stream-ID must be the ID of an existing, open stream. The reason for this restriction is to have a clear
         endpoint for pushed content. If the user-agent requested a resource on stream 11, the server replies on stream 11. It can
         push any number of additional streams to the client before sending a frame with the FINAL flag set on stream 11. However,
         once the originating stream is closed no further push streams may be associated with it. The pushed streams do not need to
         be closed (FINAL flag set) before the originating stream is closed, they only need to be created before the originating stream
         closes.
      </p>
      <p id="rfc.section.4.3.1.p.3">To minimize race conditions with the client, the HEADERS+PRIORITY for the pushed resources MUST be sent prior to sending any
         content which could allow the client to discover the pushed resource and request it.
      </p>
      <p id="rfc.section.4.3.1.p.4">The server MUST only push resources that could have been returned from a GET request.</p>
      <p id="rfc.section.4.3.1.p.5">Note: If the server does not have all of the Response headers available at the time it issues the HEADERS frame for the pushed
         resource, it may later use an additional HEADERS frame to augment the name-value pairs to be associated with the pushed stream.
         All mandatory headers MUST be sent prior to sending any data frames on the stream. The subsequent HEADERS frame(s) MUST NOT
         duplicate header values from previous HEADERS frames.
      </p>
      <h3 id="rfc.section.4.3.2"><a href="#rfc.section.4.3.2">4.3.2</a>&nbsp;Client implementation
      </h3>
      <p id="rfc.section.4.3.2.p.1">When fetching a resource the client has 3 possibilities: </p>
      <ol>
         <li>the resource is not being pushed</li>
         <li>the resource is being pushed, but the data has not yet arrived</li>
         <li>the resource is being pushed, and the data has started to arrive</li>
      </ol>
      <p id="rfc.section.4.3.2.p.2">When a HEADERS+PRIORITY frame that contains an Associated-To-Stream-ID is received, the client MUST NOT issue GET requests
         for the resource in the pushed stream, and instead wait for the pushed stream to arrive.
      </p>
      <p id="rfc.section.4.3.2.p.3">A server MUST NOT push a resource with the Associated-To-Stream-ID of 0. Clients MUST treat this as a session error (<a href="#SessionErrorHandler" title="Session Error Handling">Section&nbsp;3.5.1</a>) and send a GOAWAY frame of type PROTOCOL_ERROR.
      </p>
      <p id="rfc.section.4.3.2.p.4">When a client receives a HEADERS+PRIORITY frame from the server without a the ':host', ':scheme', and ':path' headers, it
         MUST reply with a RST_STREAM with error code HTTP_PROTOCOL_ERROR.
      </p>
      <p id="rfc.section.4.3.2.p.5">To cancel individual server push streams, the client can issue a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;3.5.2</a>) with error code CANCEL. Upon receipt, the server MUST stop sending on this stream immediately (this is an Abrupt termination).
      </p>
      <p id="rfc.section.4.3.2.p.6">To cancel all server push streams related to a request, the client may issue a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;3.5.2</a>) with error code CANCEL on the associated-stream-id. By cancelling that stream, the server MUST immediately stop sending frames
         for any streams with in-association-to for the original stream.
      </p>
      <p id="rfc.section.4.3.2.p.7">If the server sends a HEADERS frame containing headers that duplicate values on a previous HEADERS frame for the same stream,
         the client must issue a stream error (<a href="#StreamErrorHandler" title="Stream Error Handling">Section&nbsp;3.5.2</a>) with error code PROTOCOL ERROR.
      </p>
      <p id="rfc.section.4.3.2.p.8">If the server sends a HEADERS frame after sending a data frame for the same stream, the client MAY ignore the HEADERS frame.
         Ignoring the HEADERS frame after a data frame prevents handling of HTTP's trailing header fields (<a href="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/22/p1-messaging.html#header.trailer" title="Trailer">Section 4.1.1</a> of <a href="#HTTP-p1" id="rfc.xref.HTTP-p1.8"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[HTTP-p1]</cite></a>).
      </p>
      <h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a>&nbsp;Design Rationale and Notes
      </h1>
      <p id="rfc.section.5.p.1">Authors' notes: The notes in this section have no bearing on the HTTP/2.0 protocol as specified within this document, and
         none of these notes should be considered authoritative about how the protocol works. However, these notes may prove useful
         in future debates about how to resolve protocol ambiguities or how to evolve the protocol going forward. They may be removed
         before the final draft.
      </p>
      <h2 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1</a>&nbsp;Separation of Framing Layer and Application Layer
      </h2>
      <p id="rfc.section.5.1.p.1">Readers may note that this specification sometimes blends the framing layer (<a href="#FramingLayer" title="HTTP/2.0 Framing Layer">Section&nbsp;3</a>) with requirements of a specific application - HTTP (<a href="#HTTPLayer" title="HTTP Message Exchanges">Section&nbsp;4</a>). This is reflected in the request/response nature of the streams and the definition of the HEADERS which are very similar
         to HTTP, and other areas as well.
      </p>
      <p id="rfc.section.5.1.p.2">This blending is intentional - the primary goal of this protocol is to create a low-latency protocol for use with HTTP. Isolating
         the two layers is convenient for description of the protocol and how it relates to existing HTTP implementations. However,
         the ability to reuse the HTTP/2.0 framing layer is a non goal.
      </p>
      <h2 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2</a>&nbsp;Error handling - Framing Layer
      </h2>
      <p id="rfc.section.5.2.p.1">Error handling at the HTTP/2.0 layer splits errors into two groups: Those that affect an individual HTTP/2.0 stream, and those
         that do not.
      </p>
      <p id="rfc.section.5.2.p.2">When an error is confined to a single stream, but general framing is in tact, HTTP/2.0 attempts to use the RST_STREAM as a
         mechanism to invalidate the stream but move forward without aborting the connection altogether.
      </p>
      <p id="rfc.section.5.2.p.3">For errors occurring outside of a single stream context, HTTP/2.0 assumes the entire session is hosed. In this case, the endpoint
         detecting the error should initiate a connection close.
      </p>
      <h2 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3</a>&nbsp;One Connection Per Domain
      </h2>
      <p id="rfc.section.5.3.p.1">HTTP/2.0 attempts to use fewer connections than other protocols have traditionally used. The rationale for this behavior is
         because it is very difficult to provide a consistent level of service (e.g. TCP slow-start), prioritization, or optimal compression
         when the client is connecting to the server through multiple channels.
      </p>
      <p id="rfc.section.5.3.p.2">Through lab measurements, we have seen consistent latency benefits by using fewer connections from the client. The overall
         number of packets sent by HTTP/2.0 can be as much as 40% less than HTTP. Handling large numbers of concurrent connections
         on the server also does become a scalability problem, and HTTP/2.0 reduces this load.
      </p>
      <p id="rfc.section.5.3.p.3">The use of multiple connections is not without benefit, however. Because HTTP/2.0 multiplexes multiple, independent streams
         onto a single stream, it creates a potential for head-of-line blocking problems at the transport level. In tests so far, the
         negative effects of head-of-line blocking (especially in the presence of packet loss) is outweighed by the benefits of compression
         and prioritization.
      </p>
      <h2 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4</a>&nbsp;Fixed vs Variable Length Fields
      </h2>
      <p id="rfc.section.5.4.p.1">HTTP/2.0 favors use of fixed length 32bit fields in cases where smaller, variable length encodings could have been used. To
         some, this seems like a tragic waste of bandwidth. HTTP/2.0 chooses the simple encoding for speed and simplicity.
      </p>
      <p id="rfc.section.5.4.p.2">The goal of HTTP/2.0 is to reduce latency on the network. The overhead of HTTP/2.0 frames is generally quite low. Each data
         frame is only an 8 byte overhead for a 1452 byte payload (~0.6%). At the time of this writing, bandwidth is already plentiful,
         and there is a strong trend indicating that bandwidth will continue to increase. With an average worldwide bandwidth of 1Mbps,
         and assuming that a variable length encoding could reduce the overhead by 50%, the latency saved by using a variable length
         encoding would be less than 100 nanoseconds. More interesting are the effects when the larger encodings force a packet boundary,
         in which case a round-trip could be induced. However, by addressing other aspects of HTTP/2.0 and TCP interactions, we believe
         this is completely mitigated.
      </p>
      <h2 id="rfc.section.5.5"><a href="#rfc.section.5.5">5.5</a>&nbsp;Data Compression
      </h2>
      <p id="rfc.section.5.5.p.1">Generic compression of data portion of the streams (as opposed to compression of the headers) without knowing the content
         of the stream is redundant. There is no value in compressing a stream which is already compressed. Because of this, HTTP/2.0
         does allow data compression to be optional. We included it because study of existing websites shows that many sites are not
         using compression as they should, and users suffer because of it. We wanted a mechanism where, at the HTTP/2.0 layer, site
         administrators could simply force compression - it is better to compress twice than to not compress.
      </p>
      <p id="rfc.section.5.5.p.2">Overall, however, with this feature being optional and sometimes redundant, it is unclear if it is useful at all. We will
         likely remove it from the specification.
      </p>
      <h2 id="rfc.section.5.6"><a href="#rfc.section.5.6">5.6</a>&nbsp;Server Push
      </h2>
      <p id="rfc.section.5.6.p.1">A subtle but important point is that server push streams must be declared before the associated stream is closed. The reason
         for this is so that proxies have a lifetime for which they can discard information about previous streams. If a pushed stream
         could associate itself with an already-closed stream, then endpoints would not have a specific lifecycle for when they could
         disavow knowledge of the streams which went before.
      </p>
      <h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a>&nbsp;Security Considerations
      </h1>
      <h2 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1</a>&nbsp;Use of Same-origin constraints
      </h2>
      <p id="rfc.section.6.1.p.1">This specification uses the same-origin policy (<a href="#RFC6454" id="rfc.xref.RFC6454.4"><cite title="The Web Origin Concept">[RFC6454]</cite></a>, <a href="http://tools.ietf.org/html/rfc6454#section-3">Section 3</a>) in all cases where verification of content is required.
      </p>
      <h2 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2</a>&nbsp;Cross-Protocol Attacks
      </h2>
      <p id="rfc.section.6.2.p.1">By utilizing TLS, we believe that HTTP/2.0 introduces no new cross-protocol attacks. TLS encrypts the contents of all transmission
         (except the handshake itself), making it difficult for attackers to control the data which could be used in a cross-protocol
         attack. <span class="comment" id="rfc.comment.21">[<a href="#rfc.comment.21" class="smpl">rfc.comment.21</a>: Issue: This is no longer true]</span> 
      </p>
      <h2 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3</a>&nbsp;Cacheability of Pushed Resources
      </h2>
      <p id="rfc.section.6.3.p.1">Pushed resources do not have an associated request. In order for existing HTTP cache control validations (such as the Vary
         header field) to work, all cached resources must have a set of request header fields. For this reason, caches MUST be careful
         to inherit request header fields from the associated stream for the push. This includes the Cookie header field.
      </p>
      <p id="rfc.section.6.3.p.2">Caching resources that are pushed is possible, based on the guidance provided by the origin server in the Cache-Control header
         field. However, this can cause issues if a single server hosts more than one tenant. For example, a server might offer multiple
         users each a small portion of its URI space.
      </p>
      <p id="rfc.section.6.3.p.3">Where multiple tenants share space on the same server, that server MUST ensure that tenants are not able to push representations
         of resources that they do not have authority over. Failure to enforce this would allow a tenant to provide a representation
         that would be served out of cache, overriding the actual representation that the authoritative tenant provides.
      </p>
      <p id="rfc.section.6.3.p.4">Pushed resources for which an origin server is not authoritative are never cached or used.</p>
      <h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a>&nbsp;Privacy Considerations
      </h1>
      <h2 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1</a>&nbsp;Long Lived Connections
      </h2>
      <p id="rfc.section.7.1.p.1">HTTP/2.0 aims to keep connections open longer between clients and servers in order to reduce the latency when a user makes
         a request. The maintenance of these connections over time could be used to expose private information. For example, a user
         using a browser hours after the previous user stopped using that browser may be able to learn about what the previous user
         was doing. This is a problem with HTTP in its current form as well, however the short lived connections make it less of a
         risk.
      </p>
      <h2 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2</a>&nbsp;SETTINGS frame
      </h2>
      <p id="rfc.section.7.2.p.1">The HTTP/2.0 SETTINGS frame allows servers to store out-of-band transmitted information about the communication between client
         and server on the client. Although this is intended only to be used to reduce latency, renegade servers could use it as a
         mechanism to store identifying information about the client in future requests.
      </p>
      <p id="rfc.section.7.2.p.2">Clients implementing privacy modes can disable client-persisted SETTINGS storage.</p>
      <p id="rfc.section.7.2.p.3">Clients MUST clear persisted SETTINGS information when clearing the cookies.</p>
      <h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a>&nbsp;Acknowledgements
      </h1>
      <p id="rfc.section.8.p.1">This document includes substantial input from the following individuals: </p>
      <ul>
         <li>Adam Langley, Wan-Teh Chang, Jim Morrison, Mark Nottingham, Alyssa Wilk, Costin Manolache, William Chan, Vitaliy Lvin, Joe
            Chan, Adam Barth, Ryan Hamilton, Gavin Peters, Kent Alstad, Kevin Lindsay, Paul Amer, Fan Yang, Jonathan Leighton (SPDY contributors).
         </li>
         <li>Gabriel Montenegro and Willy Tarreau (Upgrade mechanism)</li>
         <li>William Chan, Salvatore Loreto, Osama Mazahir, Gabriel Montenegro, Jitu Padhye, Roberto Peon, Rob Trace (Flow control)</li>
         <li>Mark Nottingham and Julian Reschke</li>
      </ul>
      <h1 id="rfc.references"><a id="rfc.section.9" href="#rfc.section.9">9.</a> References
      </h1>
      <h2 id="rfc.references.1"><a href="#rfc.section.9.1" id="rfc.section.9.1">9.1</a> Normative References
      </h2>
      <table>                              
         <tr>
            <td class="reference"><b id="HTTP-p1">[HTTP-p1]</b></td>
            <td class="top">Fielding, R. and J. Reschke, “<a href="http://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-22">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-p1-messaging-22 (work in progress), February&nbsp;2013.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="HTTP-p2">[HTTP-p2]</b></td>
            <td class="top">Fielding, R. and J. Reschke, “<a href="http://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-22">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-p2-semantics-22 (work in progress), February&nbsp;2013.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="HTTP-p4">[HTTP-p4]</b></td>
            <td class="top"><a href="mailto:fielding@gbiv.com" title="Adobe Systems Incorporated">Fielding, R., Ed.</a> and <a href="mailto:julian.reschke@greenbytes.de" title="greenbytes GmbH">J. Reschke, Ed.</a>, “<a href="http://tools.ietf.org/html/draft-ietf-httpbis-p4-conditional-22">Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-p4-conditional-22 (work in progress), February&nbsp;2013.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="HTTP-p5">[HTTP-p5]</b></td>
            <td class="top"><a href="mailto:fielding@gbiv.com" title="Adobe Systems Incorporated">Fielding, R., Ed.</a>, <a href="mailto:ylafon@w3.org" title="World Wide Web Consortium">Lafon, Y., Ed.</a>, and <a href="mailto:julian.reschke@greenbytes.de" title="greenbytes GmbH">J. Reschke, Ed.</a>, “<a href="http://tools.ietf.org/html/draft-ietf-httpbis-p5-range-22">Hypertext Transfer Protocol (HTTP/1.1): Range Requests</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-p5-range-22 (work in progress), February&nbsp;2013.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="HTTP-p6">[HTTP-p6]</b></td>
            <td class="top"><a href="mailto:fielding@gbiv.com" title="Adobe Systems Incorporated">Fielding, R., Ed.</a>, <a href="mailto:mnot@mnot.net" title="Akamai">Nottingham, M., Ed.</a>, and <a href="mailto:julian.reschke@greenbytes.de" title="greenbytes GmbH">J. Reschke, Ed.</a>, “<a href="http://tools.ietf.org/html/draft-ietf-httpbis-p6-cache-22">Hypertext Transfer Protocol (HTTP/1.1): Caching</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-p6-cache-22 (work in progress), February&nbsp;2013.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="HTTP-p7">[HTTP-p7]</b></td>
            <td class="top"><a href="mailto:fielding@gbiv.com" title="Adobe Systems Incorporated">Fielding, R., Ed.</a> and <a href="mailto:julian.reschke@greenbytes.de" title="greenbytes GmbH">J. Reschke, Ed.</a>, “<a href="http://tools.ietf.org/html/draft-ietf-httpbis-p7-auth-22">Hypertext Transfer Protocol (HTTP/1.1): Authentication</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-p7-auth-22 (work in progress), February&nbsp;2013.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC0793">[RFC0793]</b></td>
            <td class="top">Postel, J., “<a href="http://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>”, STD&nbsp;7, RFC&nbsp;793, September&nbsp;1981.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC1950">[RFC1950]</b></td>
            <td class="top"><a href="mailto:ghost@aladdin.com" title="Aladdin Enterprises">Deutsch, L.</a> and J. Gailly, “<a href="http://tools.ietf.org/html/rfc1950">ZLIB Compressed Data Format Specification version 3.3</a>”, RFC&nbsp;1950, May&nbsp;1996.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC2119">[RFC2119]</b></td>
            <td class="top"><a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, “<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC2617">[RFC2617]</b></td>
            <td class="top"><a href="mailto:john@math.nwu.edu" title="Northwestern University, Department of Mathematics">Franks, J.</a>, <a href="mailto:pbaker@verisign.com" title="Verisign Inc.">Hallam-Baker, P.</a>, <a href="mailto:jeff@AbiSource.com" title="AbiSource, Inc.">Hostetler, J.</a>, <a href="mailto:lawrence@agranat.com" title="Agranat Systems, Inc.">Lawrence, S.</a>, <a href="mailto:paulle@microsoft.com" title="Microsoft Corporation">Leach, P.</a>, Luotonen, A., and <a href="mailto:stewart@OpenMarket.com" title="Open Market, Inc.">L. Stewart</a>, “<a href="http://tools.ietf.org/html/rfc2617">HTTP Authentication: Basic and Digest Access Authentication</a>”, RFC&nbsp;2617, June&nbsp;1999.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC3986">[RFC3986]</b></td>
            <td class="top">Berners-Lee, T., Fielding, R., and L. Masinter, “<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>”, STD&nbsp;66, RFC&nbsp;3986, January&nbsp;2005.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC4559">[RFC4559]</b></td>
            <td class="top">Jaganathan, K., Zhu, L., and J. Brezak, “<a href="http://tools.ietf.org/html/rfc4559">SPNEGO-based Kerberos and NTLM HTTP Authentication in Microsoft Windows</a>”, RFC&nbsp;4559, June&nbsp;2006.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC5246">[RFC5246]</b></td>
            <td class="top">Dierks, T. and E. Rescorla, “<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>”, RFC&nbsp;5246, August&nbsp;2008.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC6454">[RFC6454]</b></td>
            <td class="top">Barth, A., “<a href="http://tools.ietf.org/html/rfc6454">The Web Origin Concept</a>”, RFC&nbsp;6454, December&nbsp;2011.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="TLSNPN">[TLSNPN]</b></td>
            <td class="top">Langley, A., “<a href="http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04">Transport Layer Security (TLS) Next Protocol Negotiation Extension</a>”, Internet-Draft&nbsp;draft-agl-tls-nextprotoneg-04 (work in progress), May&nbsp;2012.
            </td>
         </tr>
      </table>
      <h2 id="rfc.references.2"><a href="#rfc.section.9.2" id="rfc.section.9.2">9.2</a> Informative References
      </h2>
      <table>    
         <tr>
            <td class="reference"><b id="RFC1323">[RFC1323]</b></td>
            <td class="top">Jacobson, V., Braden, B., and D. Borman, “<a href="http://tools.ietf.org/html/rfc1323">TCP Extensions for High Performance</a>”, RFC&nbsp;1323, May&nbsp;1992.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="TALKING">[TALKING]</b></td>
            <td class="top">Huang, L-S., Chen, E., Barth, A., Rescorla, E., and C. Jackson, “<a href="http://w2spconf.com/2011/papers/websocket.pdf">Talking to Yourself for Fun and Profit</a>”, 2011, &lt;<a href="http://w2spconf.com/2011/papers/websocket.pdf">http://w2spconf.com/2011/papers/websocket.pdf</a>&gt;.
            </td>
         </tr>
      </table>
      <div class="avoidbreak">
         <h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
         <address class="vcard"><span class="vcardline"><span class="fn">Mike Belshe</span><span class="n hidden"><span class="family-name">Belshe</span><span class="given-name">Mike</span></span></span><span class="org vcardline">Twist</span><span class="vcardline">Email: <a href="mailto:mbelshe@chromium.org"><span class="email">mbelshe@chromium.org</span></a></span></address>
         <address class="vcard"><span class="vcardline"><span class="fn">Roberto Peon</span><span class="n hidden"><span class="family-name">Peon</span><span class="given-name">Roberto</span></span></span><span class="org vcardline">Google, Inc</span><span class="vcardline">Email: <a href="mailto:fenix@google.com"><span class="email">fenix@google.com</span></a></span></address>
         <address class="vcard"><span class="vcardline"><span class="fn">Martin Thomson</span>
               (editor)
               <span class="n hidden"><span class="family-name">Thomson</span><span class="given-name">Martin</span></span></span><span class="org vcardline">Microsoft</span><span class="adr"><span class="street-address vcardline">3210 Porter Drive</span><span class="vcardline"><span class="locality">Palo Alto</span>, <span class="postal-code">94043</span></span><span class="country-name vcardline">US</span></span><span class="vcardline">Email: <a href="mailto:martin.thomson@skype.net"><span class="email">martin.thomson@skype.net</span></a></span></address>
         <address class="vcard"><span class="vcardline"><span class="fn">Alexey Melnikov</span>
               (editor)
               <span class="n hidden"><span class="family-name">Melnikov</span><span class="given-name">Alexey</span></span></span><span class="org vcardline">Isode Ltd</span><span class="adr"><span class="street-address vcardline">5 Castle Business Village</span><span class="street-address vcardline">36 Station Road</span><span class="vcardline"><span class="locality">Hampton</span>, <span class="region">Middlesex</span>&nbsp;<span class="postal-code">TW12 2BX</span></span><span class="country-name vcardline">UK</span></span><span class="vcardline">Email: <a href="mailto:Alexey.Melnikov@isode.com"><span class="email">Alexey.Melnikov@isode.com</span></a></span></address>
      </div>
      <h1 id="rfc.section.A" class="np"><a href="#rfc.section.A">A.</a>&nbsp;<a id="change.log" href="#change.log">Change Log (to be removed by RFC Editor before publication)</a></h1>
      <h2 id="rfc.section.A.1"><a href="#rfc.section.A.1">A.1</a>&nbsp;<a id="changes.since.draft-ietf-httpbis-http2-01" href="#changes.since.draft-ietf-httpbis-http2-01">Since draft-ietf-httpbis-http2-01</a></h2>
      <p id="rfc.section.A.1.p.1">Removed zlib-based header compression mechanism.</p>
      <p id="rfc.section.A.1.p.2">Updated references.</p>
      <p id="rfc.section.A.1.p.3">Clarified stream identifier reuse.</p>
      <p id="rfc.section.A.1.p.4">Removed CREDENTIALS frame and associated mechanisms.</p>
      <p id="rfc.section.A.1.p.5">Added advice against naive implementation of flow control.</p>
      <p id="rfc.section.A.1.p.6">Added session header section.</p>
      <p id="rfc.section.A.1.p.7">Restructured frame header. Removed distinction between data and control frames.</p>
      <p id="rfc.section.A.1.p.8">Altered flow control properties to include session-level limits.</p>
      <p id="rfc.section.A.1.p.9">Added note on cacheability of pushed resources and multiple tenant servers.</p>
      <p id="rfc.section.A.1.p.10">Changed protocol label form based on discussions.</p>
      <h2 id="rfc.section.A.2"><a href="#rfc.section.A.2">A.2</a>&nbsp;<a id="changes.since.draft-ietf-httpbis-http2-00" href="#changes.since.draft-ietf-httpbis-http2-00">Since draft-ietf-httpbis-http2-00</a></h2>
      <p id="rfc.section.A.2.p.1">Changed title throughout.</p>
      <p id="rfc.section.A.2.p.2">Removed section on Incompatibilities with SPDY draft#2.</p>
      <p id="rfc.section.A.2.p.3">Changed INTERNAL_ERROR on GOAWAY to have a value of 2 &lt;<a href="https://groups.google.com/forum/?fromgroups#!topic/spdy-dev/cfUef2gL3iU">https://groups.google.com/forum/?fromgroups#!topic/spdy-dev/cfUef2gL3iU</a>&gt;.
      </p>
      <p id="rfc.section.A.2.p.4">Replaced abstract and introduction.</p>
      <p id="rfc.section.A.2.p.5">Added section on starting HTTP/2.0, including upgrade mechanism.</p>
      <p id="rfc.section.A.2.p.6">Removed unused references.</p>
      <p id="rfc.section.A.2.p.7">Added flow control principles (<a href="#fc-principles" title="Flow Control Principles">Section&nbsp;3.6.1</a>) based on &lt;<a href="http://tools.ietf.org/html/draft-montenegro-httpbis-http2-fc-principles-01">http://tools.ietf.org/html/draft-montenegro-httpbis-http2-fc-principles-01</a>&gt;.
      </p>
      <h2 id="rfc.section.A.3"><a href="#rfc.section.A.3">A.3</a>&nbsp;<a id="changes.since.draft-mbelshe-httpbis-spdy-00" href="#changes.since.draft-mbelshe-httpbis-spdy-00">Since draft-mbelshe-httpbis-spdy-00</a></h2>
      <p id="rfc.section.A.3.p.1">Adopted as base for draft-ietf-httpbis-http2.</p>
      <p id="rfc.section.A.3.p.2">Updated authors/editors list.</p>
      <p id="rfc.section.A.3.p.3">Added status note.</p>
      <h1 id="rfc.index"><a href="#rfc.index">Index</a></h1>
      <p class="noprint"><a href="#rfc.index.H">H</a> <a href="#rfc.index.R">R</a> <a href="#rfc.index.T">T</a> 
      </p>
      <div class="print2col">
         <ul class="ind">
            <li><a id="rfc.index.H" href="#rfc.index.H"><b>H</b></a><ul>
                  <li><em>HTTP-p1</em>&nbsp;&nbsp;<a href="#rfc.xref.HTTP-p1.1">1</a>, <a href="#rfc.xref.HTTP-p1.2">2.1</a>, <a href="#rfc.xref.HTTP-p1.3">2.2</a>, <a href="#rfc.xref.HTTP-p1.4">4</a>, <a href="#rfc.xref.HTTP-p1.5">4.2.2</a>, <a href="#rfc.xref.HTTP-p1.6">4.2.2</a>, <a href="#rfc.xref.HTTP-p1.7">4.2.2</a>, <a href="#rfc.xref.HTTP-p1.8">4.3.2</a>, <a href="#HTTP-p1"><b>9.1</b></a><ul>
                        <li><em>Section 3</em>&nbsp;&nbsp;<a href="#rfc.xref.HTTP-p1.1">1</a></li>
                        <li><em>Section 3.1.1</em>&nbsp;&nbsp;<a href="#rfc.xref.HTTP-p1.5">4.2.2</a>, <a href="#rfc.xref.HTTP-p1.6">4.2.2</a></li>
                        <li><em>Section 3.2.6</em>&nbsp;&nbsp;<a href="#rfc.xref.HTTP-p1.2">2.1</a></li>
                        <li><em>Section 4.1.1</em>&nbsp;&nbsp;<a href="#rfc.xref.HTTP-p1.8">4.3.2</a></li>
                        <li><em>Section 5.4</em>&nbsp;&nbsp;<a href="#rfc.xref.HTTP-p1.7">4.2.2</a></li>
                        <li><em>Section 6.7</em>&nbsp;&nbsp;<a href="#rfc.xref.HTTP-p1.3">2.2</a></li>
                     </ul>
                  </li>
                  <li><em>HTTP-p2</em>&nbsp;&nbsp;<a href="#rfc.xref.HTTP-p2.1">4</a>, <a href="#rfc.xref.HTTP-p2.2">4.2.2</a>, <a href="#HTTP-p2"><b>9.1</b></a><ul>
                        <li><em>Section 4</em>&nbsp;&nbsp;<a href="#rfc.xref.HTTP-p2.2">4.2.2</a></li>
                     </ul>
                  </li>
                  <li><em>HTTP-p4</em>&nbsp;&nbsp;<a href="#rfc.xref.HTTP-p4.1">4</a>, <a href="#HTTP-p4"><b>9.1</b></a></li>
                  <li><em>HTTP-p5</em>&nbsp;&nbsp;<a href="#rfc.xref.HTTP-p5.1">4</a>, <a href="#HTTP-p5"><b>9.1</b></a></li>
                  <li><em>HTTP-p6</em>&nbsp;&nbsp;<a href="#rfc.xref.HTTP-p6.1">4</a>, <a href="#HTTP-p6"><b>9.1</b></a></li>
                  <li><em>HTTP-p7</em>&nbsp;&nbsp;<a href="#rfc.xref.HTTP-p7.1">4</a>, <a href="#rfc.xref.HTTP-p7.2">4.2.4</a>, <a href="#HTTP-p7"><b>9.1</b></a></li>
               </ul>
            </li>
            <li><a id="rfc.index.R" href="#rfc.index.R"><b>R</b></a><ul>
                  <li><em>RFC0793</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC0793.1">3.1</a>, <a href="#RFC0793"><b>9.1</b></a></li>
                  <li><em>RFC1323</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC1323.1">3.6.2</a>, <a href="#RFC1323"><b>9.2</b></a></li>
                  <li><em>RFC1950</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC1950.1">3.7.1</a>, <a href="#RFC1950"><b>9.1</b></a></li>
                  <li><em>RFC2119</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC2119.1">1.2</a>, <a href="#RFC2119"><b>9.1</b></a></li>
                  <li><em>RFC2617</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC2617.1">4.2.4</a>, <a href="#RFC2617"><b>9.1</b></a></li>
                  <li><em>RFC3986</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC3986.1">4.2.2</a>, <a href="#RFC3986"><b>9.1</b></a><ul>
                        <li><em>Section 3.2</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC3986.1">4.2.2</a></li>
                     </ul>
                  </li>
                  <li><em>RFC4559</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC4559.1">4.2.4</a>, <a href="#RFC4559"><b>9.1</b></a></li>
                  <li><em>RFC5246</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC5246.1">2.3</a>, <a href="#RFC5246"><b>9.1</b></a></li>
                  <li><em>RFC6454</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC6454.1">3.7.5</a>, <a href="#rfc.xref.RFC6454.2">4.1</a>, <a href="#rfc.xref.RFC6454.3">4.3</a>, <a href="#rfc.xref.RFC6454.4">6.1</a>, <a href="#RFC6454"><b>9.1</b></a><ul>
                        <li><em>Section 3</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC6454.3">4.3</a>, <a href="#rfc.xref.RFC6454.4">6.1</a></li>
                     </ul>
                  </li>
               </ul>
            </li>
            <li><a id="rfc.index.T" href="#rfc.index.T"><b>T</b></a><ul>
                  <li><em>TALKING</em>&nbsp;&nbsp;<a href="#rfc.xref.TALKING.1">3.2</a>, <a href="#TALKING"><b>9.2</b></a></li>
                  <li><em>TLSNPN</em>&nbsp;&nbsp;<a href="#rfc.xref.TLSNPN.1">2.1</a>, <a href="#rfc.xref.TLSNPN.2">2.3</a>, <a href="#rfc.xref.TLSNPN.3">2.4</a>, <a href="#TLSNPN"><b>9.1</b></a></li>
               </ul>
            </li>
         </ul>
      </div>
   </body>
</html>