<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en">
   <head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>HPACK - Header Compression for HTTP/2.0 </title><script>
var buttonsAdded = false;

function init() {
  var fb = document.createElement("div");
  fb.className = "feedback noprint";
  fb.setAttribute("onclick", "feedback();");
  fb.appendChild(document.createTextNode("feedback"));

  var bodyl = document.getElementsByTagName("body");
  bodyl.item(0).appendChild(fb);
}

function feedback() {
  toggleButtonsToElementsByName("h1");
  toggleButtonsToElementsByName("h2");
  toggleButtonsToElementsByName("h3");
  toggleButtonsToElementsByName("h4");

  buttonsAdded = !buttonsAdded;
}

function toggleButtonsToElementsByName(name) {
  var list = document.getElementsByTagName(name);
  for (var i = 0; i < list.length; i++) {
    toggleButton(list.item(i));
  }
}

function toggleButton(node) {
  if (! buttonsAdded) {

    // docname
    var template = "mailto:ietf-http-wg@w3.org?subject={docname},%20%22{section}%22&body=<{ref}>:";

    var id = node.getAttribute("id");
    // better id available?
    var titlelinks = node.getElementsByTagName("a");
    for (var i = 0; i < titlelinks.length; i++) {
      var tl = titlelinks.item(i);
      if (tl.getAttribute("id")) {
        id = tl.getAttribute("id");
      }
    }

    // ref
    var ref = window.location.toString();
    var hash = ref.indexOf("#");
    if (hash != -1) {
      ref = ref.substring(0, hash);
    }
    if (id != "") {
      ref += "#" + id;
    }

    // docname
    var docname = "draft-ietf-httpbis-header-compression-latest";

    // section
    var section = node.textContent;
    section = section.replace("\u00a0", " ");

    // build URI from template
    var uri = template.replace("{docname}", encodeURIComponent(docname));
    uri = uri.replace("{section}", encodeURIComponent(section));
    uri = uri.replace("{ref}", encodeURIComponent(ref));

    var button = document.createElement("a");
    button.className = "fbbutton noprint";
    button.setAttribute("href", uri);
    button.appendChild(document.createTextNode("send feedback"));
    node.appendChild(button);
  }
  else {
    var buttons = node.getElementsByTagName("a");
    for (var i = 0; i < buttons.length; i++) {
      var b = buttons.item(i);
      if (b.className == "fbbutton noprint") {
        node.removeChild(b);
      }
    }
  }
}</script><style type="text/css" title="Xml2Rfc (sans serif)">
a {
  text-decoration: none;
}
a.smpl {
  color: black;
}
a:hover {
  text-decoration: underline;
}
a:active {
  text-decoration: underline;
}
address {
  margin-top: 1em;
  margin-left: 2em;
  font-style: normal;
}
body {
  color: black;
  font-family: cambria, helvetica, arial, sans-serif;
  font-size: 11pt;
  margin-right: 2em;
}
cite {
  font-style: normal;
}
dl {
  margin-left: 2em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}
dl p {
  margin-left: 0em;
}
dt {
  margin-top: .5em;
}
h1 {
  font-size: 130%;
  line-height: 21pt;
  page-break-after: avoid;
}
h1.np {
  page-break-before: always;
}
h2 {
  font-size: 120%;
  line-height: 15pt;
  page-break-after: avoid;
}
h3, h4, h5, h6 {
  font-size: 110%;
  page-break-after: avoid;
}
h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
  color: black;
}
img {
  margin-left: 3em;
}
li {
  margin-left: 2em;
}
ol {
  margin-left: 2em;
}
ol.la {
  list-style-type: lower-alpha;
}
ol.ua {
  list-style-type: upper-alpha;
}
ol p {
  margin-left: 0em;
}
p {
  margin-left: 2em;
}
pre {
  margin-left: 3em;
  background-color: lightyellow;
  padding: .25em;
  page-break-inside: avoid;
}
pre.text2 {
  border-style: dotted;
  border-width: 1px;
  background-color: #f0f0f0;
  width: 69em;
}
pre.inline {
  background-color: white;
  padding: 0em;
}
pre.text {
  border-style: dotted;
  border-width: 1px;
  background-color: #f8f8f8;
  width: 69em;
}
pre.drawing {
  border-style: solid;
  border-width: 1px;
  background-color: #f8f8f8;
  padding: 2em;
}
sup {
  font-size: 60%;
}
table {
  margin-left: 2em;
}
table.tt {
  vertical-align: top;
}
table.full {
  border-style: outset;
  border-width: 1px;
}
table.headers {
  border-style: outset;
  border-width: 1px;
}
table.tt td {
  vertical-align: top;
}
table.full td {
  border-style: inset;
  border-width: 1px;
}
table.tt th {
  vertical-align: top;
}
table.full th {
  border-style: inset;
  border-width: 1px;
}
table.headers th {
  border-style: none none inset none;
  border-width: 1px;
}
table.left {
  margin-right: auto;
}
table.right {
  margin-left: auto;
}
table.center {
  margin-left: auto;
  margin-right: auto;
}
caption {
  caption-side: bottom;
  font-weight: bold;
  font-size: 10pt;
  margin-top: .5em;
}

table.header {
  border-spacing: 1px;
  width: 95%;
  font-size: 11pt;
  color: white;
}
td.top {
  vertical-align: top;
}
td.topnowrap {
  vertical-align: top;
  white-space: nowrap;
}
table.header td {
  background-color: gray;
  width: 50%;
}
td.reference {
  vertical-align: top;
  white-space: nowrap;
  padding-right: 1em;
}
thead {
  display:table-header-group;
}
ul.toc, ul.toc ul {
  list-style: none;
  margin-left: 1.5em;
  padding-left: 0em;
}
ul.toc li {
  line-height: 150%;
  font-weight: bold;
  margin-left: 0em;
}
ul.toc li li {
  line-height: normal;
  font-weight: normal;
  font-size: 10pt;
  margin-left: 0em;
}
li.excluded {
  font-size: 0pt;
}
ul p {
  margin-left: 0em;
}
.title, .filename, h1, h2, h3, h4 {
  font-family: candara, helvetica, arial, sans-serif;
}
samp, tt, code, pre {
  font: consolas, monospace;
}

.comment {
  background-color: yellow;
}
.center {
  text-align: center;
}
.error {
  color: red;
  font-style: italic;
  font-weight: bold;
}
.figure {
  font-weight: bold;
  text-align: center;
  font-size: 10pt;
}
.filename {
  color: #333333;
  font-size: 75%;
  font-weight: bold;
  line-height: 21pt;
  text-align: center;
}
.fn {
  font-weight: bold;
}
.left {
  text-align: left;
}
.right {
  text-align: right;
}
.title {
  color: green;
  font-size: 150%;
  line-height: 18pt;
  font-weight: bold;
  text-align: center;
  margin-top: 36pt;
}
.warning {
  font-size: 130%;
  background-color: yellow;
}
.feedback {
  position: fixed;
  bottom: 1%;
  right: 1%;
  padding: 3px 5px;
  color: white;
  border-radius: 5px;
  background: #a00000;
  border: 1px solid silver;
}
.fbbutton {
  margin-left: 1em;
  color: #303030;
  font-size: small;
  font-weight: normal;
  background: #d0d000;
  padding: 1px 4px;
  border: 1px solid silver;
  border-radius: 5px;
}

@media print {
  .noprint {
    display: none;
  }

  a {
    color: black;
    text-decoration: none;
  }

  table.header {
    width: 90%;
  }

  td.header {
    width: 50%;
    color: black;
    background-color: white;
    vertical-align: top;
    font-size: 110%;
  }

  ul.toc a:nth-child(2)::after {
    content: leader('.') target-counter(attr(href), page);
  }

  ul.ind li li a {
    content: target-counter(attr(href), page);
  }

  .print2col {
    column-count: 2;
    -moz-column-count: 2;
    column-fill: auto;
  }
}

@page {
  @top-left {
       content: "Internet-Draft";
  }
  @top-right {
       content: "October 2013";
  }
  @top-center {
       content: "HPACK";
  }
  @bottom-left {
       content: "Peon & Ruellan";
  }
  @bottom-center {
       content: "Expires April 18, 2014";
  }
  @bottom-right {
       content: "[Page " counter(page) "]";
  }
}

@page:first {
    @top-left {
      content: normal;
    }
    @top-right {
      content: normal;
    }
    @top-center {
      content: normal;
    }
}
</style><style tyle="text/css">body {   font: 11pt cambria, helvetica, arial, sans-serif;   font-size-adjust: 0.5;   line-height: 130%;   margin: 1em auto;   max-width: 700px; }  .title, .filename, h1, h2, h3, h4 {   font-family: candara, helvetica, arial, sans-serif;   font-size-adjust: 0.5; } .title { font-size: 150%; } h1 { font-size: 130%; } h2 { font-size: 120%; } h3, h4 { font-size: 110%; } ul.toc >li { font-size: 95%; } ul.toc >li >ul, .figure, caption { font-size: 90%; }  table {   margin-left: 0em; } table.header {   width: 100%; }  table.header td {   background-color: inherit;   color: black; }  samp, tt, code, pre {   font: 11pt consolas, monospace;   font-size-adjust: none; }  pre.text, pre.text2 {   width: 90%; }  dt {   float: left; clear: left;   margin: 0.5em 0.5em 0 0; } dt:first-child {   margin-top: 0; } dd {   margin: 0.5em 0 0 2em; } dd p, dd ul {   margin-top: 0; margin-bottom: 0; } dd *+p {   margin-top: 0.5em; }  ol, ul {   padding: 0;   margin: 0.5em 0 0.5em 2em; } ul.toc, ul.toc ul {    margin: 0 0 0 1.5em; } ul.toc a:first-child {    display: inline-block;    min-width: 1.2em; }</style><link rel="Contents" href="#rfc.toc">
      <link rel="Author" href="#rfc.authors">
      <link rel="Copyright" href="#rfc.copyrightnotice">
      <link rel="Chapter" title="1 Introduction" href="#rfc.section.1">
      <link rel="Chapter" title="2 Overview" href="#rfc.section.2">
      <link rel="Chapter" title="3 Header Field Encoding" href="#rfc.section.3">
      <link rel="Chapter" title="4 Detailed Format" href="#rfc.section.4">
      <link rel="Chapter" title="5 Parameter Negotiation" href="#rfc.section.5">
      <link rel="Chapter" title="6 Security Considerations" href="#rfc.section.6">
      <link rel="Chapter" href="#rfc.section.7" title="7 References">
      <link rel="Appendix" title="A Change Log (to be removed by RFC Editor before publication" href="#rfc.section.A">
      <link rel="Appendix" title="B Static Header Field Table" href="#rfc.section.B">
      <link rel="Appendix" title="C Example" href="#rfc.section.C">
      <meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.603, 2013/09/18 20:22:25, XSLT vendor: SAXON 9.1.0.8 from Saxonica http://www.saxonica.com/">
      <meta name="keywords" content="HTTP, Header">
      <link rel="schema.dct" href="http://purl.org/dc/terms/">
      <meta name="dct.creator" content="Peon, R.">
      <meta name="dct.creator" content="Ruellan, H.">
      <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-httpbis-header-compression-latest">
      <meta name="dct.issued" scheme="ISO8601" content="2013-10-15">
      <meta name="dct.abstract" content="This document describes HPACK, a format adapted to efficiently represent HTTP header fields in the context of HTTP/2.0.">
      <meta name="description" content="This document describes HPACK, a format adapted to efficiently represent HTTP header fields in the context of HTTP/2.0.">
   </head>
   <body onload="init();">
      <table class="header">
         <tbody>
            <tr>
               <td class="left">HTTPbis Working Group</td>
               <td class="right">R. Peon</td>
            </tr>
            <tr>
               <td class="left">Internet-Draft</td>
               <td class="right">Google, Inc</td>
            </tr>
            <tr>
               <td class="left">Intended status: Informational</td>
               <td class="right">H. Ruellan</td>
            </tr>
            <tr>
               <td class="left">Expires: April 18, 2014</td>
               <td class="right">Canon CRF</td>
            </tr>
            <tr>
               <td class="left"></td>
               <td class="right">October 15, 2013</td>
            </tr>
         </tbody>
      </table>
      <p class="title">HPACK - Header Compression for HTTP/2.0<br><span class="filename">draft-ietf-httpbis-header-compression-latest</span></p>
      <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
      <p>This document describes HPACK, a format adapted to efficiently represent HTTP header fields in the context of HTTP/2.0.</p>
      <h1 id="rfc.note.1"><a href="#rfc.note.1">Editorial Note (To be removed by RFC Editor)</a></h1>
      <p>Discussion of this draft takes place on the HTTPBIS working group mailing list (ietf-http-wg@w3.org), which is archived at &lt;<a href="http://lists.w3.org/Archives/Public/ietf-http-wg/">http://lists.w3.org/Archives/Public/ietf-http-wg/</a>&gt;.
      </p>
      <p>Working Group information and related documents can be found at &lt;<a href="http://tools.ietf.org/wg/httpbis/">http://tools.ietf.org/wg/httpbis/</a>&gt; (Wiki) and &lt;<a href="https://github.com/http2/http2-spec">https://github.com/http2/http2-spec</a>&gt; (source code and issues tracker).
      </p>
      <p>The changes in this draft are summarized in <a href="#changes.since.draft-ietf-httpbis-header-compression-03" title="Since draft-ietf-httpbis-header-compression-03">Appendix&nbsp;A.1</a>.
      </p>
      <div id="rfc.status">
         <h1><a href="#rfc.status">Status of This Memo</a></h1>
         <p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
         <p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute
            working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.
         </p>
         <p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other
            documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work
            in progress”.
         </p>
         <p>This Internet-Draft will expire on April 18, 2014.</p>
      </div>
      <div id="rfc.copyrightnotice">
         <h1><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
         <p>Copyright © 2013 IETF Trust and the persons identified as the document authors. All rights reserved.</p>
         <p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights
            and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License
            text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified
            BSD License.
         </p>
      </div>
      <hr class="noprint">
      <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
      <ul class="toc">
         <li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.1">Introduction</a></li>
         <li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#overview">Overview</a><ul>
               <li><a href="#rfc.section.2.1">2.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.2.1">Outline</a></li>
            </ul>
         </li>
         <li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#header.encoding">Header Field Encoding</a><ul>
               <li><a href="#rfc.section.3.1">3.1</a>&nbsp;&nbsp;&nbsp;<a href="#encoding.concepts">Encoding Concepts</a><ul>
                     <li><a href="#rfc.section.3.1.1">3.1.1</a>&nbsp;&nbsp;&nbsp;<a href="#encoding.context">Encoding Context</a></li>
                     <li><a href="#rfc.section.3.1.2">3.1.2</a>&nbsp;&nbsp;&nbsp;<a href="#header.table">Header Table</a></li>
                     <li><a href="#rfc.section.3.1.3">3.1.3</a>&nbsp;&nbsp;&nbsp;<a href="#reference.set">Reference Set</a></li>
                     <li><a href="#rfc.section.3.1.4">3.1.4</a>&nbsp;&nbsp;&nbsp;<a href="#header.set">Header set</a></li>
                     <li><a href="#rfc.section.3.1.5">3.1.5</a>&nbsp;&nbsp;&nbsp;<a href="#header.representation">Header Field Representation</a></li>
                     <li><a href="#rfc.section.3.1.6">3.1.6</a>&nbsp;&nbsp;&nbsp;<a href="#header.emission">Header Field Emission</a></li>
                  </ul>
               </li>
               <li><a href="#rfc.section.3.2">3.2</a>&nbsp;&nbsp;&nbsp;<a href="#header.set.processing">Header Set Processing</a><ul>
                     <li><a href="#rfc.section.3.2.1">3.2.1</a>&nbsp;&nbsp;&nbsp;<a href="#header.representation.processing">Header Field Representation Processing</a></li>
                     <li><a href="#rfc.section.3.2.2">3.2.2</a>&nbsp;&nbsp;&nbsp;<a href="#reference.set.emission">Reference Set Emission</a></li>
                     <li><a href="#rfc.section.3.2.3">3.2.3</a>&nbsp;&nbsp;&nbsp;<a href="#header.set.completion">Header Set Completion</a></li>
                  </ul>
               </li>
               <li><a href="#rfc.section.3.3">3.3</a>&nbsp;&nbsp;&nbsp;<a href="#header.table.management">Header Table Management</a><ul>
                     <li><a href="#rfc.section.3.3.1">3.3.1</a>&nbsp;&nbsp;&nbsp;<a href="#maximum.table.size">Maximum Table Size</a></li>
                     <li><a href="#rfc.section.3.3.2">3.3.2</a>&nbsp;&nbsp;&nbsp;<a href="#entry.addition">Entry Addition</a></li>
                     <li><a href="#rfc.section.3.3.3">3.3.3</a>&nbsp;&nbsp;&nbsp;<a href="#entry.eviction">Entry Eviction</a></li>
                  </ul>
               </li>
            </ul>
         </li>
         <li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#detailed.format">Detailed Format</a><ul>
               <li><a href="#rfc.section.4.1">4.1</a>&nbsp;&nbsp;&nbsp;<a href="#low-level.representation">Low-level representations</a><ul>
                     <li><a href="#rfc.section.4.1.1">4.1.1</a>&nbsp;&nbsp;&nbsp;<a href="#integer.representation">Integer representation</a><ul>
                           <li><a href="#rfc.section.4.1.1.1">4.1.1.1</a>&nbsp;&nbsp;&nbsp;<a href="#integer.representation.example1">Example 1: Encoding 10 using a 5-bit prefix</a></li>
                           <li><a href="#rfc.section.4.1.1.2">4.1.1.2</a>&nbsp;&nbsp;&nbsp;<a href="#integer.representation.example2">Example 2: Encoding 1337 using a 5-bit prefix</a></li>
                        </ul>
                     </li>
                     <li><a href="#rfc.section.4.1.2">4.1.2</a>&nbsp;&nbsp;&nbsp;<a href="#string.literal.representation">String Literal Representation</a></li>
                  </ul>
               </li>
               <li><a href="#rfc.section.4.2">4.2</a>&nbsp;&nbsp;&nbsp;<a href="#indexed.header.representation">Indexed Header Field Representation</a></li>
               <li><a href="#rfc.section.4.3">4.3</a>&nbsp;&nbsp;&nbsp;<a href="#literal.header.representation">Literal Header Field Representation</a><ul>
                     <li><a href="#rfc.section.4.3.1">4.3.1</a>&nbsp;&nbsp;&nbsp;<a href="#literal.header.without.indexing">Literal Header Field without Indexing</a></li>
                     <li><a href="#rfc.section.4.3.2">4.3.2</a>&nbsp;&nbsp;&nbsp;<a href="#literal.header.with.incremental.indexing">Literal Header Field with Incremental Indexing</a></li>
                  </ul>
               </li>
            </ul>
         </li>
         <li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#parameter.negotiation">Parameter Negotiation</a></li>
         <li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#Security">Security Considerations</a></li>
         <li><a href="#rfc.section.7">7.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a><ul>
               <li><a href="#rfc.section.7.1">7.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.1">Normative References</a></li>
               <li><a href="#rfc.section.7.2">7.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.2">Informative References</a></li>
            </ul>
         </li>
         <li><a href="#rfc.authors">Authors' Addresses</a></li>
         <li><a href="#rfc.section.A">A.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.A">Change Log (to be removed by RFC Editor before publication</a><ul>
               <li><a href="#rfc.section.A.1">A.1</a>&nbsp;&nbsp;&nbsp;<a href="#changes.since.draft-ietf-httpbis-header-compression-03">Since draft-ietf-httpbis-header-compression-03</a></li>
               <li><a href="#rfc.section.A.2">A.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.A.2">Since draft-ietf-httpbis-header-compression-02</a></li>
               <li><a href="#rfc.section.A.3">A.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.A.3">Since draft-ietf-httpbis-header-compression-01</a></li>
               <li><a href="#rfc.section.A.4">A.4</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.A.4">Since draft-ietf-httpbis-header-compression-01</a></li>
            </ul>
         </li>
         <li><a href="#rfc.section.B">B.</a>&nbsp;&nbsp;&nbsp;<a href="#static.headers">Static Header Field Table</a></li>
         <li><a href="#rfc.section.C">C.</a>&nbsp;&nbsp;&nbsp;<a href="#example">Example</a><ul>
               <li><a href="#rfc.section.C.1">C.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.C.1">First header set</a></li>
               <li><a href="#rfc.section.C.2">C.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.C.2">Second header set</a></li>
            </ul>
         </li>
      </ul>
      <ul class="toc">
         <li>Figures
            
            <ul>
               <li><a href="#rfc.figure.1">Figure 1: Header Table</a></li>
               <li><a href="#rfc.figure.2">Figure 2: Indexed Header Field</a></li>
               <li><a href="#rfc.figure.3">Figure 3: Literal Header Field without Indexing - Indexed Name</a></li>
               <li><a href="#rfc.figure.4">Figure 4: Literal Header Field without Indexing - New Name</a></li>
               <li><a href="#rfc.figure.5">Figure 5: Literal Header Field with Incremental Indexing -                         Indexed Name</a></li>
               <li><a href="#rfc.figure.6">Figure 6: Literal Header Field with Incremental Indexing -                         New Name</a></li>
            </ul>
         </li>
      </ul>
      <div>
         <h1 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;Introduction
         </h1>
         <p id="rfc.section.1.p.1">This document describes HPACK, a format adapted to efficiently represent HTTP header fields in the context of HTTP/2.0 (see <a href="#HTTP2"><cite title="Hypertext Transfer Protocol version 2.0">[HTTP2]</cite></a>).
         </p>
      </div>
      <div id="overview">
         <h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a>&nbsp;<a href="#overview">Overview</a></h1>
         <p id="rfc.section.2.p.1">In HTTP/1.X, header fields are sent without any form of compression. As web pages have grown to include dozens to hundreds
            of requests, the redundant header fields in these requests now pose a problem of measurable latency and unnecessary bandwidth
            (see <a href="#PERF1"><cite title="IETF83: SPDY and What to Consider for HTTP/2.0">[PERF1]</cite></a> and <a href="#PERF2"><cite title="SPDY: What I Like About You">[PERF2]</cite></a>).
         </p>
         <p id="rfc.section.2.p.2"><a href="#SPDY">SPDY</a> <cite title="SPDY Protocol">[SPDY]</cite> initially addressed this redundancy by compressing header fields with Deflate, which proved very effective at eliminating
            the redundant header fields. However, that aproach exposed a security risk as demonstrated by the <a href="#CRIME">CRIME</a> <cite title="The Crime Attack">[CRIME]</cite>.
         </p>
         <p id="rfc.section.2.p.3">In this document, we propose a new header field compressor which eliminates the redundant header fields, is not vulnerable
            to the CRIME style attack, and which also has a bounded memory cost for use in small constrained environments.
         </p>
         <div>
            <h2 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1</a>&nbsp;Outline
            </h2>
            <p id="rfc.section.2.1.p.1">The HTTP header field encoding described in this document is based on a header table that map (name, value) pairs to index
               values. Header tables are incrementally updated during the HTTP/2.0 session.
            </p>
            <p id="rfc.section.2.1.p.2">The encoder is responsible for deciding which header fields to insert as new entries in the header table. The decoder then
               does exactly what the encoder prescribes, ending in a state that exactly matches the encoder's state. This enables decoders
               to remain simple and understand a wide variety of encoders.
            </p>
            <p id="rfc.section.2.1.p.3">As two consecutive sets of header fields often have header fields in common, each set of header fields is coded as a difference
               from the previous set of header fields. The goal is to only encode the changes (header fields present in one of the set and
               not in the other) between the two sets of header fields.
            </p>
            <p id="rfc.section.2.1.p.4">An example illustrating the use of these different mechanisms to represent header fields is available in <a href="#example" title="Example">Appendix&nbsp;C</a>.
            </p>
         </div>
      </div>
      <div id="header.encoding">
         <h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a>&nbsp;<a href="#header.encoding">Header Field Encoding</a></h1>
         <div id="encoding.concepts">
            <h2 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1</a>&nbsp;<a href="#encoding.concepts">Encoding Concepts</a></h2>
            <p id="rfc.section.3.1.p.1">The encoding and decoding of header fields relies on some components and concepts. The set of components used form an encoding
               context. 
            </p>
            <dl>
               <dt>Header Table:</dt>
               <dd>The header table (see <a href="#header.table" title="Header Table">Section&nbsp;3.1.2</a>) is a component used to associate header fields to index values.
               </dd>
               <dt>Reference Set:</dt>
               <dd>The reference set (see <a href="#reference.set" title="Reference Set">Section&nbsp;3.1.3</a>) is a component containing a group of header fields used as a reference for the differential encoding of a new set of header
                  fields.
               </dd>
               <dt>Header Set:</dt>
               <dd>A header set (see <a href="#header.set" title="Header set">Section&nbsp;3.1.4</a>) is a group of header fields that are encoded jointly. A complete set of key-value pairs as encoded in a HTTP request or
                  response is a header set.
               </dd>
               <dt>Header Field Representation:</dt>
               <dd>A header field can be represented in encoded form either as a literal or as an index (see <a href="#header.representation" title="Header Field Representation">Section&nbsp;3.1.5</a>). The indexed representation is based on the header table.
               </dd>
               <dt>Header Field Emission:</dt>
               <dd>When decoding a set of header fields, some operations emit a header field (see <a href="#header.emission" title="Header Field Emission">Section&nbsp;3.1.6</a>). An emitted header field is added to the set of header fields that form the HTTP request or response. Once emitted, a header
                  field can't be removed from the set of header fields.
               </dd>
            </dl>
            <div id="encoding.context">
               <h3 id="rfc.section.3.1.1"><a href="#rfc.section.3.1.1">3.1.1</a>&nbsp;<a href="#encoding.context">Encoding Context</a></h3>
               <p id="rfc.section.3.1.1.p.1">The set of components used to encode or decode a header set form an encoding context: an encoding context contains a header
                  table and a reference set.
               </p>
               <p id="rfc.section.3.1.1.p.2">Using HTTP, messages are exchanged between a client and a server in both direction. To keep the encoding of header fields
                  in each direction independent from the other direction, there is one encoding context for each direction.
               </p>
               <p id="rfc.section.3.1.1.p.3">The header fields contained in a PUSH_PROMISE frame sent by a server to a client are encoded within the same context as the
                  header fields contained in the HEADERS frame corresponding to a response sent from the server to the client.
               </p>
            </div>
            <div id="header.table">
               <h3 id="rfc.section.3.1.2"><a href="#rfc.section.3.1.2">3.1.2</a>&nbsp;<a href="#header.table">Header Table</a></h3>
               <p id="rfc.section.3.1.2.p.1">A header table consists of an ordered list of (name, value) pairs. The first entry of a header table is assigned the index
                  0.
               </p>
               <p id="rfc.section.3.1.2.p.2">A header field can be represented by an entry from the header table. Rather than encoding a literal value for the header field
                  name and value, the encoder can select an entry from the header table, and represent the header field using the entry's index.
               </p>
               <p id="rfc.section.3.1.2.p.3">There is no need for the header table to contain duplicate entries. However, duplicate entries MUST NOT be treated as an error
                  by a decoder.
               </p>
               <p id="rfc.section.3.1.2.p.4">The header table has two parts, the first part is dynamic and is controlled by the encoder, while the second part is static.
                  The content of the static part is defined by <a href="#static.headers" title="Static Header Field Table">Appendix&nbsp;B</a>. The index of the first entry of the static part is the number of entries in the dynamic part: in index order, the static
                  part is appended after the dynamic part.
               </p>
               <p id="rfc.section.3.1.2.p.5">Initially, the dynamic part of the header table is empty.</p>
               <p id="rfc.section.3.1.2.p.6">A header table is modified by adding a new entry at the beginning of the table, in the dynamic part.</p>
               <p id="rfc.section.3.1.2.p.7">The encoder decides how to update the header table and as such can control how much memory is used by the header table. To
                  limit the memory requirements on the decoder side, the size of the dynamic part of the header table is bounded (see <a href="#maximum.table.size" title="Maximum Table Size">Section&nbsp;3.3.1</a>).
               </p>
               <p id="rfc.section.3.1.2.p.8">When necessary, entries at the end of the dynamic part of the table are dropped to reduce the size of the header table and
                  keep it under its limit.
               </p>
               <div id="rfc.figure.1"></div><pre class="drawing">                            
       &lt;--  Dynamic Part  --&gt; &lt;--  Static Part  --&gt;
       +---+-------------+---+---+------------+---+
       | 0 |     ...     | k |k+1|     ...    | n |
       +---+-------------+---+---+------------+---+
       ^                   |
       |                   V
Insertion Point       Drop Point

</pre><p class="figure">Figure 1: Header Table</p>
            </div>
            <div id="reference.set">
               <h3 id="rfc.section.3.1.3"><a href="#rfc.section.3.1.3">3.1.3</a>&nbsp;<a href="#reference.set">Reference Set</a></h3>
               <p id="rfc.section.3.1.3.p.1">A reference set is defined as an unordered set of references to entries of the header table.</p>
               <p id="rfc.section.3.1.3.p.2">The initial reference set is the empty set.</p>
               <p id="rfc.section.3.1.3.p.3">The reference set is updated during the processing of a set of header fields.</p>
               <p id="rfc.section.3.1.3.p.4">Using the differential encoding, a header field that is not present in the reference set can be encoded either with an indexed
                  representation (if the header field is present in the header table), or with a literal representation (if the header field
                  is not present in the header table).
               </p>
               <p id="rfc.section.3.1.3.p.5">A header field that is to be removed from the reference set is encoded with an indexed representation.</p>
            </div>
            <div id="header.set">
               <h3 id="rfc.section.3.1.4"><a href="#rfc.section.3.1.4">3.1.4</a>&nbsp;<a href="#header.set">Header set</a></h3>
               <p id="rfc.section.3.1.4.p.1">A header set is a group of header fields that are encoded as a whole. Each header field is a (name, value) pair.</p>
               <p id="rfc.section.3.1.4.p.2">A header set is encoded using an ordered list of zero or more header field representations. All the header field representations
                  describing a header set a grouped into a header block.
               </p>
            </div>
            <div id="header.representation">
               <h3 id="rfc.section.3.1.5"><a href="#rfc.section.3.1.5">3.1.5</a>&nbsp;<a href="#header.representation">Header Field Representation</a></h3>
               <p id="rfc.section.3.1.5.p.1">A header field can be represented either as a literal or as an index.</p>
               <p id="rfc.section.3.1.5.p.2"></p>
               <dl>
                  <dt>Literal Representation:</dt>
                  <dd>A literal representation defines a new header field. The header field name is represented either literally or as a reference
                     to an entry of the header table. The header field value is represented literally.
                  </dd>
                  <dd>Two different literal representations are provided: 
                     <ul>
                        <li>A literal representation that does not add the header field to the header table (see <a href="#literal.header.without.indexing" title="Literal Header Field without Indexing">Section&nbsp;4.3.1</a>).
                        </li>
                        <li>A literal representation that adds the header field as a new entry at the beginning of the header table (see <a href="#literal.header.with.incremental.indexing" title="Literal Header Field with Incremental Indexing">Section&nbsp;4.3.2</a>).
                        </li>
                     </ul> 
                  </dd>
                  <dt>Indexed Representation:</dt>
                  <dd>The indexed representation defines a header field as a reference in the header table (see <a href="#indexed.header.representation" title="Indexed Header Field Representation">Section&nbsp;4.2</a>).
                  </dd>
               </dl>
            </div>
            <div id="header.emission">
               <h3 id="rfc.section.3.1.6"><a href="#rfc.section.3.1.6">3.1.6</a>&nbsp;<a href="#header.emission">Header Field Emission</a></h3>
               <p id="rfc.section.3.1.6.p.1">The emission of header field is the process of adding a header field to the current set of header fields. Once an header field
                  is emitted, it can't be removed from the current set of header fields.
               </p>
               <p id="rfc.section.3.1.6.p.2">The concept of header field emission allows a decoder to know when it can pass a header field safely to a higher level on
                  the receiver side. This allows a decoder to be implemented in a streaming way, and as such to only keep in memory the header
                  table and the reference set. With such an implementation, the amount of memory used by the decoder is bounded, even in presence
                  of a very large set of header fields. The management of memory for handling very large sets of header fields can therefore
                  be deferred to the application, which may be able to process these header fields upon receiving them and thus free up memory
                  quickly.
               </p>
            </div>
         </div>
         <div id="header.set.processing">
            <h2 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2</a>&nbsp;<a href="#header.set.processing">Header Set Processing</a></h2>
            <p id="rfc.section.3.2.p.1">The processing of an encoded header set to obtain a list of header fields is defined in this section. To ensure a correct
               decoding of a header set, a decoder MUST obey the following rules.
            </p>
            <div id="header.representation.processing">
               <h3 id="rfc.section.3.2.1"><a href="#rfc.section.3.2.1">3.2.1</a>&nbsp;<a href="#header.representation.processing">Header Field Representation Processing</a></h3>
               <p id="rfc.section.3.2.1.p.1">All the header field representations contained in a header block are processed in the order in which they are presented, as
                  specified below.
               </p>
               <p id="rfc.section.3.2.1.p.2">An <em>indexed representation</em> corresponding to an entry <em>not present</em> in the reference set entails the following actions: 
               </p>
               <ul>
                  <li>The header field corresponding to the entry is emitted.</li>
                  <li>The entry is added to the reference set.</li>
               </ul>
               <p id="rfc.section.3.2.1.p.3">An <em>indexed representation</em> corresponding to an entry <em>present</em> in the reference set entails the following actions: 
               </p>
               <ul>
                  <li>The entry is removed from the reference set.</li>
               </ul>
               <p id="rfc.section.3.2.1.p.4">A <em>literal representation</em> that is <em>not added</em> to the header table entails the following action: 
               </p>
               <ul>
                  <li>The header field is emitted.</li>
               </ul>
               <p id="rfc.section.3.2.1.p.5">A <em>literal representation</em> that is <em>added</em> to the header table entails the following actions: 
               </p>
               <ul>
                  <li>The header field is emitted.</li>
                  <li>The header field is inserted at the beginning of the header table.</li>
                  <li>The new entry is added to the reference set.</li>
               </ul>
            </div>
            <div id="reference.set.emission">
               <h3 id="rfc.section.3.2.2"><a href="#rfc.section.3.2.2">3.2.2</a>&nbsp;<a href="#reference.set.emission">Reference Set Emission</a></h3>
               <p id="rfc.section.3.2.2.p.1">Once all the representations contained in a header block have been processed, the header fields that are in common with the
                  previous header set are emitted, during the reference set emission.
               </p>
               <p id="rfc.section.3.2.2.p.2">For the reference set emission, each header field contained in the reference set that has not been emitted during the processing
                  of the header block is emitted.
               </p>
            </div>
            <div id="header.set.completion">
               <h3 id="rfc.section.3.2.3"><a href="#rfc.section.3.2.3">3.2.3</a>&nbsp;<a href="#header.set.completion">Header Set Completion</a></h3>
               <p id="rfc.section.3.2.3.p.1">Once all of the header field representations have been processed, and the remaining items in the reference set have been emitted,
                  the header set is complete.
               </p>
            </div>
         </div>
         <div id="header.table.management">
            <h2 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3</a>&nbsp;<a href="#header.table.management">Header Table Management</a></h2>
            <div id="maximum.table.size">
               <h3 id="rfc.section.3.3.1"><a href="#rfc.section.3.3.1">3.3.1</a>&nbsp;<a href="#maximum.table.size">Maximum Table Size</a></h3>
               <p id="rfc.section.3.3.1.p.1">To limit the memory requirements on the decoder side, the size of the dynamic part of the header table is bounded. The size
                  of the dynamic part MUST stay lower than or equal to the value of the HTTP/2.0 setting SETTINGS_HEADER_TABLE_SIZE (see <a href="#HTTP2"><cite title="Hypertext Transfer Protocol version 2.0">[HTTP2]</cite></a>). The size of the dynamic part of the header table is the sum of the size of its entries.
               </p>
               <p id="rfc.section.3.3.1.p.2">The size of an entry is the sum of its name's length in bytes (as defined in <a href="#string.literal.representation" title="String Literal Representation">Section&nbsp;4.1.2</a>), of its value's length in bytes (<a href="#string.literal.representation" title="String Literal Representation">Section&nbsp;4.1.2</a>) and of 32 bytes. The 32 bytes are an accounting for the entry structure overhead. For example, an entry structure using
                  two 64-bits pointers to reference the name and the value and the entry, and two 64-bits integer for counting the number of
                  references to these name and value would use 32 bytes.
               </p>
               <p id="rfc.section.3.3.1.p.3">To prevent the header table size from exceeding its limit, an eviction mechanism is used (see <a href="#entry.eviction" title="Entry Eviction">Section&nbsp;3.3.3</a>). The eviction mechanism is applied in two cases: before inserting a new entry in the table, when applying a reduction of
                  the SETTINGS_HEADER_TABLE_SIZE setting value.
               </p>
            </div>
            <div id="entry.addition">
               <h3 id="rfc.section.3.3.2"><a href="#rfc.section.3.3.2">3.3.2</a>&nbsp;<a href="#entry.addition">Entry Addition</a></h3>
               <p id="rfc.section.3.3.2.p.1">The header table can be modified by adding a new entry to it. A new entry is always inserted in the dynamic part of the header
                  table, at the index 0. As a consequence, all the other entries in the table are shifted, and their index is increased by one
                  (both for the entries in the dynamic part and in the static part).
               </p>
               <p id="rfc.section.3.3.2.p.2">Before inserting a new entry in the header table, it has to be ensured that the header table size will stay lower than or
                  equal to the SETTINGS_HEADER_TABLE_SIZE limit (see <a href="#parameter.negotiation" title="Parameter Negotiation">Section&nbsp;5</a>). If not enought space is available for this new entry, the eviction mechanism (see <a href="#entry.eviction" title="Entry Eviction">Section&nbsp;3.3.3</a>) is applied until the size of the header table added to the size of the new entry is lower than or equal to the SETTINGS_HEADER_TABLE_SIZE.
               </p>
               <p id="rfc.section.3.3.2.p.3">The addition of a new entry with a size greater than the SETTINGS_HEADER_TABLE_SIZE limit is allowed. It causes all the entries
                  from the header table to be dropped and the new entry not to be added to the header table.
               </p>
            </div>
            <div id="entry.eviction">
               <h3 id="rfc.section.3.3.3"><a href="#rfc.section.3.3.3">3.3.3</a>&nbsp;<a href="#entry.eviction">Entry Eviction</a></h3>
               <p id="rfc.section.3.3.3.p.1">The size of the header table is reduced through the eviction mechanism.</p>
               <p id="rfc.section.3.3.3.p.2">While the size of dynamic part of the header table is strictly greater than its limit, the entry with the highest index in
                  the header table is dropped.
               </p>
               <p id="rfc.section.3.3.3.p.3">The eviction of one or more entries from the dynamic part of the header table cause the index of the entries in the static
                  part of the header table to be reduced.
               </p>
            </div>
         </div>
      </div>
      <div id="detailed.format">
         <h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a>&nbsp;<a href="#detailed.format">Detailed Format</a></h1>
         <div id="low-level.representation">
            <h2 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1</a>&nbsp;<a href="#low-level.representation">Low-level representations</a></h2>
            <div id="integer.representation">
               <h3 id="rfc.section.4.1.1"><a href="#rfc.section.4.1.1">4.1.1</a>&nbsp;<a href="#integer.representation">Integer representation</a></h3>
               <p id="rfc.section.4.1.1.p.1">Integers are used to represent name indexes, pair indexes or string lengths. To allow for optimized processing, an integer
                  representation always finishes at the end of a byte.
               </p>
               <p id="rfc.section.4.1.1.p.2">An integer is represented in two parts: a prefix that fills the current byte and an optional list of bytes that are used if
                  the integer value does not fit in the prefix. The number of bits of the prefix (called N) is a parameter of the integer representation.
               </p>
               <p id="rfc.section.4.1.1.p.3">The N-bit prefix allows filling the current byte. If the value is small enough (strictly less than 2<sup>N</sup>-1), it is encoded within the N-bit prefix. Otherwise all the bits of the prefix are set to 1 and the value is encoded using
                  an <a href="http://en.wikipedia.org/wiki/Variable-length_quantity">unsigned variable length integer</a> representation.
               </p>
               <p id="rfc.section.4.1.1.p.4">The algorithm to represent an integer I is as follows: </p>
               <div id="rfc.figure.u.1"></div><pre class="inline">If I &lt; 2^N - 1, encode I on N bits
Else
    encode 2^N - 1 on N bits
    I = I - (2^N - 1)
    While I &gt;= 128
         Encode (I % 128 + 128) on 8 bits
         I = I / 128
    encode (I) on 8 bits
                        </pre><div id="integer.representation.example1">
                  <h4 id="rfc.section.4.1.1.1"><a href="#rfc.section.4.1.1.1">4.1.1.1</a>&nbsp;<a href="#integer.representation.example1">Example 1: Encoding 10 using a 5-bit prefix</a></h4>
                  <p id="rfc.section.4.1.1.1.p.1">The value 10 is to be encoded with a 5-bit prefix. </p>
                  <ul>
                     <li>10 is less than 31 (= 2<sup>5</sup> - 1) and is represented using the 5-bit prefix.
                     </li>
                  </ul>
                  <div id="rfc.figure.u.2"></div><pre class="inline">  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| X | X | X | 0 | 1 | 0 | 1 | 0 |   10 stored on 5 bits
+---+---+---+---+---+---+---+---+
</pre></div>
               <div id="integer.representation.example2">
                  <h4 id="rfc.section.4.1.1.2"><a href="#rfc.section.4.1.1.2">4.1.1.2</a>&nbsp;<a href="#integer.representation.example2">Example 2: Encoding 1337 using a 5-bit prefix</a></h4>
                  <p id="rfc.section.4.1.1.2.p.1">The value I=1337 is to be encoded with a 5-bit prefix. </p>
                  <ul class="empty">
                     <li>1337 is greater than 31 (= 2<sup>5</sup> - 1).
                     </li>
                     <li>
                        <ul class="empty">
                           <li>The 5-bit prefix is filled with its max value (31).</li>
                        </ul> 
                     </li>
                     <li>I = 1337 - (2<sup>5</sup> - 1) = 1306.
                     </li>
                     <li>
                        <ul class="empty">
                           <li>I (1306) is greater than or equal to 128, the while loop body executes:</li>
                           <li>
                              <ul class="empty">
                                 <li>I % 128 == 26</li>
                                 <li>26 + 128 == 154</li>
                                 <li>154 is encoded in 8 bits as: 10011010</li>
                                 <li>I is set to 10 (1306 / 128 == 10)</li>
                                 <li>I is no longer greater than or equal to 128, the while loop terminates.</li>
                              </ul> 
                           </li>
                           <li>I, now 10, is encoded on 8 bits as: 00001010</li>
                        </ul> 
                     </li>
                     <li>The process ends.</li>
                  </ul>
                  <div id="rfc.figure.u.3"></div><pre class="inline">  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| X | X | X | 1 | 1 | 1 | 1 | 1 |  Prefix = 31, I = 1306
| 1 | 0 | 0 | 1 | 1 | 0 | 1 | 0 |  1306&gt;=128, encode(154), I=1306/128
| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 |  10&lt;128, encode(10), done
+---+---+---+---+---+---+---+---+
</pre></div>
            </div>
            <div id="string.literal.representation">
               <h3 id="rfc.section.4.1.2"><a href="#rfc.section.4.1.2">4.1.2</a>&nbsp;<a href="#string.literal.representation">String Literal Representation</a></h3>
               <p id="rfc.section.4.1.2.p.1">Header field names and header field values are encoded as sequences of bytes. A header field name or a header field value
                  is encoded in two parts: 
               </p>
               <ol>
                  <li>The number of bytes in the sequence, represented as a variable-length-quantity (<a href="#integer.representation" title="Integer representation">Section&nbsp;4.1.1</a>).
                  </li>
                  <li>The sequence of bytes representing the header field name or value.</li>
               </ol>
            </div>
         </div>
         <div id="indexed.header.representation">
            <h2 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2</a>&nbsp;<a href="#indexed.header.representation">Indexed Header Field Representation</a></h2>
            <p id="rfc.section.4.2.p.1">An indexed header field representation identifies an entry in the header table. The entry is emitted and added to the reference
               set if it is not currently in the reference set. The entry is removed from the reference set if it is present in the reference
               set.
            </p>
            <div id="rfc.figure.2"></div><pre class="inline">  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 1 |        Index (7+)         |
+---+---------------------------+
</pre><p class="figure">Figure 2: Indexed Header Field</p>
            <p id="rfc.section.4.2.p.3">This representation starts with the '1' 1-bit pattern, followed by the index of the matching pair, represented as an integer
               with a 7-bit prefix.
            </p>
         </div>
         <div id="literal.header.representation">
            <h2 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3</a>&nbsp;<a href="#literal.header.representation">Literal Header Field Representation</a></h2>
            <p id="rfc.section.4.3.p.1">Literal header field representations contain a literal header field value. Header field names are either provided as a literal
               or by reference to an existing header table entry.
            </p>
            <p id="rfc.section.4.3.p.2">Literal representations all result in the emission of a header field when decoded.</p>
            <div id="literal.header.without.indexing">
               <h3 id="rfc.section.4.3.1"><a href="#rfc.section.4.3.1">4.3.1</a>&nbsp;<a href="#literal.header.without.indexing">Literal Header Field without Indexing</a></h3>
               <p id="rfc.section.4.3.1.p.1">A literal header field without indexing causes the emission of a header field without altering the header table.</p>
               <div id="rfc.figure.3"></div><pre class="inline">  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 1 |      Index (6+)       |
+---+---+---+-------------------+
|       Value Length (8+)       |
+-------------------------------+
| Value String (Length octets)  |
+-------------------------------+
</pre><p class="figure">Figure 3: Literal Header Field without Indexing - Indexed Name</p>
               <div id="rfc.figure.4"></div><pre class="inline">  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 1 |           0           |
+---+---+---+-------------------+
|       Name Length (8+)        |
+-------------------------------+
|  Name String (Length octets)  |
+-------------------------------+
|       Value Length (8+)       |
+-------------------------------+
| Value String (Length octets)  |
+-------------------------------+
</pre><p class="figure">Figure 4: Literal Header Field without Indexing - New Name</p>
               <p id="rfc.section.4.3.1.p.4">This representation starts with the '01' 2-bit pattern.</p>
               <p id="rfc.section.4.3.1.p.5">If the header field name matches the header field name of a (name, value) pair stored in the Header Table, the index of the
                  pair increased by one (index + 1) is represented as an integer with a 6-bit prefix. Note that if the index is strictly below
                  63, one byte is used.
               </p>
               <p id="rfc.section.4.3.1.p.6">If the header field name does not match a header field name entry, the value 0 is represented on 6 bits followed by the header
                  field name (<a href="#string.literal.representation" title="String Literal Representation">Section&nbsp;4.1.2</a>).
               </p>
               <p id="rfc.section.4.3.1.p.7">The header field name representation is followed by the header field value represented as a literal string as described in <a href="#string.literal.representation" title="String Literal Representation">Section&nbsp;4.1.2</a>.
               </p>
            </div>
            <div id="literal.header.with.incremental.indexing">
               <h3 id="rfc.section.4.3.2"><a href="#rfc.section.4.3.2">4.3.2</a>&nbsp;<a href="#literal.header.with.incremental.indexing">Literal Header Field with Incremental Indexing</a></h3>
               <p id="rfc.section.4.3.2.p.1">A literal header field with incremental indexing adds a new entry to the header table.</p>
               <div id="rfc.figure.5"></div><pre class="inline">  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 |      Index (6+)       |
+---+---+---+-------------------+
|       Value Length (8+)       |
+-------------------------------+
| Value String (Length octets)  |
+-------------------------------+
</pre><p class="figure">Figure 5: Literal Header Field with Incremental Indexing -                         Indexed Name</p>
               <div id="rfc.figure.6"></div><pre class="inline">  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 |           0           |
+---+---+---+-------------------+
|       Name Length (8+)        |
+-------------------------------+
|  Name String (Length octets)  |
+-------------------------------+
|       Value Length (8+)       |
+-------------------------------+
| Value String (Length octets)  |
+-------------------------------+
</pre><p class="figure">Figure 6: Literal Header Field with Incremental Indexing -                         New Name</p>
               <p id="rfc.section.4.3.2.p.4">This representation starts with the '00' 2-bit pattern.</p>
               <p id="rfc.section.4.3.2.p.5">If the header field name matches the header field name of a (name, value) pair stored in the Header Table, the index of the
                  pair increased by one (index + 1) is represented as an integer with a 6-bit prefix. Note that if the index is strictly below
                  63, one byte is used.
               </p>
               <p id="rfc.section.4.3.2.p.6">If the header field name does not match a header field name entry, the value 0 is represented on 6 bits followed by the header
                  field name (<a href="#string.literal.representation" title="String Literal Representation">Section&nbsp;4.1.2</a>).
               </p>
               <p id="rfc.section.4.3.2.p.7">The header field name representation is followed by the header field value represented as a literal string as described in <a href="#string.literal.representation" title="String Literal Representation">Section&nbsp;4.1.2</a>.
               </p>
            </div>
         </div>
      </div>
      <div id="parameter.negotiation">
         <h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a>&nbsp;<a href="#parameter.negotiation">Parameter Negotiation</a></h1>
         <p id="rfc.section.5.p.1">When a decompressor wishes to change the size of the header table, it sends a SETTINGS frame with a new value for the SETTINGS_HEADER_TABLE_SIZE.
            Upon receipt of this SETTINGS frame, the compressor must modify the header table accordingly (including any resulting evictions)
            as soon as possible.
         </p>
         <p id="rfc.section.5.p.2">After modifying the header table and performing any associated evictions, the recipient of the SETTINGS frame MUST respond
            with a SETTINGS frame in which the ACK flag is set before sending any additional HEADERS, PUSH_PROMISE, or CONTINUATION frames.
         </p>
      </div>
      <div id="Security">
         <h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a>&nbsp;<a href="#Security">Security Considerations</a></h1>
         <p id="rfc.section.6.p.1">This compressor exists to solve security issues present in stream compressors such as DEFLATE whereby the compression context
            can be efficiently probed to reveal secrets. A conformant implementation of this specification should be fairly safe against
            that kind of attack, as the reaping of any information from the compression context requires more work than guessing and verifying
            the plaintext data directly with the server. As with any secret, however, the longer the length of the secret, the more difficult
            the secret is to guess. It is inadvisable to have short cookies that are relied upon to remain secret for any duration of
            time.
         </p>
         <p id="rfc.section.6.p.2">A proper security-conscious implementation will also need to prevent timing attacks by ensuring that the amount of time it
            takes to do string comparisons is always a function of the total length of the strings, and not a function of the number of
            matched characters.
         </p>
         <p id="rfc.section.6.p.3">Another common security problem is when the remote endpoint successfully causes the local endpoint to exhaust its memory.
            This compressor attempts to deal with the most obvious ways that this could occur by limiting both the peak and the steady-state
            amount of memory consumed in the compressor state, by providing ways for the application to consume/flush the emitted header
            fields in small chunks, and by considering overhead in the state size calculation. Implementors must still be careful in the
            creation of APIs to an implementation of this compressor by ensuring that header field keys and values are either emitted
            as a stream, or that the compression implementation have a limit on the maximum size of a key or value. Failure to implement
            these kinds of safeguards may still result in a scenario where the local endpoint exhausts its memory.
         </p>
      </div>
      <h1 id="rfc.references"><a id="rfc.section.7" href="#rfc.section.7">7.</a> References
      </h1>
      <h2 id="rfc.references.1"><a href="#rfc.section.7.1" id="rfc.section.7.1">7.1</a> Normative References
      </h2>
      <table>
         <tr>
            <td class="reference"><b id="HTTP2">[HTTP2]</b></td>
            <td class="top">Belshe, M., Peon, R., Thomson, M., and A. Melnikov, “<a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-06">Hypertext Transfer Protocol version 2.0</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-http2-06 (work in progress), August&nbsp;2013.
            </td>
         </tr>
      </table>
      <h2 id="rfc.references.2"><a href="#rfc.section.7.2" id="rfc.section.7.2">7.2</a> Informative References
      </h2>
      <table>
         <tr>
            <td class="reference"><b id="CRIME">[CRIME]</b></td>
            <td class="top">Rizzo, J. and T. Duong, “<a href="https://docs.google.com/a/twist.com/presentation/d/11eBmGiHbYcHR9gL5nDyZChu_-lCa2GizeuOfaLU2HOU/edit#slide=id.g1eb6c1b5_3_6">The Crime Attack</a>”, September&nbsp;2012, &lt;<a href="https://docs.google.com/a/twist.com/presentation/d/11eBmGiHbYcHR9gL5nDyZChu_-lCa2GizeuOfaLU2HOU/edit#slide=id.g1eb6c1b5_3_6">https://docs.google.com/a/twist.com/presentation/d/11eBmGiHbYcHR9gL5nDyZChu_-lCa2GizeuOfaLU2HOU/edit#slide=id.g1eb6c1b5_3_6</a>&gt;.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="PERF1">[PERF1]</b></td>
            <td class="top">Belshe, M., “<a href="http://www.ietf.org/proceedings/83/slides/slides-83-httpbis-3">IETF83: SPDY and What to Consider for HTTP/2.0</a>”, March&nbsp;2012, &lt;<a href="http://www.ietf.org/proceedings/83/slides/slides-83-httpbis-3">http://www.ietf.org/proceedings/83/slides/slides-83-httpbis-3</a>&gt;.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="PERF2">[PERF2]</b></td>
            <td class="top">McManus, P., “<a href="http://bitsup.blogspot.com/2011/09/spdy-what-i-like-about-you.html">SPDY: What I Like About You</a>”, September&nbsp;2011, &lt;<a href="http://bitsup.blogspot.com/2011/09/spdy-what-i-like-about-you.html">http://bitsup.blogspot.com/2011/09/spdy-what-i-like-about-you.html</a>&gt;.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="SPDY">[SPDY]</b></td>
            <td class="top">Belshe, M. and R. Peon, “<a href="http://tools.ietf.org/html/draft-mbelshe-httpbis-spdy">SPDY Protocol</a>”, February&nbsp;2012, &lt;<a href="http://tools.ietf.org/html/draft-mbelshe-httpbis-spdy">http://tools.ietf.org/html/draft-mbelshe-httpbis-spdy</a>&gt;.
            </td>
         </tr>
      </table>
      <div class="avoidbreak">
         <h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
         <p><b>Roberto Peon</b><br>Google, Inc<br>Email: <a href="mailto:fenix@google.com">fenix@google.com</a></p>
         <p><b>Hervé Ruellan</b><br>Canon CRF<br>Email: <a href="mailto:herve.ruellan@crf.canon.fr">herve.ruellan@crf.canon.fr</a></p>
      </div>
      <div>
         <h1 id="rfc.section.A" class="np"><a href="#rfc.section.A">A.</a>&nbsp;Change Log (to be removed by RFC Editor before publication
         </h1>
         <div id="changes.since.draft-ietf-httpbis-header-compression-03">
            <h2 id="rfc.section.A.1"><a href="#rfc.section.A.1">A.1</a>&nbsp;<a href="#changes.since.draft-ietf-httpbis-header-compression-03">Since draft-ietf-httpbis-header-compression-03</a></h2>
            <ul>
               <li>Initial header table always accessible.</li>
               <li>Combined initial header tables.</li>
               <li>Removed substitution.</li>
            </ul>
         </div>
         <div>
            <h2 id="rfc.section.A.2"><a href="#rfc.section.A.2">A.2</a>&nbsp;Since draft-ietf-httpbis-header-compression-02
            </h2>
            <ul>
               <li>Corrected error in integer encoding pseudocode.</li>
            </ul>
         </div>
         <div>
            <h2 id="rfc.section.A.3"><a href="#rfc.section.A.3">A.3</a>&nbsp;Since draft-ietf-httpbis-header-compression-01
            </h2>
            <p id="rfc.section.A.3.p.1"></p>
            <ul>
               <li>Refactored of Header Encoding Section: split definitions and processing rule.</li>
               <li>Backward incompatible change: Updated reference set management as per issue #214. This changes how the interaction between
                  the reference set and eviction works. This also changes the working of the reference set in some specific cases.
               </li>
               <li>Backward incompatible change: modified initial header list, as per issue #188.</li>
               <li>Added example of 32 bytes entry structure (issue #191).</li>
               <li>Added Header Set Completion section. Reflowed some text. Clarified some writing which was akward. Added text about duplicate
                  header entry encoding. Clarified some language w.r.t Header Set. Changed x-my-header to mynewheader. Added text in the HeaderEmission
                  section indicating that the application may also be able to free up memory more quickly. Added information in Security Considerations
                  section.
               </li>
            </ul>
         </div>
         <div>
            <h2 id="rfc.section.A.4"><a href="#rfc.section.A.4">A.4</a>&nbsp;Since draft-ietf-httpbis-header-compression-01
            </h2>
            <p id="rfc.section.A.4.p.1"></p>
            <ul class="empty">
               <li>Fixed bug/omission in integer representation algorithm.</li>
               <li>Changed the document title.</li>
               <li>Header matching text rewritten.</li>
               <li>Changed the definition of header emission.</li>
               <li>Changed the name of the setting which dictates how much memory the compression context should use.</li>
               <li>Removed "specific use cases" section</li>
               <li>Corrected erroneous statement about what index can be contained in one byte</li>
               <li>Added descriptions of opcodes</li>
               <li>Removed security claims from introduction.</li>
            </ul>
         </div>
      </div>
      <div id="static.headers">
         <h1 id="rfc.section.B"><a href="#rfc.section.B">B.</a>&nbsp;<a href="#static.headers">Static Header Field Table</a></h1>
         <p id="rfc.section.B.p.1"><span class="comment" id="rfc.comment.1">[<a href="#rfc.comment.1" class="smpl">rfc.comment.1</a>: The table in this section should be updated based on statistical analysis of header field names frequency and specific HTTP
               2.0 header field rules (like removal of some header fields).]</span> 
         </p>
         <p id="rfc.section.B.p.2">The following table lists the pre-defined header fields that make-up the static part of a header table used to encode or decode
            a set of header fields.
         </p>
         <div id="rfc.table.1">
            <div id="static.headers.table"></div>
            <table class="tt full center" cellpadding="3" cellspacing="0">
               <caption>Table 1: Static Header Field Table</caption>
               <thead>
                  <tr>
                     <th>Index</th>
                     <th>Header Field Name</th>
                     <th>Header Field Value</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td class="left">0</td>
                     <td class="left">:method</td>
                     <td class="left">GET</td>
                  </tr>
                  <tr>
                     <td class="left">1</td>
                     <td class="left">:method</td>
                     <td class="left">POST</td>
                  </tr>
                  <tr>
                     <td class="left">2</td>
                     <td class="left">:scheme</td>
                     <td class="left">http</td>
                  </tr>
                  <tr>
                     <td class="left">3</td>
                     <td class="left">:scheme</td>
                     <td class="left">https</td>
                  </tr>
                  <tr>
                     <td class="left">4</td>
                     <td class="left">:path</td>
                     <td class="left">/</td>
                  </tr>
                  <tr>
                     <td class="left">5</td>
                     <td class="left">:status</td>
                     <td class="left">200</td>
                  </tr>
                  <tr>
                     <td class="left">6</td>
                     <td class="left">:authority</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">7</td>
                     <td class="left">accept-charset</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">8</td>
                     <td class="left">accept-encoding</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">9</td>
                     <td class="left">accept-language</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">10</td>
                     <td class="left">accept-ranges</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">11</td>
                     <td class="left">accept</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">12</td>
                     <td class="left">access-control-allow-origin</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">13</td>
                     <td class="left">age</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">14</td>
                     <td class="left">allow</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">15</td>
                     <td class="left">authorization</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">16</td>
                     <td class="left">cache-control</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">17</td>
                     <td class="left">content-disposition</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">18</td>
                     <td class="left">content-encoding</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">19</td>
                     <td class="left">content-language</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">20</td>
                     <td class="left">content-length</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">21</td>
                     <td class="left">content-location</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">22</td>
                     <td class="left">content-range</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">23</td>
                     <td class="left">content-type</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">24</td>
                     <td class="left">cookie</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">25</td>
                     <td class="left">date</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">26</td>
                     <td class="left">etag</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">27</td>
                     <td class="left">expect</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">28</td>
                     <td class="left">expires</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">29</td>
                     <td class="left">from</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">30</td>
                     <td class="left">host</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">31</td>
                     <td class="left">if-match</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">32</td>
                     <td class="left">if-modified-since</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">33</td>
                     <td class="left">if-none-match</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">34</td>
                     <td class="left">if-range</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">35</td>
                     <td class="left">if-unmodified-since</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">36</td>
                     <td class="left">last-modified</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">37</td>
                     <td class="left">link</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">38</td>
                     <td class="left">location</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">39</td>
                     <td class="left">max-forwards</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">40</td>
                     <td class="left">proxy-authenticate</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">41</td>
                     <td class="left">proxy-authorization</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">42</td>
                     <td class="left">range</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">43</td>
                     <td class="left">referer</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">44</td>
                     <td class="left">refresh</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">45</td>
                     <td class="left">retry-after</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">46</td>
                     <td class="left">server</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">47</td>
                     <td class="left">set-cookie</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">48</td>
                     <td class="left">strict-transport-security</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">49</td>
                     <td class="left">user-agent</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">50</td>
                     <td class="left">vary</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">51</td>
                     <td class="left">via</td>
                     <td class="left"></td>
                  </tr>
                  <tr>
                     <td class="left">52</td>
                     <td class="left">www-authenticate</td>
                     <td class="left"></td>
                  </tr>
               </tbody>
            </table>
         </div>
         <p id="rfc.section.B.p.3">The table give the index of each entry inside the static part of the header table. The full index of each entry, to be used
            for encoding a reference to this entry, is computed by adding the number of entries in the dynamic part of the header table
            to this index.
         </p>
      </div>
      <div id="example">
         <h1 id="rfc.section.C"><a href="#rfc.section.C">C.</a>&nbsp;<a href="#example">Example</a></h1>
         <p id="rfc.section.C.p.1">Here is an example that illustrates different representations and how tables are updated. <span class="comment" id="rfc.comment.2">[<a href="#rfc.comment.2" class="smpl">rfc.comment.2</a>: This section needs to be updated to better reflect the new processing of header fields, and include more examples.]</span> 
         </p>
         <div>
            <h2 id="rfc.section.C.1"><a href="#rfc.section.C.1">C.1</a>&nbsp;First header set
            </h2>
            <p id="rfc.section.C.1.p.1">The first header set to represent is the following: </p>
            <div id="rfc.figure.u.4"></div><pre class="text">:path, /my-example/index.html
user-agent, my-user-agent
mynewheader, first
</pre><p> The header table is empty, all header fields are represented as literal header fields with indexing. The 'mynewheader' header
               field name is not in the header table and is encoded literally. This gives the following representation: 
            </p>
            <div id="rfc.figure.u.5"></div><pre class="text">0x04      (literal header with incremental indexing, name index = 3)
0x16      (header field value string length = 22)
/my-example/index.html
0x0D      (literal header with incremental indexing, name index = 12)
0x0D      (header field value string length = 13)
my-user-agent
0x00      (literal header with incremental indexing, new name)
0x0B      (header field name string length = 11)
mynewheader
0x05      (header field value string length = 5)
first
</pre><p> The header table is as follows after the processing of these header fields: </p>
            <div id="rfc.figure.u.6"></div><pre class="inline">Header table
+---------+----------------+---------------------------+
|  Index  | Header Name    | Header Value              |
+---------+----------------+---------------------------+
|    0    | mynewheader    | first                     | added header
+---------+----------------+---------------------------+
|    1    | user-agent     | my-user-agent             | added header
+---------+----------------+---------------------------+
|    2    | :path          | /my-example/index.html    | added header
+---------+----------------+---------------------------+
|    3    | :scheme        | http                      |
+---------+----------------+---------------------------+
|    4    | :scheme        | https                     |
+---------+----------------+---------------------------+
|   ...   | ...            | ...                       |
+---------+----------------+---------------------------+
|   32    | via            |                           |
+---------+----------------+---------------------------+
</pre><p> As all the header fields in the first header set are indexed in the header table, all are kept in the reference set of header
               fields, which is: 
            </p>
            <div id="rfc.figure.u.7"></div><pre class="inline">Reference Set:
:path, /my-example/index.html
user-agent, my-user-agent
mynewheader, first
</pre></div>
         <div>
            <h2 id="rfc.section.C.2"><a href="#rfc.section.C.2">C.2</a>&nbsp;Second header set
            </h2>
            <p id="rfc.section.C.2.p.1">The second header set to represent is the following: </p>
            <div id="rfc.figure.u.8"></div><pre class="text">:path, /my-example/resources/script.js
user-agent, my-user-agent
mynewheader, second
</pre><p> Comparing this second header set to the reference set, the first and third header fields are from the reference set are not
               present in this second header set and must be removed. In addition, in this new set, the first and third header fields have
               to be encoded. The path header field is represented as a literal header field without indexing. The mynewheader will be represented
               as a literal header field with incremental indexing. 
            </p>
            <div id="rfc.figure.u.9"></div><pre class="text">0x80       (indexed header, index = 0: removal from reference set)
0x82       (indexed header, index = 2: removal from reference set)
0x43       (literal header, without indexing, name index = 2)
0x1f       (header field value string length = 31)
/my-example/resources/script.js
0x01       (literal header, incremental indexing, name index = 0)
0x06       (header field value string length = 6)
second
</pre><p> The header table is updated as follow: </p>
            <div id="rfc.figure.u.10"></div><pre class="inline">Header table
+---------+----------------+---------------------------+
|  Index  | Header Name    | Header Value              |
+---------+----------------+---------------------------+
|    0    | mynewheader    | second                    | added header
+---------+----------------+---------------------------+
|    1    | mynewheader    | first                     |
+---------+----------------+---------------------------+
|    2    | user-agent     | my-user-agent             |
+---------+----------------+---------------------------+
|    3    | :path          | /my-example/index.html    |
+---------+----------------+---------------------------+
|    4    | :scheme        | http                      |
+---------+----------------+---------------------------+
|    5    | :scheme        | https                     |
+---------+----------------+---------------------------+
|   ...   | ...            | ...                       |
+---------+----------------+---------------------------+
|   33    | via            |                           |
+---------+----------------+---------------------------+
</pre><p> All the header fields in this second header set are indexed in the header table, therefore, all are kept in the reference
               set of header fields, which becomes: 
            </p>
            <div id="rfc.figure.u.11"></div><pre class="inline">Reference Set:
:path, /my-example/resources/script.js
user-agent, my-user-agent
mynewheader, second
</pre></div>
      </div>
   </body>
</html>