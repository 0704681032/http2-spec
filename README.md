# 超文本传输协议版本 2
### IETF HTTP2草案最新版

## 摘要

 本规范描述了一种优化的超文本传输协议(HTTP).HTTP/2通过引进首部字段压缩以及多路复用来更有效利用网络资源、减少感知延迟。另外同样介绍了服务器主动推送规范。

本文档保持对HTTP/1.1的后向兼容，HTTP的现有的语义保持不变。

## 1 介绍

超文本传输协议（HTTP）是一个非常成功的协议。 然而，HTTP/1.1 是针对90年代的情况而不是现代web应用的性能而设计。因此它对现代应用程序的性能产生负面影响。

特别是，HTTP/1.0只允许一个请求建立在给定的连接上, HTTP/1.1管道只部分解决了请求并发和对头阻塞的问题.因此客户端需要通过多个请求多次请求服务器以减少延迟。

此外，HTTP/1.1的报头字段经常重复和冗长，其中，为了产生更多或更大的网络数据包，可能会导致小的初始TCP拥塞窗口来快速填充。 当多个请求在一个新的TCP连接进行可能会导致过度的延迟。

该文通过定义一个基础连接的HTTP的语义优化的映射来解决这些问题。 具体地，它允许对请求和响应消息建立在同一连接，并使用高效率编码的HTTP报头字段。 它还允许请求的优先级，让更多的重要的要求更快速的完成，进一步提高了性能。

最终协议被设计为对网络更友好，因为相对HTTP/1.x使用了更少的连接。 这意味着与其他流更少的竞争和更长时间的连接,从而更有效地利用可用的网络容量。

最后，这种封装也通过使用二进制消息帧使信息处理更具扩展性。

## 2 HTTP / 2协议概述

HTTP/2 提供了对HTTP语义的优化运输。HTTP/2支持所有HTTP／1.1的核心特征，并且在某些方面更高效。

HTTP/2中基本的协议单位是帧。每个帧都有不同的类型和用途。例如，报头(HEADERS)和数据(DATA)帧组成了基本的HTTP 请求和响应；其他帧例如 设置(SETTINGS),窗口更新(WINDOW_UPDATE), 和推送承诺(PUSH_PROMISE)是用来支持HTTP/2的其他功能。

请求多路复用是通过给每个HTTP请求响应分配在一个流上实现的。流在很大程度上是相互独立的，因此一个请求上的阻塞或终止并不会影响其他请求的处理。

流量控制和优先级能确保正确使用复用流。流量控制确保数据只可以被传播的接收者使用。优先级能确保有限的资源能被首先传送。

HTTP/2添加了一种新的交互模式，即服务器能推送消息给客户端。服务器推送允许服务端预测客户端需要来发送数据给客户端，交换网络使用来阻止潜在的延迟增长。服务器通过复用一个以PUSH_PROMISE帧发送的请求来实现。然后服务端可以在一个单独的流里面发送响应给这个合成的请求。

帧包含的HTTP报头字段是被压缩的。HTTP请求可能是高度冗余的，因此压缩能显著见效请求和响应的大小。

## 文档结构

HTTP/2协议被分为以下两个部分：

 - Starting HTTP/2 covers how an HTTP/2 connection is
 - 启动HTTP/2包含了一个HTTP/2连接是如何初始化的。

帧和流层描述了 HTTP/2流是如何建立并形成复用流的。

帧和错误码定义了HTTP/2中使用的流和错误类型的详细内容。

HTTP寻址和拓展需求描述了HTTP语义化是如何由帧和流表达的。

虽然一些帧和流层的概念是与HTTP隔离的，它的意图并不是定义一个完全通用的帧层。这些帧和流层是为了HTTP协议和服务端推送的需求定制的。

## 约定和术语

文档中出现的关键字“`必须`”,“`绝对不能`”，“`要求`”，“`应`”，“`不应`”，“`应该`”，“`不应该`”，“`建议`”，“`或许`”及“`可选`”的可在此找到解释RFC 2119

所有的数值都是按网络字节顺序。值是无符号的除非有另外说明。按情况提供十进制或十六进制的文本值。十六进制以前缀0x来区分。

文中术语包括：

客户端：发起HTTP/2请求的端点
连接：在两个端点之间的传输层级别的连接
连接错误：HTTP/2连接整个过程中发生的错误
端点：连接的客户端或服务器
帧：HTTP/2.0通信连接中的最小单元，包括根据帧类型结构的字节的报头和可变长度的序列
对等端：一个端点。当讨论特定的端点时，“对等端”指的是讨论的主题的远程端点
接收端：正在接收帧的端点
发送端：正在传输帧的端点
服务端：不是启动HTTP/2连接的端点
流：一个双向字节帧流穿过HTTP/2连接中的虚拟通道
流错误：一个HTTP/2流中的错误

## 3 启动HTTP/2

一个HTTP/2连接是运行在TCP连接上的应用层协议。客户端是TCP连接发起者。

HTTP/2使用与HTTP/1.1相同的"http" and "https" 资源标识符(URI)。使用相同的默认端口："http"80端口及“https”443端口。因此，实现对例如`http://example.org/foo`或`https://example.com/bar`目标资源的URI请求处理需要首先确定上游服务端(当前客户端希望建立连接的对等端)是否支持HTTP/2。

检测“http”及“https”的URIs是否支持HTTP/2的方法是不一样的。检测"http" URIs在中描述。检测"https" URIs在中描述。

### 3.1 HTTP/2版本定义

文档中定义的协议用字符"h2"标记。这种方式用在HTTP/1.1的升级字段、TLS 应用层协议协商扩展字段以及其他需要定义协议的地方。当在定义ALPN协议(序列化的字节)中序列化时，"h2"字符使用UTF-8编码。

协定"h2"用于文档中的传输、安全、帧及语义化消息部分。

**TODO**

### 3.2 Starting HTTP/2 for "http" URIs

客户端发起“http” URI请求不支持HTTP/2的使用HTTP升级机制。客户端发起一个http1.1请求，其中包含识别HTTP/2的升级头部字段与h2令牌。HTTP/1.1必须包含一个确切的HTTP2-Settings中的头部字段。

例如：

```
GET /default.htm HTTP/1.1
Host: server.example.com
Connection: Upgrade, HTTP2-Settings
Upgrade: h2c
HTTP2-Settings: <base64url encoding of HTTP/2 SETTINGS payload>
```

包含主体内容的请求必须在客户端能发送HTTP/2帧前全部发送。这意味着一个大的请求实例能阻塞连接的使用直到其全部被发送。

如果一个请求的并发后续请求是重要的，那么一个小的请求可以用来执行升级到HTTP/2,消耗一个额外的往返成本。

不支持HTTP/2的服务端对请求返回一个不包含升级的头部字段的响应：

```
HTTP/1.1 200 OK
Content-Length: 243
Content-Type: text/html
...
```

支持HTTP/2的服务端可以返回一个101(转换协议)响应来接受升级请求。在101空内容响应终止后，服务端可以开始发送HTTP/2帧。这些帧必须包含一个标示升级的响应。

```
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: h2

[ HTTP/2 connection ...
```

第一个被服务端发送的HTTP/2帧是一个设置(SETTINGS)帧。在收到101响应后，客户端发送一个包含设置(SETTINGS)帧的连接序言。

HTTP/1.1最初用来升级的请求用1来标示流并将赋予最高优先级。流1对发送到服务端的客户端是隐式半封闭的，因为这个请求已经以一个HTTP/1.1请求完成了。HTTP/2连接开始后,流1在响应中使用。

#### 3.2.1 HTTP2-Settings Header Field

从HTTP/1.1升级到HTTP/2的请求必须包含一个确切的HTTP2-Settings头部字段。HTTP2-Settings头部字段是一个包含管理HTTP/2连接参数的逐跳头部字段。如果没有此头部字段，服务端必须拒绝升级。

```
HTTP2-Settings    = token68
```

这个HTTP2-Settings头部字段的内容是设置(SETTINGS)帧的有效载体，使用base64url字符编码(URL及文件名安全的Base64编码，编码描述在RFC4648中。

客户端必须包含以下设置(SETTINGS) 参数：

最大连接数设置
初始化窗口大小设置

作为一个逐跳的报文头部字段，当升级到HTTP/2时，此连接头部字段必须包含一个HTTP2设置(HTTP2-Settings)的值。

服务端就像对任何其他设置(SETTINGS)帧一样对这些值进行解码。因为101响应的隐式声明，对这些设置参数的确认不是必须的。这些升级请求中的值使得协议不需要上述设置参数的默认值，同时使客户端有机会提供其他优先参数来从服务端获取任何帧。

### 3.3 Starting HTTP/2 for "https" URIs

客户端发起“https”的URI请求无法预知服务端是否支持HTTP/2的使用TLS与TLSALP应用层协议协商扩展。

TSL协议一旦完成，客户端和服务端都可以发送连接序言。

### 3.4 Starting HTTP/2 with Prior Knowledge

客户端可以通过其他方式判断服务端是否支持HTTP/2。例如，AltSvc定义一种机制让HTTP头字段进行广播。客户端可以对支持HTTP/2的服务端在连接序言之后立即发送HTTP/2帧。服务端可以通过连接序言中的“PRI”方法来区分这种连接。这种对"http"URI改变的唯一影响是，支持HTTP/2的服务端对“https”URI需要支持TLS中的协商扩展。

对HTTP/2之前的支持并不是强烈信号表明一个给定的服务器会在以后的连接中支持HTTP/2。服务器配置有可能改变或者集群中不同服务器配置有差异。拦截代理(又叫“透明”代理)是另一个可能得原因。

###  3.5 HTTP/2 Connection Preface

在建立TCP连接并且检测到HTTP/2会被各个对等端使用后，每个端点必须发送一个连接序言最终确认和作为建立HTTP/2连接的初始设置参数。

客户端连接序言以24个字节的序列开始，以十六进制表示是：

```
0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a
```

(字符串PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n)。这个序列后跟着一个设置帧。客户端在收到101转换协议响应(升级成功指示)后马上发送客户端连接序言，或者作为TLS连接的第一个应用数据字节。如果在对服务器支持HTTP/2具有先验知识的情况下启动HTTP/2连接，客户端连接序言在连接建立后就发送。

客户端连接序言是这样选择的：大部分的HTTP/1.1或者HTTP/1.0服务端以及中介者不试图进一步处理帧。注意这并不能解决TALKING中提到的问题。

服务端连接序言仅包含一个必须在HTTP/2连接中首个发送的设置(SETTINGS) 帧 。

为了避免不必要的延迟，允许客户端在发送客户端连接序言之后立即发送其他额外的帧，不需要等待收到服务端连接序言。不过需要注意的是，服务端连接序言设置(SETTINGS)帧可能包含一些关于期望客户端如何与服务端通信的所必须修改的参数。在收到这些设置(SETTINGS)帧之后，客户端应当遵守任何建立的参数。

任意一个端点没有以一个有效的连接序言开始，客户端以及服务端必须终止TCP连接。如果端点并没有使用HTTP/2此时超时GOAWAY 帧可能可以省略。

## 4 HTTP Frames

HTTP/2连接一旦建立，端点之间可以马上交换数据帧。

### 4.1 Frame Format

所有的帧以8字节的头部开始并且跟着0-16,383长度的主体。

```
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | R |     Length (14)           |   Type (8)    |   Flags (8)   |
 +-+-+-----------+---------------+-------------------------------+
 |R|                 Stream Identifier (31)                      |
 +-+-------------------------------------------------------------+
 |                   Frame Payload (0...)                      ...
 +---------------------------------------------------------------+
```

帧头部字段定义是：

 - **R** : 保留的2字节字段。这些字节的语义是未定义的，并且在发送的时候必须保留未设置(0)，在接受的时候必须被忽略。
 - **Length** :  以14字节无符号整数的帧主体的长度。8字节长度的帧头部信息不计算在此内。
 - **Type** ： 帧的8字节类型。帧类型定义了剩余的帧报头和帧主体将如何被解释。具体实现必须处理收到未知帧类型(任何未在文档中定义的帧)时作为连接错误中类型协议错误PROTOCOL_ERROR。
 - **Flags** ： 为帧类型保留的8字节字段有具体的布尔标识。
标识针对确定的帧类型赋予特定的语义。确定帧类型定义语义以外的标示必须被忽略，并且必须在发送的时候保留未设置(0)。
 - **R** : 1字节的保留字段。这个字段的语义未设置并且必须在发送的时候保持未设置(0),在接受的时候必须被忽略。
 - **Stream Identifier** : 31字节的流标识符(见StreamIdentifiers)。0是保留的，标明帧是与连接相关作为一个整体而不是一个单独的流。

帧主体的结构和内容完全取决于帧类型。

### 4.2 Frame Size

帧主体的最大长度限制因不同的帧类型而不同。最大帧主体的绝对长度是 $2^{14}-1$ (16,383)字节，表示最大的帧长度是16,391字节。所有的实现应当具备接收和处理此最大长度帧的能力。

某些帧类型，例如PING(见 PING)，对主体数据大小有额外的限制。同样的，一些特定的应用也可能使用额外的大小限制(见HttpExtra)。

如果一个帧大小超过任何设定的限制，或者太小无法包含强制的帧数据，这个端点必须发送一个帧大小错误FRAME_SIZE_ERROR。如果帧大小错误可能修改整个连接状态，必须作为一个ConnectionErrorHandler连接错误处理；这包括与0流一起的携带HeaderBlock头部块(即报文头HEADERS，推送许可PUSH_PROMISE和延续CONTINUATION)、<x:ref>设置SETTINGS</x:ref>以及任何窗口更新WINDOW_UPDATE的帧。

### 4.3 Header Compression and Decompression

HTTP/2报文头部字段是包含一个或多个相关意义的键值对。他们在HTTP请求响应消息及服务器推送操作(见PushResources)中使用。

 报头集合是0个或多个报头字段的集合。当传输一个连接的时候，报头集合将使用HTTP头部压缩序列化到报文头部块中。序列化的报头块被分割成一个或多个的字节序列，称为报头分区，并在报头HEADERS、推送约定PUSH_PROMISE及延续CONTINUATION的载体中传送。

HTTP报文头压缩并不保留报头字段的相关顺序。通用多个值的报头字段使用特定的分割器被编码分割到一个单独的报头区域；见HeaderOrdering。

报文头Cookie字段被通过HTTP映射特殊处理；见CompressCookie。

接收端点连接报头区块重新组装，并且解压缩区块后重建报头集合。

一个完整的报头区块可以包含：

 - 一个包含头部终止标记集合的单独的报头HEADERS 或 推送约定PUSH_PROMISE帧，或者
 -  一个头部终止标记被清除的报头HEADERS 或 推送约定PUSH_PROMISE帧以及一个或多个延续CONTINUATION帧，最后一个延续CONTINUATION帧拥有头部终止标记设置。

报头区块必须作为一个连续的帧序列传输，没有任何类型或任何其他流的交错帧。一个报头HEADERS或者延续CONTINUATION帧序列的最后一帧必须有头部终止标记设置。推送约定PUSH_PROMISE或者延续CONTINUATION帧序列的最后一帧必须具有头部终止标记设置。

报头区块必须被报头HEADERS、<x:ref>推送约定PUSH_PROMISE</x:ref>或<x:ref>延续CONTINUATION</x:ref>的有效载体发送，因为这些帧中携带了能被接收端修改的压缩上下文数据。端点在接收<x:ref>报头HEADERS</x:ref>、<x:ref>推送约定PUSH_PROMISE</x:ref>或<x:ref>延续CONTINUATION</x:ref>帧时必须重新组装报头区块并且执行解压缩，即便这些帧将被废弃。如何不能重建头部区间，接收端必须终止连接并报<x:ref>解压缩错误COMPRESSION_ERROR的ConnectionErrorHandler连接错误connection error</xref>。

## 5 Streams and Multiplexing

流是一个独立的，客户端和服务端在HTTP/2连接下交换<x:ref>报头HEADERS</x:ref>和 <x:ref>数据DATA</x:ref>帧的双向序列。

 - 一个单独的HTTP/2连接能够保护多个同时打开的流，各个端点间从多个流中交错帧。
 - 流可以被被客户端或者服务端单方面建立使用或分享。
 - 流可以被任何一个终端关闭。
 - 在流内发送帧的顺序很重要。它们将按被接收的顺序处理。
 - 流以一个整数标识。标识符有启动流的终端分配。

### 5.1 Stream States

流的生存周期如StreamStatesFigure所示：

```
            <![CDATA[
                       +--------+
                 PP    |        |    PP
              ,--------|  idle  |--------.
             /         |        |         \
            v          +--------+          v
     +----------+          |           +----------+
     |          |          | H         |          |
 ,---| reserved |          |           | reserved |---.
 |   | (local)  |          v           | (remote) |   |
 |   +----------+      +--------+      +----------+   |
 |      |          ES  |        |  ES          |      |
 |      | H    ,-------|  open  |-------.      | H    |
 |      |     /        |        |        \     |      |
 |      v    v         +--------+         v    v      |
 |   +----------+          |           +----------+   |
 |   |   half   |          |           |   half   |   |
 |   |  closed  |          | R         |  closed  |   |
 |   | (remote) |          |           | (local)  |   |
 |   +----------+          |           +----------+   |
 |        |                v                 |        |
 |        |  ES / R    +--------+  ES / R    |        |
 |        `----------->|        |<-----------'        |
 |  R                  | closed |                  R  |
 `-------------------->|        |<--------------------'
                       +--------+

   H:  HEADERS frame (with implied CONTINUATIONs)
   PP: PUSH_PROMISE frame (with implied CONTINUATIONs)
   ES: END_STREAM flag
   R:  RST_STREAM frame
```

$$Figure 2: Stream States$$

当流在传输的时候，各个端点对流状态的主观认识可能不同。终端并不协调流的创建；它们是被任意终端单方面创建的。不匹配的状态导致的消极结果是在发送<x:ref>RST_STREAM</x:ref>流之后它们的“关闭”是受限制的，因为可能在关闭之后帧才被接收。

流有以下状态：

**idle** :

 所有流以“空闲”状态开始。在这种状态下，没有任何帧的交换。
下列传输在这种状态下是有效的：

 - 发送或者接收一个<x:ref>报头HEADERS</x:ref>帧导致流变成“打开”。流标识符如StreamIdentifiers说明。这个<x:ref>报头HEADERS</x:ref>帧同样可能导致流立即变成“半关闭”状态。
 - 发送一个<x:ref>推送约定PUSH_PROMISE</x:ref>帧标记相关的流后续再使用。保留流状态将转换为“预留(本地)”。
 - 接收一个<x:ref>推送约定PUSH_PROMISE</x:ref>帧标记相关的流为远程端点预留的流。这些流的状态变成“预留(远程)”

在“预留(本地)”状态的是已经被承诺发送<x:ref>推送约定PUSH_PROMISE</x:ref>帧的流。一个<x:ref>推送约定PUSH_PROMISE</x:ref>帧通过使一个流与一个由远端对等端初始化的打开的流相关联来保留一个空闲流。

**reserved (local)** : 

在“预留(本地)”状态的是已经被承诺发送<x:ref>推送约定PUSH_PROMISE</x:ref>帧的流。一个<x:ref>推送约定PUSH_PROMISE</x:ref>帧通过使一个流与一个由远端对等端初始化的打开的流相关联来保留一个空闲流。 

在这种状态下，只有下列传输是可能的：

 - 端点可以发送<x:ref>报头HEADERS</x:ref>帧，致使流打开到“半封闭(远程)”状态。
 - 任意端点能发送一个<x:ref>RST_STREAM</x:ref>帧来使流变成“关闭”。这将释放流的保留。

在这种状态下一个端绝对不能发送<x:ref>报头HEADERS</x:ref>帧和<x:ref>RST_STREAM</x:ref>以外的帧。

在这种状态下一个<x:ref>优先级PRIORITY</x:ref>帧可能被接收。接收到任何<x:ref>报头HEADERS</x:ref>帧、<x:ref>RST_STREAM</x:ref>帧或者<x:ref>优先级PRIORITY</x:ref>帧以外的帧都将被认为是类型为<x:ref>协议错误PROTOCOL_ERROR</x:ref>的ConnectionErrorHandler连接错误connection error</xref>。

**reserved (remote)** :

在“保留(远程)”状态下的流说明已经被远程对等端所保留。

在这种状态下，只有下列传输是可能的：

 - 接收一个<x:ref>报头HEADERS</x:ref>帧并致使流转换到“半封闭(本地)”状态。
 - 任意一个端点能发送一个<x:ref>RST_STREAM</x:ref> 帧来使流变成“关闭”。这将释放流的保留。

这种状态下终端可以发送一个<x:ref>优先级PRIORITY</x:ref>帧来变更保留流的优先级顺序。终端绝对不能发送任何<x:ref>RST_STREAM</x:ref> 和<x:ref>优先级PRIORITY</x:ref>以外的帧。

接收任何<x:ref>RST_STREAM</x:ref> 和<x:ref>优先级PRIORITY</x:ref>以外的帧必须作为类型为 <x:ref>协议错误PROTOCOL_ERROR</x:ref>的ConnectionErrorHandler连接错误</xref>来处理。

**open** : 

处于“打开”状态的流可以被两个对等端来发送任何类型的帧。在这种状态下，发送数据的对等端检查被广播端FlowControl流量控制限制。

 在这种状态下每个终端可以发送一个带有END_STREAM结束流标记的帧来使流转换到以下一种“半关闭”状态：一个终端发送一个结束流END_STREAM标记使流变成“半封闭”状态；一个终端接收一个结束流END_STREAM标记使流变成“半封闭(远程)”状态。带有结束流END_STREAM标记的<x:ref>报头HEADERS</x:ref>帧后面可以跟着<x:ref>延续CONTINUATION</x:ref>帧。 

这种状态下各个终端可以发送一个<x:ref>RST_STREAM</x:ref>帧来使流转换到"关闭"状态。

**half closed (local)** : 

“半封闭(本地)”状态下的流不能发送帧。

这种状态下，当流接收到包含END_STREAM标记的帧或者某个终端发送了<x:ref>RST_STREAM</x:ref>帧，流转换到“关闭”状态。带有结束流END_STREAM标记的<x:ref>报头HEADERS</x:ref>帧后面可以跟着<x:ref>延续CONTINUATION</x:ref>帧。 

这种状态下接收端可以忽略<x:ref>窗口更新WINDOW_UPDATE</x:ref>或<x:ref>优先级PRIORITY</x:ref>帧。这种类型的帧有可能在结束流END_STREAM标记到达一小段时间后才收到。

**half closed (remote)** : 

"半封闭(远程)"状态下的流不再被对等端用来发送帧。这种状态下，执行流量控制的终端不在承担接收留空控制窗口的工作。

如果终端接收到处于这种状态下的流发送的额外的帧，除非是<x:ref>延续CONTINUATION</x:ref>帧，否则必须返回类型为<x:ref>流关闭STREAM_CLOSED</x:ref>的<xref target="StreamErrorHandler">流错误</xref>

这种状态下，当流发送一个带有终止流END_STREAM标记的帧或者某个终端发送了一个<x:ref>RST_STREAM</x:ref>帧，流将转换到“关闭”状态。

**closed** : 

“关闭”状态是终止状态。

终端绝对不能通过关闭的流发送帧。终端在收到<x:ref>RST_STREAM</x:ref>后接收的任何帧必须作为类型为<x:ref>流关闭STREAM_CLOSED</x:ref>的StreamErrorHandler流错误stream error</xref>处理。相似的，终端接收到带有END_STREAM标记设置的<x:ref>数据DATA</x:ref>帧之后的任何帧，或在带有END_STREAM终止流标记且后面没有<x:ref>延续CONTINUATION</x:ref>帧的<x:ref>报头HEADERS</x:ref>帧之后收到任何帧都必须作为类型为<x:ref>流关闭STREAM_CLOSED</x:ref>的StreamErrorHandler流错误</xref>处理。

这种状态下，<x:ref>WINDOW_UPDATE</x:ref>, <x:ref>PRIORITY</x:ref>, or <x:ref>RST_STREAM</x:ref>帧可以在带有END_STREAM标记的<x:ref>数据DATA</x:ref>或者<x:ref>报头HEADERS</x:ref>帧发送一小段时间内被接收。在远端对等端接收并处理带有END_STREAM标记的帧之前，可以发送任意这几种帧。在这种状态下终端必须忽略接收到的<x:ref>WINDOW_UPDATE</x:ref>,<x:ref>PRIORITY</x:ref>, 或 <x:ref>RST_STREAM</x:ref>帧，但终端也可以当作<x:ref>协议错误PROTOCOL_ERROR</x:ref>或者ConnectionErrorHandler连接错误</xref>来处理。

如果流在发送<x:ref>RST_STREAM</x:ref>帧转换到这种状态，接收到<x:ref>RST_STREAM</x:ref>的对等端可能已经发送或者队列中准备发送无法取消的帧。终端必须忽略从已经发送<x:ref>RST_STREAM</x:ref>帧的流接收到的帧。终端可以选择设置忽略帧的超时时间并在超过限制后作为错误处理。

在发送<x:ref>RST_STREAM</x:ref>之后收到的流量受限帧(如<x:ref>数据DATA</x:ref>帧)转向流量控制窗口连接处理。尽管这些帧可以被忽略，但他们是在发送端接收到<x:ref>RST_STREAM</x:ref>之前发送的，发送端会认为这些帧与流量控制窗口不符。

终端可能在发送<x:ref>RST_STREAM</x:ref>之后收<x:ref>PUSH_PROMISE</x:ref>帧。即便相关的流已经被重置，<x:ref>PUSH_PROMISE</x:ref>也能使流变成“预留”状态。因此，需要<x:ref>RST_STREAM</x:ref>来关闭一个不想要的被承诺流。

本文档中没有明确说明的地方，具体实现时接收描述状态中没有明确许可的信息都应作为类型为<x:ref>协议错误PROTOCOL_ERROR</x:ref>的ConnectionErrorHandler连接错误</xref>来处理。

#### 5.1.1 Stream Identifiers

流由31位字节的无符号整数定义。客户端发起的流必须以奇数标示；服务器发起的流必须使用偶数来标示。0(0x0)用来标识连接控制信息流，且绝对不能用来建立一个新流。

HTTP/1.1升级到HTTP/2的请求将收到一个1(0x1)标识的响应流。升级完成后，0x1流将对客户端处于“半封闭(本地)”状态。因此，0x1流不能被从HTTP/1.1升级的客户端用来作为一个新的流的标识符。

一个新建立的流标识符必须数值大于任何终端已经打开或者保留的流标识符。规则适用于使用<x:ref>HEADERS</x:ref>帧打开的流以及使用<x:ref>PUSH_PROMISE</x:ref>保留的流。终端收到不规范的流标识符必须响应一个类型为 <x:ref>PROTOCOL_ERROR</x:ref>的ConnectionErrorHandler连接错误connection error</xref>。

新的流标识符第一次被使用时将隐式关闭所有处于“空闲”状态下，可能已经被对等端初始化而且流标识符数字小于新标识符的流。例如，一个客户端发送一个流7的<x:ref>HEADERS</x:ref>帧，那么在流7发送或者接收帧后从没有发送帧的流5将转换为“关闭”状态。

流标识符不能被重复使用。生存期长的连接可能导致流标识符可用范围耗尽。客户端不能新建流标识符时可以针对新流建立一个新的连接。

#### 5.1.2 Stream Concurrency

 对等端可以使用<x:ref>SETTINGS</x:ref>帧里面的<x:ref>SETTINGS_MAX_CONCURRENT_STREAMS</x:ref>参数来限制流的并发量。最大并发流设置仅适用于终端并且只对接收到此设置的对等端有效。也就是说：客户端可以指定服务端能启动的流最大并发量，而且服务端能指定客户端能启动的流最大并发量。终端绝对不能超过对等端设置的限制。

处于“打开”或者任意一种“半封闭”状态的流均计入终端被允许启动的流次数中。处于任意这三种状态下的流都将计入SETTINGS_MAX_CONCURRENT_STREAMS设置次数中 (see SettingValues).

处于任意一种“保留”状态下的流不计入打开次数中。

### 5.2 Flow Control

使用复用流介绍了针对TCP连接的资源争夺导致了流的阻塞。流量控制方案等确保同意连接上的流相互之间不会造成破坏性的干扰。流量控制使用在单个流及整个连接过程中。

HTTP/2 通过使用<x:ref>WINDOW_UPDATE</x:ref>帧类型来提供流量控制。

#### 5.2.1 Flow Control Principles

HTTP/2流流量控制目标在于允许不需要协议改动的情况下改进流量控制算法。HTTP/2中的流量控制有以下特点：

 1. 流量控制是逐跳的，而不是头尾连接的。
 2. 流量控制是基于窗口更新帧的。接收端广播自己准备在流及整个连接过程中接收的字节大小。这是一个信用为基础的方案。
 3. 流量控制是有方向性的，由接收端全权掌握。接收端可以选择针对流及整个连接设置任意的窗口大小。发送端必须遵守接收端的流量控制限制。客户端、服务端及中端代理作为接收者时都独立的向外广播他们各自的流量控制窗口，作为发送者时遵守接收端的限制。
 4. 每个新的流及整个连接的流量控制窗口初始值是65,535字节。
 5. 帧类型决定了是否适用流量控制规则。本文档定义的帧中，只有<x:ref>DATA</x:ref>帧受流量控制；所有其他的帧不受广播的流量控制窗口影响。这保证了重要的控制帧不因流量控制所阻塞。
 6. 流量控制不能被禁用。
 7. HTTP/2只标准化<x:ref>WINDOW_UPDATE</x:ref>帧格式(WINDOW_UPDATE)。它没有规定接收端是何时发送帧或者发送什么值，也没有规定发送端如何选择发送包。具体实现可以选择任何满足需求的算法。

具体实现还负责管理请求和响应是如何基于优先级发送的；如何避免请求头阻塞以及管理新流的创建。这些算法能够与任何流量控制算法相互作用。

流量控制的定义是用来保护端点在资源约束条件下的操作。例如，一个代理需要在很多连接之间共享内存，也有可能有缓慢的上游连接和快速的下游连接。流量控制解决的情况是接收端在一个流上处理数据的同时同样想继续处理同个连接上的其他流。

调度过程中不需要这种能力时可以广播一个最大值的流量控制窗口，增加接收新数据时的可用空间。发送数据时总是受接收端广播的流量控制窗口的管理。

资源约束下(例如内存)的调度可以使用流量来限制一个对等端可以消耗的内存数量。需要注意的是如果在不知道带宽延迟乘积的时候启用流量控制可能导致无法最优的利用可用的网络资源(see RFC1323)。

即便是对当前的网络延迟乘积有充分的认识，流量控制的实现也可能很复杂。当使用流量控制时，接收端必须及时地从TCP接收缓冲区读取数据。这样做可能导致在一些例如<x:ref>WINDOW_UPDATE</x:ref>的关键帧在HTTP/2不可用时导致死锁。但是流量控制可以保证约束资源能在不需要减少连接利用的情况下得到保护。

### 5.3 Stream priority

新建流的终端可以对流标记优先级。优先级使用31字节无符号整数表示。0表示最高优先级，2的31次方-1表示最低优先级。

这个值的目的是允许终端表示流的相对优先级。端点可以用这些信息按优先级来给流分配资源。HTTP/2中，当发送能力有限时，可以使用优先级来选择流传输帧。例如，终端可能对当前并发激活的流进行排队，当传输容量可用后，拥有高优先级的流可能在低优先级流前先发送帧。

明确设置流的优先级并不能保证能相当其他相关流有特殊的处理或者传输顺序。也没提供任何机制让流的发起者能强制或要求接收端对当前流进行特殊处理。

除非在<x:ref>HEADERS</x:ref>(HEADERS)帧中明确设置，默认的流优先级是$2^{30}$。

PushResources推送流比其他相关的流优先级低。被承诺的流继承了其相关的流优先级并加1，最多$2^{31}$-1.

**TODO** 有更新

### 5.4 Error Handling  

HTTP/2框架允许两类错误：

 - 使整个连接不可用的错误。
 - 单个流中出现的错误。

错误码列表可以在"ErrorCodes"找到。

####  5.4.1 Connection Error Handling

流错误是阻止帧层更进一步进行处理或者破坏任何流状态的错误。

发送流错误的终端应当首先发送一个<x:ref>超时GOAWAY</x:ref>帧(GOAWAY)，并带有最近的一个成功从对等端接收帧的流的标识符。<x:ref>GOAWAY</x:ref>超时帧包含链接终端的错误码。发送<x:ref>GOAWAY</x:ref>后，终端必须关闭TCP连接。

<x:ref>超时GOAWAY</x:ref>帧有可能不被接收端有效接收。在连接错误事件中，<x:ref>超时GOAWAY</x:ref>帧是尝试跟对等端通信告知连接终止原因的最佳实践。

终端可以在任何时候终止一个连接。类似的，终端可以选择将流错误作为连接错误处理。只要环境许可，终端在终止连接时应当发送一个<x:ref>GOAWAY</x:ref>帧。

#### 5.4.2 Stream Error Handling

流错误是与特定标识的流相关的错误，并且不会影响其他流的处理。

终端检测到流错误时发送一个带有错误发生时的流标识符的<x:ref>RST_STREAM</x:ref>帧(RST_STREAM)。<x:ref>RST_STREAM</x:ref>帧带有表示错误类型的错误码。

<x:ref>RST_STREAM</x:ref>是终端可以发送一个流的最后一帧。发送<x:ref>RST_STREAM</x:ref>帧的对等端必须准备好接收任何由远端对等端发送或者准备发送的帧。这些帧可以被忽略，除非连接状态被修改（例如报头压缩中的状态）。

通常，终端不应该在任何流觞发送多个<x:ref>RST_STREAM</x:ref>帧。但是，终端如果在一个关闭的流上超过rtt时间后收到帧，则可以发送的额外的<x:ref>RST_STREAM</x:ref>帧。这种做法是被允许用来处理这种非常规情况。

终端绝不能在收到<x:ref>RST_STREAM</x:ref>帧后响应一个<x:ref>RST_STREAM</x:ref>帧，避免死循环。

#### 5.4.3 Connection Termination

如果TCP连接在流仍然保持打开或者半封闭状态下断开，那么终端必须假定这些流是异常终端且不完整的。

## 6 Frame Definitions

本规范定义了一系列的帧类型，每种类型由独特的8位类型代码标记。不管是在连接管理或单独的流中，每种帧都为了特定的目的而服务。

特定帧类型的传输可以修改连接的状态。如果终端不能保持同步的连接状态，连接中的通信将失败。因此，终端对于如何使用给定帧修改状态需要达成共识。

### 6.1 DATA

数据帧（类型=0x0）表示随意，由伴随流的可变长度序列组成。例如，一个或多个数据帧被用来携带HTTP请求或者响应的载体。

数据帧也可以包含任意包装物。包装物可以添加到数据帧中来隐藏消息的大小。

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | [Pad High(8)] | [Pad Low (8)] |          Data (*)             .
 +---------------+---------------+-------------------------------+
 .                            Data (*)                         ...
 +---------------------------------------------------------------+
 |                           Padding (*)                       ...
 +---------------------------------------------------------------+
```

数据帧包含以下字段：

 - **Pad High** ： 包含单位为256字节的填充量的8位字段。这个字段是可选的，并且只在设置了PAD_HIGH标记的情况下呈现。这个字段与Pad Low一起决定了帧上面有多少填充量。
 - **Pad Low** ： 包含单位为单个字节的填充量的8为字段。这个字段是可选的并且只在设置了PAD_LOW标记的情况下呈现。这个字段与Pad High一起决定了帧上面有多少填充量。
 - **Data** ： 应用数据。数据量的大小是帧的有效载荷减去其他呈现字段的长度。
 - **Padding** ： 填充字节不包含任何应用语义值。天聪字节必须在发送的时候设置为0，在接收的时候忽略。

数据帧定义了以下标记：

 - **END_STREAM (0x1)** ： 1位用来表示当前帧是确定的流发送的最后一帧。设置这个标记时流进入到一种半封闭状态或者关闭状态。
 - **END_SEGMENT (0x2)** ： 2位表示是当前端的最后一帧。代理端绝对不能跨越多个端的边界来合并帧，转发帧的时候代理端必须保持片段的边界。
 - **PAD_LOW (0x10)** ： 5位用来表示Pad Low 字段是可见的。
 - **PAD_HIGH (0x20):** ： 6位用来标识Pad High字段是可见的。除非设置了PAD_LOW标记才能设置此标记。终端接收到带有PAD_HIGH设置但是PAD_LOW被清除的必须作为类型为协议错误的连接错误来处理。

数据帧绝对需要与流相关联。如果接收到流标记字段是0x0的数据帧，必须响应一个类型为协议错误的连接错误。

数据帧遵从流量控制，并且只有在流是打开或者半封闭(远端)状态下才能够被发送。填充同样包含在流量控制中。如果数据帧在相关流不是在打开和半封闭(本地)状态下被接收，接收端必须响应一个类型为流关闭的流错误。

填充字节的总数由Pad High的值乘以256加上Pad Low 的值决定。二者默认值均为0。如果填充物的大小大于帧有效载荷的大小，接收端必须作为类型为协议错误的连接错误处理。

`请注意` ： 加上值为0的Pad Low值后，帧大小将加1字节。

使用填充是一种安全手段；例如，用来满足特定需求，见padding.

### 6.2 HEADERS

报头帧(类型=0x1)由键值对组成。它用来打开一个流。报头帧能在流打开或者半封闭(远程)的状态下发送。

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | [Pad High(8)] | [Pad Low (8)] |X|      [Priority (31)]      ...
 +---------------+---------------+-+-----------------------------+
 ...      [Priority]             | Header Block Fragment (*)   ...
 +-------------------------------+-------------------------------+
 |                   Header Block Fragment (*)                 ...
 +---------------------------------------------------------------+
 |                           Padding (*)                       ...
 +---------------------------------------------------------------+
```

报头帧主体有以下字段：

 - **Pad High** ： 填充大小的高位。这个字段只有在设置了PAD_HIGH 标记的情况下才呈现。
 - **Pad Low** ： 填充大小低位。这个字段只有在设置了PAD_LOW 标记的情况下才呈现。
 - **X** ： 单一保留位。这个字段是可选的，并且只在优先级标记设置的情况下才呈现。
 - **Priority** ： 流的优先级信息。见StreamPriority。这个字段是可选的，并且只在优先级标记设置的情况下才呈现。
 - **Header Block Fragment** ： 报头块碎片。
 - **Padding** ： 填充字节
 
报头帧定义了以下标记：

 - **END_STREAM (0x1)** ： 1位用来标识这是发送端对确定的流发送的最后报头区块。设置这个标记将使流进入一种半封闭状态。
后面伴随带有END_STREAM标记的延续帧的报头帧表示流的终止。延续帧不用来用终止流。
 - **END_SEGMENT (0x2)** ： 位2表示这是当前端的最后一帧。中介者绝对不能跨片段来合并帧，且在转发帧的时候必须保持片段的边界。
 - **END_HEADERS (0x4)** ： 3 位表示帧包含了整个的报头块，且后面没有延续帧。
不带有END_HEADERS标记的报头帧在同个流上后面必须跟着延续帧。接收端接收到任何其他类型的帧或者在其他流上的帧必须作为类型为协议错误的连接错误处理。
 - **PRIORITY (0x8)** ： 4 位表示帧带有单独的保留为并且和一个31位的优先级。见<xref target="StreamPriority"/>.如果此为未设置，那四个字节不会出现。
 - **PAD_LOW (0x10)** ： 位5 表示Pad Low 字段会呈现。
 - **PAD_HIGH (0x20)** ： 为6表示Pad High字段会呈现。除非PAD_LOW标记设置此标记才能设置。终端收到带有Pad High设置但是没有PAD_LOW标记的必须作为类型为协议错误的连接错误处理。

报头帧的主体包含一个报头区块碎片。报头区块大于一个报头帧的将在延续帧中继续传送。

报头帧必须与一个流相关联。如果一个接收到一个流标示识0x0得报头帧，接收端必须响应一个类型为协议错误的连接错误。

报头帧改变连接状态在TODO此中表述。

报头帧包含可选的填充段。填充字段和标记同数据帧中描述。

###  6.3 PRIORITY

优先级帧(type=0x2)明确了发送者建议的流的优先级。它可以任意时间在存在的流中发送。这个使存在的流有了优先级次序。

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |X|                        Priority (31)                        |
 +-+-------------------------------------------------------------+
```

优先级帧的主体包含一个保留的位及31位的优先级。

优先级不定义任何标记。

优先级与存在的流相关联。如果接收端收到流标识为0的优先级帧，必须响应一个类型为协议错误的连接错误。

优先级帧可以在流状态为“保留(远端)”、“打开"、“半封闭(本地)”或者“半封闭(远程)”状态下发送,但它不能在由单个报头区块组成的连续帧之间发送。需要注意的是这个帧可能在处理或者帧发送已经完成之后才到达，这可能导致没有效果。对于处于“半封闭(远程)”状态下的流，优先级帧只能影响流的处理而不是传输。

RST_STREAM帧(type=0x3)允许流的异常终止。当被流的指示器发送时，它表示期望取消流或者错误条件发生。当被接收端的流发送时，它表示接收者希望拒绝流、流被取消或者发生了错误。

TODO

### 6.4 RST_STREAM

RST_STREAM帧(type=0x3)允许流的异常终止。当被流的指示器发送时，它表示期望取消流或者错误条件发生。当被接收端的流发送时，它表示接收者希望拒绝流、流被取消或者发生了错误。

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                        Error Code (32)                        |
 +---------------------------------------------------------------+
```

RST_STREAM 帧由一个无符号的32位整数标记错误码。错误码指明流被终止的原因。

RST_STREAM 帧未定义任何标记。

RST_STREAM 帧完全终止相关的流并使其转入关闭状态。在接收到流的RST_STREAM帧后，接收端绝对不能在流上发送额外的帧。然而，在发送RST_STREAM帧后，发送端必须要准备接收并处理流上的其他帧，因为对等端有可能在收到RST_STREAM帧前就已经发送。

RST_STREAM 帧必须与流相关联。如果接收端收到流标示符为0x0的RST_STREAM 帧，必须作为类型为协议错误的连接错误处理。

RST_STREAM帧绝对不能在流处于“空闲”状态下发送。如果接收端收到流状态为空闲的RST_STREAM帧，必须作为类型为协议错误的连接错误处理。

### 6.5 SETTINGS

设置帧(type=0x4)包含影响如何与终端通信的设置参数(例如偏好设置以及对等端的行为约束)，并且用来确认这些参数的接收。单个的设置参数也可以被认为是“设置”。

设置参数不是通过协商确定的；它们描述发送端的特点，并被接收端使用。相同的参数对不同的对等端设置可能不同。例如，一个客户端可能设置一个较高的流量控制窗口，而服务器为了保存资源可能设置一个较低的值。

设置帧必须由两个终端在连接开始的时候发送，并且可以由各个终端在连接生存期的任意时间发送。具体实现必须支持本规范定义的所有参数。

设置帧的所有参数将替换参数中现有值。参数由他们出现的顺序来处理，而且接收设置帧并不需要保存当前值以外的任何状态。因此，设置参数的值是接收端接收到的最后一个值。

设置参数是被接收端公认的。为了实现这个，设置帧定义了以下标记：

 **ACK (0x1)** ： 位1表示设置帧已被接收端接收并应用。如果这个位设置了，设置帧的载体必须为空。接收到字段长度不是0的带有ACK标记的设置帧必须作为类型为帧大小错误的连接错误处理。更多信息，见此。

设置帧总是应用于连接，而不是一个单独的流。流的设置帧标识必须为0.如果终端接收到流设置帧标识不是0的设置帧，必须响应一个类型为协议错误的连接错误。

设置帧影响连接状态。格式错误或者未完成的设置帧必须作为类型为协议错误的连接错误处理。

#### 6.5.1 SettingFormat

设置帧载体包含0个或多个参数，每个包含一个无符号的8位标识以及一个无符号的32位值。

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |Identifier (8) |                 Value (32)                  ...
 +---------------+-----------------------------------------------+
 ...Value        |
 +---------------+
```

#### 6.5.2 Defined SETTINGS Parameters

定义了以下参数：

 - **SETTINGS_HEADER_TABLE_SIZE (1)** : 允许发送端通知远端终端解码报头区块的报头压缩表的大小。这个编码器可以在报头区块中使用特定信号来减少报头压缩的大小。初始值是4,096个字节。
 - **SETTINGS_ENABLE_PUSH (2)** : 这个参数可以用来关闭服务器推送。终端在接收到此参数为0的情况下绝对不能发送服务器推送帧。终端在已经设置此参数为0并且承认的情况下必须对接收到的服务器推送作为类型为协议错误的连接错误处理。
初始值是1，表示推送是许可的。任何不是0或1的值必须作为类型为协议错误的连接错误处理。
 - **SETTINGS_MAX_CONCURRENT_STREAMS (3)** : 标明发送者允许的最大并发流。此限制是定向的：它适用于发送端允许接收端创建的最大并发流的数量。初始化时这个值没有限制。建议值不要大于100,以免不必要的限制并行。
此设置为0的值不应该被终端认为是特殊的。0的值阻止了新的流的创建，另外它也适用于被激活的流用尽的任何限制。对于短连接不应该设置此参数为0；如果服务端不希望接收任何请求，最佳的做法是关闭连接。
 - **SETTINGS_INITIAL_WINDOW_SIZE (4)** : 表示发送端对流层流量控制的初始窗口大小(字节单位)。初始值是65,535。
这个参数影响了所有流的窗口大小，包括现有的流。见InitialWindowSize.
流量控制窗口大小值大于2的31次方-1的必须被作为流量控制错误的连接错误处理。

终端收到其他标记的设置帧必须作为类型为协议错误的连接错误处理。

#### 6.5.3 Settings Synchronization

大部分设置值收益于或者需要了解对等端接收到并且改变了通信过的参数的值的时机。为了提供这样一种同步的时间点，接收到没有设置ACK标记的设置帧必须尽快将更新过的参数适用于接收端上。

设置帧的值必须按照它们出现的顺序被使用，在处理值中间不能处理其他帧。一旦所有的值被应用，接收端必须马上发送一个带有ACK标记的设置帧。在接收到带有ACK标记的设置帧后，修改参数的发送端可以认为修改已生效。

如果设置参数的发送端没有在一定时间内收到认可的响应，它可以发出一个类型为设置超时的连接错误。

### 6.6 PUSH_PROMISE

推送帧(type=0x5)用来在流发送者准备发送流之前告知对等端。推送帧包含了终端准备创建的长流的31位无符号标记以及提供附加上下文的报头的集合。PushResources中详细描述了推送帧的使用。

如果SETTINGS_ENABLE_PUSH设置参数为0，推送帧绝对不能被发送。

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | [Pad High(8)] | [Pad Low (8)] |X|  Promised Stream ID (31)  ...
 +---------------+---------------+-+-----------------------------+
 ...    Promised Stream ID       | Header Block Fragment (*)   ...
 +-------------------------------+-------------------------------+
 |                   Header Block Fragment (*)                 ...
 +---------------------------------------------------------------+
 |                           Padding (*)                       ...
 +---------------------------------------------------------------+
```

报头帧载体包含以下字段：

 - **Pad High** : 填充大小高位。这个字段只有在PAD_HIGH标记设置的情况下才呈现。
 - **Pad Low** : 填充大小低位。这个字段只有在PAD_LOW标记设置的情况下才呈现。
 - **X** : 单独的保留位。
 - **Promised Stream ID** : 这个无符号31位整数表示终端准备发送的流标记。被承诺的流标记必须对发送端准备发送的下一个流来说是有效选择。
 - **Header Block Fragment** : 包含请求头字段的报头区块碎片。
 - **Padding** : 填充字节。

推送帧定义了以下标记：

 - **END_HEADERS (0x4)** : 位3 表明帧包含了整个报头区块并且不跟着延续帧。
不带有END_HEADERS标记的推送承诺帧在同个流上面后面必须跟着延续帧。接收端接收到任何其他类型或者其他流觞的帧必须作为类型为协议错误的连接错误处理。
 - **PAD_LOW (0x10)** : 位5 表明Pad Low字段是已设置。
 - **PAD_HIGH (0x20)** : 位6表明Pad High字段已设置。除非Pad High也设置了否则这个位绝对不能设置。终端接收到有PAD_HIGH 设置但是没有PAD_LOW设置的必须作为类型为协议错误的连接错误处理。

推送承诺帧必须与现有的由对等端初始化的流相关联。如果流标识字段为0x0，接收端必须响应一个类型为协议错误的连接错误。

被承诺的流并不需要以被承诺的顺序使用。推送承诺只保留接下来会使用的流的标识符。

推送承诺的接收端可以选择给推送承诺的发送端返回一个与被承诺的流标识符相关的RST_STREAM标记来拒绝接收承诺流。

推送承诺帧对连接章台的修改见HeaderBlock中定义。

PUSH_PROMISE通过两种方式修改连接状态。这包括一个报头区块可能修改压缩状态。PUSH_PROMISE同样保留流后续使用，导致被推送的流进入到“保留”状态。发送端绝对不能在流上发送PUSH_PROMISE除非流是“打开”或者“半封闭(远程)”状态；发送端绝对要保证被承诺的流对于新的流标示来说是一个有效的选择(就是说，被承诺的流必须进入"空闲"状态)。

由于PUSH_PROMISE保留了一个流、忽略一个PUSH_PROMISE 帧都会导致流状态变得不确定。接收端接收到流状态不是“打开”或者“半封闭(本地)”的流的推送帧必须作为类型为协议错误的连接错误处理。相似的，接收端必须对在一个非法标示的流(即流的标识当前不在空闲状态)上建立的推送承诺作为类型为协议错误的连接错误处理。

PUSH_PROMISE帧填充是可选的。填充字段及标记同数据帧中定义。

### 6.7 PING

PING帧(type=0x6)是一种从发送端测量最小的RTT时间的机制，同样也是一种检测连接是否可用的方法。PING帧可以被任何终端发送。

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 |                      Opaque Data (64)                         |
 |                                                               |
 +---------------------------------------------------------------+
```

除了帧报头之外，PING帧必须在载体中包含一个8字节长度的数据。发送端可以选择使用任何指并在任何时候使用。

接收到不包含ACK标记的PING帧必须发送一个带有ACK比标记的PING帧响应，以及一个相同的载荷。PING响应应当设置比其他帧更高的优先级。

PING帧定义了以下标记：

 **ACK (0x1)** ： 位1表示PING帧是一个PING响应。终端必须在PING响应中设置此标记。终端绝对不能对包含此标记的PING帧做出响应。

PING帧捕鱼任何独立的流相关联。如果收到流标示字段不是0x0的PING帧，接收端必须响应一个类型为协议错误的连接错误。

接收到字段长度不是8的PING帧必须作为类型为帧大小错误的连接错误处理。

### 6.8 GOAWAY

超时帧(type=0x7)通知远端对等端不要在这个连接上建立新流。超时帧可以由客户端或者服务端发送。一旦发送，发动端将忽略当前连接上新的流的帧的发送。接收端接收到超时帧后绝对不能在这个连接上打开新的流，但是可以针对新的流创建一个新的连接。这个帧的目的是允许终端优雅的停止接收新的流(也许是重新启动或者维护)，但仍然接续完成之前已经建立的流的处理。

在终端启动新的流及远端发送超时帧之间有一个内在的竞争条件。为了处理这种情况，超时帧带有当前连接中发送终端处理的最后一个流的标识。如果超时帧的接收端使用了比指定的流更新的流，它们将不会被发送端处理，而且接收端可以认为这些流根本没有被创建(因此接收端可以稍后在新的连接上重新创建这些流)。

终端在关闭一个连接之前总是应当发送一个超时帧，这样远端就能知道一个流是否已被部分处理。例如，如果一个HTTP客户端在服务端关闭连接的时候发送了一个POST请求，如果服务端不发送一个指示它在哪里停止工作的超时帧，客户端将不知道这个POST请求是否被处理。对于不规范的对等端，终端可以选择不发送超时帧的情况下关闭连接。

发送超时帧后，发送端可以丢弃新流的帧。然而，任何改变连接状态的帧不能被完全忽略。例如，报头、PUSH_PROMISE和延续帧必须被最低限度的处理以确保一致的压缩状态(见HeaderBlock)；相似的数据帧必须被计入连接流量控制窗口。

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |X|                  Last-Stream-ID (31)                        |
 +-+-------------------------------------------------------------+
 |                      Error Code (32)                          |
 +---------------------------------------------------------------+
 |                  Additional Debug Data (*)                    |
 +---------------------------------------------------------------+
```

超时帧没有定义任何标记。

超时帧适用于连接而不是特定的流。终端接收到流标识符不是0x0的超时帧必须作为类型为协议错误的连接错误处理。

超时帧中最后一个流的标识包含了接收端接收到并可能已经进行某些处理的流的标识的最大值。所有小于或等于此指定标识符的流都可能通过某种方式被处理。如果没有流被处理，最后流的标识符设置为0。

`注意`：这个案例中，“已处理”表示流中的某些数据已经被传到软件的更高的层并被进行某些处理。

如果连接在没有超时帧的情况下终止，这个值有效的是最大的流标识符。

连接关闭前小于或等于标识符上的流没有完全关闭的，重试请求，交换，或者任何协议活动都是不可能的(例如HTTP GET,PUT,或者删除等等幂行为例外)。任何使用更高的流数值的协议行为可以在新的连接上安全地重试。

小于或等于最后流标识符上的流的活动可能仍然能成功完成。超时帧的发送端可能通过发送超时帧优雅地关闭了连接，保持连接在打开状态直到正在处理的流全部处理完成。

如果没有流起作用，最后流的ID必须是0。

如果终端保持了连接并且继续交换帧，忽略的帧必须被计入流量控制限制或者更新报头压缩状态。否则，流量控制或者报头压缩状态可能会不同步。

超时帧同样包含一个32位的错误码，里面包含了关闭连接的原因。

终端可以在超时帧载体上附加不透明数据。额外的调试数据仅用来诊断没有语义值。调试信息可以包含安全或者隐私敏感的数据。登录或者其他持续存储的数据必须有足够的保障措施，以防止未经授权的访问。

### 6.9 WINDOW_UPDATE

WINDOW_UPDATE帧(type=0x8)用来实现流量控制；概述见FlowControl。

流量控制在两种层面上操作：每个单独的流或者整个连接。

所有类型的流量控制都是逐跳的；就是说，只在两个终端之间作用。中介者不在依赖的连接上转接WINDOW_UPDATE帧。接收端对数据的显示可以直接导致流量控制信息的传播转到原始发送端。

流量控制只适用于确定受流量控制影响的帧。文档中定义的帧类型中，只包括数据帧。不受流量控制的帧必须被接收和处理，除非接收端无法为帧分配资源。接收端如果无法接收帧，可以响应一个流错误或者类型为流量控制错误的连接错误。

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |X|              Window Size Increment (31)                     |
 +-+-------------------------------------------------------------+
```

WINDOW_UPDATE帧的载体是一个保留字节，加上一个无符号32为整数表明发送端除了现有的流量控制窗口可以发送的字节数。留空控制窗口有效的增量范围是$1 至 2^{31}-1$(0x7fffffff) 字节。

WINDOW_UPDATE帧没有定义任何标记。

WINDOW_UPDATE可以专指某个流或者整个连接。在前者的情况下，帧的流标识符指的是被影响的流；在后者情况下，值"0"表示整个连接都受这个帧的影响。

WINDOW_UPDATE可以由一个已经发送带有END_STREAM标记的帧的对等端来发送。这意味着接收端可以在“半封闭(远程)”或者“关闭”的流上接收WINDOW_UPDATE帧。接收端绝对不能作为错误处理，见StreamStates

接收端收到受流量控制的帧必须总是计算流量对整个连接流量控制的影响量，除非接收端将这作为连接错误处理。即使帧出错这也是必须的。因为发送端将这个帧计入了流量控制窗口，如果接收端没有这样做，发送端和接收端的流量控制会不相同。

#### 6.9.1 The Flow Control Window

HTTP/2中流量控制是通过每个发送端在每个流上携带一个窗口来实现的。流量控制窗口是一个简单的整数值，指示发送端被允许传输的字节数；因此，它的大小是接收端的缓存能力的衡量。

流量控制窗口对流和连接的流量控制窗口都适用。发送端绝对不能发送超出接收端广播的流量控制窗口大小的可用空间长度的受流量控制影响的帧。在各个流量控制窗口中没有可用空间时，可以发送带有END_STREAM标记的长度为0的帧(例如，空数据帧)。

流量控制计算中，8字节的帧报头不被计入。

在发送一个流量控制帧后，发送端在各个窗口中可用空间中减去发送的帧长度。

接收端发送一个WINDOW_UPDATE帧因为它消耗并释放了流量控制窗口的空间。单独的WINDOW_UPDATE帧用于流及连接层面的流量控制窗口中。

发送端收到WINDOW_UPDATE后按帧中指定的大小更新到正确的窗口。

发送端绝对不允许流量控制窗口超过2的31次方-1字节。如果发送端接收到WINDOW_UPDATE使得流量控制窗口超过这个最大值，它必须适当地终止这个流或者这个连接。对于流，发送端发送一个带有流量控制错误的错误码的ST_STREAM帧；对于连接，发送一个带有流量控制错误码的超时帧。

发送端发送的受流量控制的帧以及接收端收到的WINDOW_UPDATE帧是完全异步的并且相互认可对方的值。这种属性让接收端积极的更新发送端携带的窗口大小来防止流停转。

#### 6.9.2  Initial Flow Control Window Size

HTTP/2连接初次建立时，新的流创建的初始化流量控制大小是65,535字节。连接的流量控制大小是65,535字节。两个终端都能通过在组成连接序言的设置帧中携带一个SETTINGS_INITIAL_WINDOW_SIZE设置调整新流的初始化窗口大小。连接的流量控制初始化大小不能被修改。

在收到设置帧指定SETTINGS_INITIAL_WINDOW_SIZE前，终端只能只有流量控制的默认窗口值。类似的，连接的流量控制窗口初始化时也是默认值知道收到WINDOW_UPDATE帧。

设置帧可以针对所有当前的流修改流量控制初始化大小。当SETTINGS_INITIAL_WINDOW_SIZE值改变时，接收端必须将根据新旧值调整其保留的所有流的窗口大小设置帧不能修改连接的流量控制窗口。

终端必须将SETTINGS_INITIAL_WINDOW_SIZE的修改导致流量控制窗口超过最大值的情况作为类型为流量控制错误的连接错误处理。

SETTINGS_INITIAL_WINDOW_SIZE的改变可能导致流量控制窗口中的可用空间变成负数。发送端必须记录负数的流量控制窗口，并且在收到WINDOW_UPDATE帧使流量控制窗口变成正数前绝对不能发送新的受流量控制的帧。

例如，如果终端在当前建立的连接上立即发送了60KB,然后服务器设置初始化窗口大小是16KB,那么客户端在接收到设置帧后计算的流量控制窗口的可用空间就是-44KB。客户端在收到WINDOW_UPDATE帧使得窗口重新变为证书钱一直保留负数的流量控制窗口，在这之后客户端可以重新发送数据。

#### 6.9.3 Reducing the Stream Window Size

接收端希望使用比当前大小更小的流量控制窗口可以发送一个新的设置帧。然而，接收端必须准备好接收超过窗口大小的数据，因为发送端在处理设置帧之前发送了超过更低限制大小的数据。

在发送见效初始化流量控制窗口大小的设置后，接收端有两种选择处理流超过流量限制的情况：

 1. 接收端可以针对受影响的流立即发送带有流量控制错误错误码的RST_STREAM帧。
 2. 接收端如果在消耗数据可以接受流并且忍受报头阻塞的结果，并发送WINDOW_UPDATE帧。

### 6.10 CONTINUATION

延续帧(type=0x9)用来延续一个报头区块碎片序列。在现有流上可以发送任意数量的延续帧，只要相同流上的前一阵是报头帧、推送承诺帧或者不带有END_HEADERS标记的延续帧。

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | [Pad High(8)] | [Pad Low (8)] |  Header Block Fragment (*)    .
 +---------------+---------------+-------------------------------+
 |                   Header Block Fragment (*)                 ...
 +---------------------------------------------------------------+
 |                           Padding (*)                       ...
 +---------------------------------------------------------------+
```

延续帧载体有以下字段：

 - **Pad High** : 填充大小高位。这个字段只有在设置PAD_HIGH标记的情况下才呈现。
 - **Pad Low** : 填充大小低位。这个字段只有在设置PAD_LOW标记的情况下才呈现。
 - **Header Block Fragment** : 报头区块碎片。
 - **Padding** : 填充字节。

延续帧定义了以下状态：

 - **END_HEADERS (0x4)** : 位3表示是报头区块的终止。
如果没有设置END_HEADERS位，那么帧后面必须跟着其他延续帧。接收到收到任何其他类型或者其他流觞的帧必须作为类型为协议错误的连接错误处理。
 - **PAD_LOW (0x10)** : 位5表示Pad Low字段已设置。
 - **PAD_HIGH (0x20)** : 位6表示Pad High字段已设置。这个位绝对不能在没有设置PAD_LOW标记的情况下设置。终端接收到带有PAD_HIGH设置但是不带PAD_LOW设置的必须作为类型为协议错误的连接错误处理。

延续帧的载体包含一个报头区块碎片。

延续帧改变连接状态如HeaderBlock中定义。

延续帧必须与流相关联。如果延续帧的相关流表示字段是0x0，终端必须响应一个类型为协议错误的连接错误。

延续帧必须跟在不带有END_HEADERS设置的报头帧、推送承诺帧或延续帧后面。终端接收到不符合此规则的必须响应一个类型为协议错误的连接错误。

延续帧的填充是可选的。填充字段额标记同数据帧中定义。

### 6.11 ALTSVC

TODO

## 7 Error Codes

错误码是32位字段，用在RST_STREAM和超时帧中用来标识流或者链接错误的原因。

错误码共享一个功能的代码空间。一些错误代码只适用于特定的条件，在某些帧类型没有定义的语义。

定义了以下错误码：

 - **NO_ERROR (0)** ： 相关的条件并不是错误的结果。例如超时帧可以携带此错误码指示连接的平滑关闭。
 - **PROTOCOL_ERROR (1)** : 终端检测到一个不确定的协议错误。这个错误用在一个更具体的错误码不可用的时候。
 - **INTERNAL_ERROR (2)** : 终端遇到意外的内部错误。
 - **FLOW_CONTROL_ERROR (3)** : 终端检测到对等端违反了流量控制协议。
 - **SETTINGS_TIMEOUT (4)** : 终端发送了设置帧，但是没有及时收到响应。见Settings Synchronization。
 - **STREAM_CLOSED (5)** : 终端在流半封闭的时候收到帧。
 - **FRAME_SIZE_ERROR (6)** : 终端收到大小超过最大尺寸的帧。
 - **REFUSED_STREAM (7)** : 终端拒绝流执行任何应用处理，详见Reliability
 - **CANCEL (8)** : 终端使用这个标示某个流不再需要。
 - **COMPRESSION_ERROR (9)** : 终端无法保持连接的压缩上下文。
 - **CONNECT_ERROR (10)** : 响应某个连接请求建立的连接被服为异常关闭。
 - **ENHANCE_YOUR_CALM (11)** : 终端检测出对等端在给定时间内表现出行为导致其拒绝处理更多帧。
 - **INADEQUATE_SECURITY (12)** ： 基础传输包含属性不满足文档或者终端申明的最小要求。

## 8 HTTP Message Exchanges

HTTP/2的目的是尽可能的就按容目前使用的HTTP。这意味着，从服务端或者客户端应用的角度来看，该协议的特定是不变的。为了实现这点，所有响应与请求的语义都将保留，尽管包含这些语义的语法已经改变。

因此，HTTP/1.1语义与内容、有条件的请求、范围请求、缓存与验证定义的规范与要求同样适用于HTTP/2.HTTP/1.1消息语法与路由选定的内容，例如HTTP与HTTPS URI方案，也同样适用于HTTP/2，但是表达这些协议的语义在下面的章节定义。

### 8.1 HTTP Request/Response Exchange

客户端在一个新的流上发起HTTP请求，使用以前未使用的流标示。服务端在同个流上发起HTTP响应。

一个HTTP消息(请求或相应)包含：

 1. 一个报头帧，后面跟着0个或多个延续帧(包含消息报头;见xx),以及
 2. 0个或多个数据帧(包含消息载荷，见),以及
 3. 一个可选的吧哦哦图真，后面跟着0个或多个延续帧(如果存在，包含尾部部分，见xxx)

序列中的最后一帧具有END_STREAM标记，但是包含END_STREAM标记的报头帧后面可以跟着包含任意报头部分的延续帧。

其他帧(来自任何流的)绝对不能出现在任意报头帧和延续帧(如果存在)之间,也不能出现在延续帧中间。

否则，流上的这些帧可能被打散，但是那些帧并不包含HTTP语义。特别是，报头帧(及任何跟在后面的延续帧)序列中第一帧及可选的最后一帧以外的并不包含HTTP语义。

报头区块中的报头尾部字段同样终止流。就是说，一个报头帧开始的序列，后面跟着0个或者多个带有END_STREAM标记的延续帧。第一个不终止流后面的报头区块不是当前HTTP请求与响应的一部分。

一个HTTP 请求/响应的数据交换在同一个流上进行。一个请求由是流进入打开状态的报头帧开始，并由一个携带使流对客户端进入半封闭的END_STREAM标记的帧结束，另外可选的后面可以跟着延续帧，使流进入关闭状态。

#### 8.1.1 Informational Responses

1xx系列的HTTP响应状态码在HTTP/2中不支持。

1xx最常见的用法是使用一个带有100-继续临牌(通俗的，“期待/继续”)的期望报头字段来表明客户端期望一个100(继续)非最终响应的状态码，收到这个表示客户端如果没有发送完应当继续发送请求正文。

通常来说，期望/继续帧被客户端用来希望避免在请求正文中发送大量数据，只用来让请求被源服务器拒绝(因此让连接可能不可用)。

HTTP/2不支持期望/继续机制；如果服务端发送一个最终状态码来拒绝请求，它可以在不需要使当前连接不可用的情况下做到这个。

需要注意的是这意味着，HTTP/2客户端发送带有请求正文的请求在连接被拒绝时可能浪费至少一个发送数据的RTT时间。这可以通过限制带宽受限的客户端第一个RTT的数据大小来缓和，通过预期的最终状态码实现。

其他定义的1xx状态码也不适用于HTTP/2。例如，101(转换协议)的语义不适用于多路复用协议。同样的，102(处理中)也不在需要，因为HTTP/2有单独的保持连接可用的方式。

这些不同协议版本之间的差异需要被中介端在转换时特殊处理：

 - 转换HTTP/1.1到HTTP/2的中介网关如果收到请求包含带有100-继续令牌的期望报头字段，必须生成一个100(继续)响应，除非它能马上生成一个最终状态码。绝对不能转发请求报头中的100-继续期望字段。
 - 转换HTTP/2到HTTP/1.1的中介网关在转发一个带有正文的请求时可以添加一个带有100-继续的期望报头字段。特定要求见xxx.
 - 转换HTTP/2到HTTP/1.1的中介网关必须丢弃所有1xx以外的响应信息。

#### 8.1.2 Examples

这个部分介绍了HTTP/1.1的请求与响应，并带有HTTP/2请求与响应的插图。

一个带有请求报头字段但没有正文的HTTP GET请求将被转换成一个单独的报头帧，后面跟着0个或者多个包含序列化的报头字段区块的延续帧。序列中最后一个报头帧将有END_HEADERS和END_STREAM标记。

```
  GET /resource HTTP/1.1           HEADERS
  Host: example.org          ==>     + END_STREAM
  Accept: image/jpeg                 + END_HEADERS
                                       :method = GET
                                       :scheme = https
                                       :path = /resource
                                       host = example.org
                                       accept = image/jpeg
```

相似的，只带有报头字段的响应将被转换成一个报头帧(同样的，后面跟着0个护着多个延续帧)，且包含序列化的响应报头字段区块。序列中最后一个报头帧将有END_HEADERS和END_STREAM标记。

```
  HTTP/1.1 304 Not Modified        HEADERS
  ETag: "xyzzy"              ==>     + END_STREAM
  Expires: Thu, 23 Jan ...           + END_HEADERS
                                       :status = 304
                                       etag: "xyzzy"
                                       expires: Thu, 23 Jan ...
```

带有报头和载荷数据的POST HTTP请求将被转换成一个报头帧，后面跟着一个或者多个带有请求报头字段的延续帧，同时后面跟着一个或者多个数据帧。延续帧或者报头帧的最后一帧有END_HEADERS标记，最后一个数据帧拥有END_STREAM标记。

```
 POST /resource HTTP/1.1          HEADERS
  Host: example.org          ==>     - END_STREAM
  Content-Type: image/jpeg           + END_HEADERS
  Content-Length: 123                  :method = POST
                                       :scheme = https
  {binary data}                        :path = /resource
                                       :authority = example.org
                                       content-type = image/jpeg
                                       content-length = 123

                                   DATA
                                     + END_STREAM
                                   {binary data}
```

带有报头字段及载荷数据的响应将被转换成一个报头帧，后面跟着0个或多个延续帧，另外后面跟着一个或多个数据帧，序列中的最后一个数据帧拥有END_STREAM标记。

```
  HTTP/1.1 200 OK                  HEADERS
  Content-Type: image/jpeg   ==>     - END_STREAM
  Content-Length: 123                + END_HEADERS
                                       :status = 200
  {binary data}                        content-type = image/jpeg
                                       content-length = 123

                                   DATA
                                     + END_STREAM
                                   {binary data}
```

所有的请求或者响应报头区块以及所有的数据帧发送之后，尾报头字段作为一个报头区块发送。带有尾部的报头/延续帧序列包含一个带有END_HEADERS及END_STREAM标记的终止帧。

```
  HTTP/1.1 200 OK                  HEADERS
  Content-Type: image/jpeg   ==>     - END_STREAM
  Transfer-Encoding: chunked         + END_HEADERS
  Trailer: Foo                         :status        = 200
                                       content-length = 123
  123                                  content-type   = image/jpeg
  {binary data}                        trailer        = Foo
  0
  Foo: bar                         DATA
                                     - END_STREAM
                                   {binary data}

                                   HEADERS
                                     + END_STREAM
                                     + END_HEADERS
                                       foo: bar
```

HTTP报头字段以一系列键值对的形式携带信息。指定的报头字段列表，见xx中维护的消息报头字段注册表。

 HTTP/1.x使用消息开始线(见xxx)来传达目标URI、请求的方法及相应状态码。但HTTP/2使用特殊的以":"开始的伪头部来实现这些任务。

正如HTTP/1.x中，报头字段名称是ASCII字符，且不区分大小写。然而，HTTP/2中报头字段名称必须转成使用同样编码的小写字符。带有大写报头字段的请求或者响应必须被认为是不规范的。

HTTP/2不使用连接报头字段来指示“逐跳”的报头字段；在该协议中，连接特定的元数据是通过其他手段传输的。因此，包含连接的HTTP/2消息必须被认为是不规范的。

这意味着中介端转换一个HTTP/1.x消息到HTTP/2需要移除由连接报头字段指定的任何报头字段，包含连接报头字段本身。这样的中介端同样应当移除其他连接特定的报头字段，例如Keep-Alive、Proxy-Connection、Transfer-Encoding和Upgrade，即便它们不是由连接指定的。

一个例外是TE报头字段，这个可能在 HTTP/2 请求中保留，但是它不能包含“trailers”以外的值。

`Note:` :  HTTP/2不支持升级到其他协议。3章节中描述的握手协议被认为足够用来作为替代协议使用。

##### 8.1.3.1 Request Header Fields

HTTP/2定义了一个以字符“:”开头的报头域，包含目标请求的信息：

 - :method 报头字段包含了HTTP方法
 - :scheme字段包含了目标URI方案部分。
 - :authority报头字段包含了目标URI的权限部分。这个权限绝对不能包含http:或者https: URIs的废弃的用户信息子成份。
为了保证HTTP/1.1请求行能被精确复制，当原始请求有请求目标或者星号形式(见[ http-p1 ]，5.3节)的HTTP/1.1请求进行转换时这个字段必须被忽略。客户端直接生成HTTP/2请求的相反应该忽略Host报头字段。如果其中一个请求没有Host字段，中介端将HTTP/2请求转换为HTTP/1.1请求的时候必须复制:authority字段的值来生成Host字段。
 - :path字段包含目标URI的路径及查询部分(绝对路径由[RFC3986]以及可选的‘?’字符后面跟着查询词组成见xx)。这个字段绝对不能为空；URI不包含path组件的必须包含一个'/'值，除非请求是一个星号形式的可选请求：这种情况下:path报头字段必须包含"*"。

所有的HTTP/2请求都必须在:method、:scheme和:path字段上有准确的值，除非是一个连接请求。缺少基本报头字段的HTTP请求是不规范的。

以冒号开头的报头字段只在HTTP/2上下文中有效。这些不是HTTP报头字段。实现的时候绝对不能生成以冒号开头的报头字段，但是他们必须忽略任何以冒号开头的报头字段。特别是，名称以冒号开头的报头字段绝对不能暴露在HTTP报头字段中。

HTTP/2没有定义中方式来包含版本标识，这个已经在HTTP/1.1请求行中包含。

##### 8.1.3.2 Response Header Fields

一个单一的:status字段定义用来携带HTTP状态码字段(见xxx)。这个报头字段必须包含在所有响应中，除非响应是不规范的。

HTTP/2没有定义一种方式来携带版本或原因短语，这些已经在HTTP/1.1状态行中包含。

##### 8.1.3.3 Header Field Ordering

HTTP报头压缩并不保留报头字段的顺序，因为不同名称的字段的相对位置并不重要。然而，当相同字段重复组成一个列表的时候(见xxx)，报头字段值的相对位置就有意义。这种重复会出现在以逗号分隔的单个报头字段值列表中，或者作为几个报头字段的单一值，或他们的任何组合。因此，再后者情况下，报头需在再压缩前保留字段顺序。

为了保留同个名称的报头字段出现多次的顺序，他们的顺序使用单个以零值字节(0x0)分隔的值连接来保留。

解压缩后，报头字段包含有0字节的必须分割成多个报头字段之后才能进一步处理。

例如，下面的HTTP/1.x报头区块：

```
              Content-Type: text/html
              Cache-Control: max-age=60, private
              Cache-Control: must-revalidate
```

包含三个缓存控制指令；两个在第一个缓存控制报头字段，一个在第二个缓存控制字段。在压缩前，它们需要转成类似格式("\0"表示0x0):

```
cache-control: max-age=60, private\0must-revalidate
              content-type: text/html
```

注意这里内容类型与缓存控制的顺序是不保留的，但是缓存控制指令的相对顺序——事实上也就是前两个是用逗号分隔，而后一个是在不一样的行——是保留的。

报头字段包含多个值必须组成单个值，除非报头字段的顺序是不重要的。

特殊情况是设置cookie——不需要形成一个逗号分隔的列表，但是可以有多个值——不需要依赖顺序。设置cookie字段可以被编码成多行报头字段值，或者单个的连接值。

##### 8.1.3.4 Compressing the Cookie Header Field

Cookie报头字段可以携带大量的冗余数据。

Cookie字段使用“;”来分割cookie-对(或叫面包屑)。这报头字段不遵循HTTP中的构建规则(见xxx)，以防cookie-对被分隔成不同的键值对。单个cookie-对更新的时候能显著提升压缩效率。

为了更好的压缩效率，Cookie字段可以被分隔成多个报头字段，每个包含一个或者多个cookie对。如果解压后有多个Cookie报头字段，他们必须由两个字节的0x3B, 0x20(ASCII";")连接成单个字段。

Coookie报头字段也可以使用0值字节(0x0)来分割，同HeaderOrdering中定义。当解码的时候，0值字节必须被替换成Cookie的分隔符(";")。

##### 8.1.3.5 Malformed Messages

不规范的请求或者响应是一个使用了有效序列的HTTP/2帧，但是使用了禁止的报头字段、必须字段缺失或者字段名称使用了大写。

包含实体的请求或者响应可以保护一个实体内容长度的报头字段。如果内容长度报头字段的值不等于组成实体的数据帧载荷长度，同样是不规范的。

中介者处理HTTP请求或者响应(除了用来作为隧道的所有中介者)绝对不能转发一个不规范的请求或者响应。

中介者检测到不规范的请求或者响应必须保证流已经终止。对于不规范的请求，服务端可以发送之前提到的响应来关闭或者重置流。客户端绝对不能接收一个不规范的响应。请注意，这些要求是为了防止一些针对HTTP的常见攻击；故意这么严格，是因为允许这些情况的话可能会暴露这些漏洞的实现。

#### 8.1.4 Request Reliability Mechanisms in HTTP/2

在HTTP/1.1中，HTTP客户端在发送错误时不能重试一个非幂等的请求，因为没有方式来确定错误的性质。有可能服务器在错误之前正在处理，如果请求重试可能导致不良影响。

HTTP/2提供了两种机制来确保让客户端知道请求没有被处理:

 - 超时帧指示了流可能被处理的最大流流标示。在更大数字的流上的请求可以保证安全的重试。
 - RST_STREAM帧中可以包含REFUSED_STREAM错误码来指示流由于之前的处理正在关闭。重置流上的任何请求都可以安全重试。

未经处理的请求且没有失败；客户可以自动重试，甚至包括那些非幂等元的方法。

服务端绝对不能表示一个流未被处理除非它能确保这个事实。如果流上的帧被传递给应用层的任何流，绝对不能在这个流上使用REFUSED_STREAM，而且一个超时帧必须包含一个大于或等于给定流表示的标识符。

除了这些机制，PING帧给客户的提供了一种方式来简单测试连接。保持空闲的连接可能被一些中间件(例如网络地址翻译或负载均衡器)静默丢弃连接绑定而打破。PING帧允许客户端在无需发送请求的情况下安全地测试连接是否依旧激活。

### 8.2 Server Push

HTTP/2允许服务端针对客户端一个单独的请求，主动的发送(或推送)一个或者多个相关的响应。这种特定在服务端知道客户端需要这些响应来完整的处理最初的请求的时候特别有用。

推送额外的响应是可选的，并且由单独的终端之间协商。SETTINGS_ENABLE_PUSH设置设置为0来标识服务端推送是可用的。

因为推送的响应只在逐跳情况下有效，中介端接从服务端接收到推送响应的可以选择不转发这些到客户端。也就是说，如何使用推送响应取决于这些中介端。相等的，中介可能选择不推送的额外的响应给客户端，不需要服务端进行任何操作。

客户端不能推送。因此，服务端收到客户端的PUSH_PROMISE帧必须作为连接错误处理。客户端不许拒绝任何尝试修改SETTINGS_ENABLE_PUSH设置值为0以外的值，并将这消息作为类型为协议错误的连接错误处理。

服务端智能推送被缓存的响应(见xxx);被承诺的请求必须是安全的，而且绝对不能包含一个请求主体。

#### 8.2.1 Push Requests

服务端推送语义上等同于服务端响应一个请求；然而，这种情况下请求也是由服务端发送的，作为一个PUSH_PROMISE帧。

PUSH_PROMISE包含了一个报头区块，含有完整的服务端属性请求报头字段。不可能对带有请求实体的请求进行推送。

推送的响应总是与客户端的一个明确的请求相关。服务端在这个明确的请求流上发送PUSH_PROMISE帧。PUSH_PROMISE帧一般包含被承诺的流标识符，从可用的服务端流标识符中选择(见xxx)。

在PUSH_PROMISE或者任何其他延续的帧中的报头字段必须是完整的请求报头字段。服务端必须在:method字段中包含一个安全而且可缓存的方法。如何客户端收到不包含完整而且有效的报头字段的PUSH_PROMISE帧、或者:method表示的方法不是安全的，客户端必须响应一个类型为协议错误的流错误。

服务端应当在发送任何被承诺的响应之前发送一个PUSH_PROMISE帧。这避免了客户端在收到任何PUSH_PROMISE帧前发出请求而出现的竞赛。

例如：如果服务端收到文档请求包含多个嵌入式的图像链接，而且服务端选择推送那些额外的图像给客户端，再数据帧前发送push promises能确保客户端能够在发现内嵌链接前看到这些承诺。类似的，如果服务端推送与报头区块(例如，在Link报头域)相关的响应，再发送报头区块前推送承诺能确保客户端不请求它们。

PUSH_PROMISE帧绝对不能由客户端发送。PUSH_PROMISE可以由服务端在任意由客户端打开的流上发送。他们必须在对服务端状态为“打开”或者“半封闭(远端)”的流上发送。PUSH_PROMISE帧由响应帧穿插组成，不过他们不能由包含单个报头区块的报头帧和延续帧组成。

#### 8.2.2 Push Responses

发送PUSH_PROMISE帧后，服务端可以开始传送推送响应作为一个响应，在由服务端初始化的使用被承诺的流标识符的流上传送。服务端使用这些流传送一个HTTP响应，使用HttpSequence中定义的相同的帧序列。在初始化报头帧发送后，流对客户端变为“半封闭”状态。

一旦客户端接收到PUSH_PROMISE帧并且选择接受推送的响应，客户端不应该对被承诺的响应发起人和请求，直到被承诺的流被关闭为止。

如果客户端以任何理由决定不希望接受服务端推送的响应，或者服务端花费太长时间才开始发送承诺的响应，客户端可以发送一个RST_STREAM帧，使用CANCEL或者REFUSED_STREAM码来关联被推送的流标识符。

客户端可以使用SETTINGS_MAX_CONCURRENT_STREAMS设置来限制服务端推送的响应的并发量。广播值为0的SETTINGS_MAX_CONCURRENT_STREAMS能防止服务端创建必需的流。这不能禁止服务端发送PUSH_PROMISE帧；客户端需要重置任何不需要的被承诺的流。

客户端收到推送响应必须验证服务端是授权提供响应的，见authority。例如，服务端只带有针对example.com的DNS的授权证书是不允许给https://www.example.org/doc推送给响应的。

### 8.3 The CONNECT Method

在HTTP/1.x中，伪方法连接()用来转换HTTP连接成隧道到远端主机。连接主要用HTTP代理为使用HTTPS资源相互作用的目的源服务器建立TLS会话。

在HTTP/2中，连接方法用来在一个单一的HTTP/2流上建立一个通向远端主机的隧道，目的类似。HTTP报头字段寻址工作大部分同请求报头字段中定义，有一部分不同。具体为：

 - :method是连接中包含:method报头字段。
 - :scheme和:path报头字段必须被忽略。
 - :authority报头字段包含主机及连接的端口(相当于authority形式的请求目标连接请求，见xxx)。

支持CONNECT的端口建立一个TCP连接到服务器，如:authority报头字段中定义。一旦连接建立成功，代理发送一个报头帧包含一个2xx序列状态码到客户端，如xxx中定义。

初始化报头帧由各个对等端发送后，所有随后的与数据对应的数据帧在TCP连接上发送。客户端发送的数据帧载荷由代理转换再发送给TCP服务器；从TCP服务器接收到的数据由代理组装成数据帧。数据帧或者流管理帧以外的帧(RST_STREAM、WINDOW_UPDATE和PRIORITY)绝对不能再建立的流上发送，如果收到这样的帧必须作为流错误处理。

TCP连接可以被各个对等端关闭。数据帧上的END_STREAM标记被认为与TCP FIN比特相同。客户端在收到带有END_STREAM标记的帧后被期望应该发送一个带有 END_STREAM标记的数据帧。代理接收到带有END_STREAM 标记的数据帧将在发送这些数据的时候在最后的TCP段上设置FIN位。带有接收到带有FIN位的TCP端发送一个带有END_STREAM标记的数据帧。注意最后的TCP端或者数据帧可以为空。

TCP连接错误由RST_STREAM来标记。代理对外TCP连接中的任何错误，包括接收到设置了RST位的TCP段，作为类型为连接错误的流错误处理。相应的，代理如果检测到流或者HTTP/2连接的错误必须发送一个设置了RST位的TCP段。

## 9 Additional HTTP Requirements/Considerations

这段概况了HTTP协议的属性，包括提高互操作性、减少暴露已知的安全漏洞，或者减少执行变动的可能。

### 9.1 Connection Management

HTTP/2连接是永久性的。为了最佳的性能，它期待客户端不会关闭连接，直到确定与服务端的进一步沟通不再必要(例如，当用户导航到其他特定的网页)，或者直到服务端关闭连接。

客户端不应该再给定的目的地上打开多个HTTP/2连接，目的地是由给定的URI确定的IP地址及TCP端口【这里我们需要小心Alt-Svc】，或者配置的代理的IP和端口。客户端可以创建额外的连接作为替代，或者取代快要用尽可用流标识空间的连接，或者替换遇到错误的连接。

客户端可以使用不相同的服务端名称标识值或者提供不一样的TLS客户端证书对相同IP地址及TCP端口打开多个连接，但应该避免对相同的配置上创建多个连接。关于客户端证书相关的更多信息，见xxx.

客户端可以使用单个的服务端连接来发送不同认证组件的URIs请求，只要服务端是认证的。

服务端被孤立尽可能长的保持打开的连接，但在必要下允许关闭空闲的连接。当任意一个终端决定关闭传输层的TCP连接，决定关闭的终端应首先发送一个GOAWAY帧这样两个终端都能可靠的确定之前发送的帧是否已经被处理及优雅的完成或者终止任何必要的剩余任务。

### 9.2 Use of TLS Features

实现HTTP/2必须支持TLS 1.2。通用的TLS用法指导应该遵循，同时加上对HTTP/2的特定支持。

TLS实现必须支持服务端名称标识(SNI)的TLS扩展。HTTP/2客户端再协商TLS的时候必须标明目标域名名称。

TLS实现必须禁止压缩。TLS压缩可能导致信息暴露。通用的压缩是不必要的，因为HTTP/2提供的压缩功能更加上下文，因为可能是更符合使用性能、安全或者其他原因。

实现必须歇山-因此使用短暂的密码套件，如短暂的Diffie-Hellman（DHE）或椭圆曲线的变体（ecdhe）具有最小尺寸的2048位（DHE）或128位的安全级别（ecdhe）。客户端必须接受多达4096位DHE尺寸。

实现不鼓励使用已知的存在漏洞的TLS密码套件进行协商，如RC4。

实现中与不符合本章要求或者任何基于策略的约束的TLS协商，都不应该协商HTTP/2。考虑下移除HTTP/2协议可能导致所有客户端提供的协议集合被移除。这个导致的协议协议协商错误，如xxx中描述。

由于实施的限制，不可能基于所有需求来使TLS协商失败。终端必须终止不符合TLS最小需求的TLS会话上建立的HTTP/2连接，并作为类型为INADEQUATE_SECURITY的连接错误处理。

### 9.3 GZip Content-Encoding

客户端必须支持HTTP响应体的Gzip压缩。不管接收白头字段的编码的值，服务端可以发送Gzip编码响应。一个压缩的响应还必须承担适当的内容编码报头字段。

## 10 Security Considerations

### 10.1 Server Authority 

客户端只有经过权限验证才能获取HTTP/2响应的资源。这在服务器推送中尤为重要，客户端在接收响应前验证PUSH_PROMISE帧。

HTTP/2依据HTTP/1.1权限定义来检测服务端是否有权限提供给定的响应，见xxx.这依赖于本地“HTTP”URI方案的域名解析，以及服务端提供的“https”方案验证。

客户端绝对不能以任何形式使用服务端提供的客户端没有权限的资源。

### 10.2 Cross-Protocol Attacks

在跨协议攻击中，攻击者使客户端在一种协议中向解析另一种协议的服务器启动一个交易。攻击者可能能够使交易看起来在第二种协议中是合法的。结合对web上下文的利用，这个可以针对保护不力的服务器在秘密网络下进行互动。

在ALPN验证下完成HTTP/2 TLS握手可以认为是足够的。ALPN提供了一个积极的指示说明服务器愿意处理HTTP/2,这有助于阻止基于TLS协议的攻击。

TLS中的加密使得攻击者很难控制明文协议中能被用来进行跨协议攻击的数据。

HTTP/2明文版本对于跨协议攻击具有最小的保护措施。连接序言(章节3.5)包含一个字符串，是用来迷惑HTTP/1.1服务器的，但是对于其他版本协议没有提供特殊保护。服务端愿意忽略包含升级字段的HTTP/1.1请求部分的可以认为是一次跨协议攻击。

### 10.3 中介者封装攻击

HTTP/2报头名称和值编码成带有长度前缀的字节序列。这使得HTTP/2能够携带任何字符串的字节作为报头字段的名称或值。中介端直接转换HTTP/2请求或响应到HTTP/1.1时可以允许HTTP/1.1消息创建的损坏。攻击者可以利用这个行为让中介端创建HTTP/1.1消息时带有非法报头字段、额外报头字段，甚至是完全伪造的新消息。

报头字段名称或值带有不被HTTP/1.1允许的字符，包括回车(U+000D)或者换行(U+000A),绝对不能被中介端逐行解析，见[HTTP-p1]定义，章节3.2.4.

从HTTP/1.x转换到HTTP/2不会被攻击者利用出现类似的情况。执行转换的中介端必须移除折叠obs的任何实例。

### 10.4 推送响应的缓存

推送响应并没有一个来自客户端的明确请求；请求是服务端从PUSH_PROMISE帧中提供的。

缓存推送响应可能是基于原始服务器的缓存控制报头字段的指导。然而，如果服务端主机包含多个用户可能会导致问题。例如，服务端可能为多个用户每个提供小部分的URI空间。

当多个用户共享同一台服务器时，该服务器必须确保用户不能推送没有权限使用的资源。如果不能确保这个将导致用户可能提供超出缓存以外的内容，覆盖用户实际有权限提供的内容。

源服务器没有权限的(见10.1章节)推送响应将不会被缓存或者使用。

### 10.5 拒绝服务的注意事项

HTTP/2连接可以要求使用比HTTP/1.1连接更大的资源。报头压缩和流量控制的使用取决于承诺的资源存储更大量的状态。这些功能的设置确保这些承诺的内存是严格限制的。处理能力不能在相同的高速缓存中被守护。

设置帧可能被滥用导致对等端花费额外的处理时间。这可能是毫无意义改变设置参数、设置多个未定义的参数，或者在同个帧中多次修改同个值。WINDOW_UPDATE 或 PRIORITY帧也可能被滥用导致资源的不必要的浪费。服务端可能在没有权限为客户端产生过量工作时错误地假定源服务器的ALTSVC帧。

大量的小或空的值可能被滥用导致对等端花费额外的时间处理报头帧。但需要注意的是有些使用是完全合法的，例如发送空数据帧结束流。

报头压缩也可能导致处理资源的浪费；见[COMPRESSION]查更多潜在滥用的细节。

设置参数的限制不能瞬间降低，这使终端对对等端暴露的行为可能超出新的限制。特别是，连接连接后瞬间，服务端设置的限制并不被客户端知道，而且客户端可能在不明显违反协议的情况下超出限制。

所有的这些功能，即设置的修改、小帧、报头压缩使用都是合法的。他们只有在不必要或者多余的使用时才会成为负担。

终端不监测这种行为可能暴露其遭受拒绝服务攻击的风险。具体实现应当跟踪这些功能的使用并限制它们的使用。终端可以对待这些可疑的活动作为类型为ENHANCE_YOUR_CALM的连接错误处理。

### 10.6 压缩的使用

HTTP/2允许更大的使用报头字段(见4.3章节)和响应主体(见9.3章节)的压缩。压缩可以使攻击者在相同上下文数据压缩的攻击控制下恢复秘密数据。

明文网络(例如[BREACH])下有针对压缩的明显攻击。攻击者诱导包含不同明文的多个请求，观察各个得到的密文的长度，当密码猜测是正确时就揭示了更短的长度。

 具体实现在一个安全通道通信时绝对不能压缩保密的和受攻击者控制的内容，除非对于各个数据源的压缩字典是不同的。绝对不能使用数据源可靠性不确定的压缩数据。

关于报头uziduan压缩的更多表述参照[COMPRESSION]

### 10.7 填充的使用

HTTP/2的填充不打算作为通用填充的替换，如可能在TLS [TLS12]提供的。多余的填充可能会适得其反。正确的应用依靠的是对于填充的数据有具体的认知。

为了减轻依靠压缩的攻击，禁用攻击可能是作为填充的最好对策。

填充可以用来混淆帧内容的实际大小，而且减少HTTP中的特殊攻击。例如，压缩的内容包含攻击者控制的明文和秘密数据的攻击(见xxx)。

使用填充可能导致比明显看起来的更少的保护。最好情况下，通过增加攻击者需要观察的帧的数量，填充能使得攻击者更难推断长度信息。但不正确的实现填充方案可能被轻松破解。特别是，带有可预测分布的随机填充提供保护非常小；或者填充的载荷是一个固定大小的公开信息做未来分布在固定大小的边界，这可能导致攻击者能控制明文的情况下破解。

中介端不应该移除填充，但中介如果是想提高填充的保护可以移除填充添加不同数量的填充量。

### 10.8 隐私注意事项

HTTP/2的一些特点导致观察者有机会观察单个客户端或服务器的行为。这包含设置的值、流量控制窗口的管理方式、优先分配流的方法、反应时间以及任何可选功能的处理。

至于这个可观察到的行为的差异，他们可以作为特定的客户端的指纹的基础，见《xxx》定义。

## 11 IANA Considerations

TODO

### 11.1 HTTP/2识别字符串的注册

这个文档在"应用层协议协商(ALPN)协议IDs"中的[TLSALPN]注册列表创建了两种HTTP/2标识符注册。

使用TLS时“h2”字符串标识HTTP/2:

 - 协议: TLS上的HTTP/2     
 - 标识序列 ： 0x68 0x32 ("h2")
 - 定义： 本文档(RFCXXX)
 - "h2c"字符串标识使用明文TCP时的HTTP/2:
 - 协议： TCP上的HTTP/2
 - 标识序列： 0x68 0x32 0x63 ("h2c")
 - 定义： 本文档(RFCXXX)

### 11.2 错误码注册

本文档建立了HTTP/2错误码注册表。“HTTP/2错误码”注册表管理一个32位空间。“HTTP/2错误码”注册表操作在“专家评审”政策下[RFC5226]。

错误码注册表必须包括错误码描述信息。专家评审建议检查新的注册可能复制现有的错误码信息。使用现有的错误码是被建议的，但没有规定。

新的注册应提供以下信息：

 - 错误码：32位错误码值
 - 名称： 错误码名称。指定一个错误码的名称是可选的。
 - 描述： 描述错误码的适用条件
 - 规范： 定义错误码规范的可选参考。

错误码等级初始表可以在第7章节中找到。

### 11.3 HTTP2设置报头字段注册

本章节注册永久消息报头字段注册[BCP90]中的HTTP2设置报头字段。

 - 报头字段名称： HTTP2-Settings
 - 应用层协议： http
 - 状态： 标准
 - 作者/修改操作者：LETF
 - 文档定义: 本文档3.2.1章节
 - 相关信息： 本字段只在HTTP/2客户端基于升级的协商中使用。

### 11.4 PRI方法注册

本章节注册HTTP方法注册[HTTP-p2]中的PRI方法。

 - 方法名称 ： PRI
 -  - 安全： 否
 - 幂等元 ： 否
 - 文档定义: 本文档3.5章节
 - 相关信息： 这个方法从不会被确切的客户端使用。该方法只在HTTP/1.1服务端或者中介端试图解析HTTP/2连接序言中使用。

