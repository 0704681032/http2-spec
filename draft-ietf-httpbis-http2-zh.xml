<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="lib/rfc2629.xslt"?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no" ?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes" ?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-index="no" ?>

<rfc ipr="trust200902"
     category="std"
     docName="draft-ietf-httpbis-http2-latest"
     x:maturity-level="proposed"
     xmlns:x="http://purl.org/net/xml2rfc/ext">
  <x:feedback template="mailto:ietf-http-wg@w3.org?subject={docname},%20%22{section}%22&amp;body=&lt;{ref}&gt;:"/>
  <front>
    <title abbrev="HTTP/2">Hypertext Transfer Protocol version 2</title>

    <author initials="M." surname="Belshe" fullname="Mike Belshe">
      <organization>Twist</organization>
      <address>
        <email>mbelshe@chromium.org</email>
      </address>
    </author>

    <author initials="R." surname="Peon" fullname="Roberto Peon">
      <organization>Google, Inc</organization>
      <address>
        <email>fenix@google.com</email>
      </address>
    </author>

    <author initials="M." surname="Thomson" fullname="Martin Thomson" role="editor">
      <organization>Mozilla</organization>
      <address>
        <postal>
          <street>Suite 300</street>
          <street>650 Castro Street</street>
          <city>Mountain View</city>
          <region>CA</region>
          <code>94041</code>
          <country>US</country>
        </postal>
        <email>martin.thomson@gmail.com</email>
      </address>
    </author>

    <date year="2014" />
    <area>Applications</area>
    <workgroup>HTTPbis</workgroup>
    <keyword>HTTP</keyword>
    <keyword>SPDY</keyword>
    <keyword>Web</keyword>

    <abstract>
      <t>
        This specification describes an optimized expression of the syntax of the Hypertext Transfer
        Protocol (HTTP). HTTP/2 enables a more efficient use of network resources and a reduced
        perception of latency by introducing header field compression and allowing multiple
        concurrent messages on the same connection. It also introduces unsolicited push of
        representations from servers to clients.

        本规范描述了一种优化的超文本传输协议(HTTP).HTTP/2通过引进首部字段压缩以及多路复用来更有效利用网络资源、减少感知延迟。另外同样介绍了服务器主动推送规范。
      </t>
      <t>
        This document is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.
        HTTP's existing semantics remain unchanged.

        本文档保持对HTTP/1.1的后向兼容，HTTP的现有的语义保持不变。
      </t>
    </abstract>

    <note title="Editorial Note (To be removed by RFC Editor)">
      <t>
        Discussion of this draft takes place on the HTTPBIS working group mailing list
        (ietf-http-wg@w3.org), which is archived at <eref
        target="http://lists.w3.org/Archives/Public/ietf-http-wg/"/>.

        该草案的HTTPBIS工作组的邮件组列表可以在此处找到<eref
        target="http://lists.w3.org/Archives/Public/ietf-http-wg/"/>.
      </t>
      <t>
        Working Group information can be found at <eref
        target="http://tools.ietf.org/wg/httpbis/"/>; that specific to HTTP/2 are at <eref
        target="http://http2.github.io/"/>.
      </t>
      <t>
        The changes in this draft are summarized in <xref
        target="change.log"/>.
      </t>
    </note>

  </front>

  <middle>
    <section anchor="intro" title="Introduction">

      <t>
        The Hypertext Transfer Protocol (HTTP) is a wildly successful protocol. However, the
        HTTP/1.1 message format (<xref target="HTTP-p1" x:fmt="," x:rel="#http.message"/>) was
        designed to be implemented with the tools at hand in the 1990s, not modern Web application
        performance. As such it has several characteristics that have a negative overall effect on
        application performance today.

        超文本传输协议（HTTP）是一个非常成功的协议。 然而，HTTP/1.1 是针对90年代的情况而不是现代web应用的性能而设计。因此它对现代应用程序的性能产生负面影响。
      </t>
      <t>
        In particular, HTTP/1.0 only allows one request to be outstanding at a time on a given
        connection.  HTTP/1.1 pipelining only partially addressed request concurrency and
        suffers from head-of-line blocking.  Therefore, clients that need to make many requests
        typically use multiple connections to a server in order to reduce latency.

        特别是，HTTP/1.0只允许一个请求建立在给定的连接上, HTTP/1.1管道只部分解决了请求并发和对头阻塞的问题.因此客户端需要通过多个请求多次请求服务器以减少延迟。
      </t>
      <t>
        Furthermore, HTTP/1.1 header fields are often repetitive and verbose, which, in addition to
        generating more or larger network packets, can cause the small initial TCP congestion window
        to quickly fill.  This can result in excessive latency when multiple requests are made on a
        single new TCP connection.

        此外，HTTP/1.1的报头字段经常重复和冗长，其中，为了产生更多或更大的网络数据包，可能会导致小的初始TCP拥塞窗口来快速填充。 当多个请求在一个新的TCP连接进行可能会导致过度的延迟。
      </t>
      <t>
        This document addresses these issues by defining an optimized mapping of HTTP's semantics to
        an underlying connection.  Specifically, it allows interleaving of request and response
        messages on the same connection and uses an efficient coding for HTTP header fields.  It
        also allows prioritization of requests, letting more important requests complete more
        quickly, further improving performance.

        该文通过定义一个基础连接的HTTP的语义优化的映射来解决这些问题。 具体地，它允许对请求和响应消息建立在同一连接，并使用高效率编码的HTTP报头字段。 它还允许请求的优先级，让更多的重要的要求更快速的完成，进一步提高了性能。
      </t>
      <t>
        The resulting protocol is designed to be more friendly to the network, because fewer TCP
        connections can be used in comparison to HTTP/1.x. This means less competition with other
        flows, and longer-lived connections, which in turn leads to better utilization of available
        network capacity.

        最终协议被设计为对网络更友好，因为相对HTTP/1.x使用了更少的连接。 这意味着与其他流更少的竞争和更长时间的连接,从而更有效地利用可用的网络容量。
      </t>
      <t>
        Finally, this encapsulation also enables more scalable processing of messages through use of
        binary message framing.

        最后，这种封装也通过使用二进制消息帧使信息处理更具扩展性。
      </t>
    </section>

    <section anchor="Overview" title="HTTP/2 Protocol Overview">
      <t>
        HTTP/2 provides an optimized transport for HTTP semantics.  HTTP/2 supports all of the core
        features of HTTP/1.1, but aims to be more efficient in several ways.

        HTTP/2 提供了对HTTP语义的优化运输。HTTP/2支持所有HTTP／1.1的核心特征，并且在某些方面更高效。
      </t>
      <t>
        The basic protocol unit in HTTP/2 is a <xref target="FrameHeader">frame</xref>.  Each frame
        has a different type and purpose.  For example, <x:ref>HEADERS</x:ref> and
        <x:ref>DATA</x:ref> frames form the basis of <xref target="HttpSequence">HTTP requests and
        responses</xref>; other frame types like <x:ref>SETTINGS</x:ref>,
        <x:ref>WINDOW_UPDATE</x:ref>, and <x:ref>PUSH_PROMISE</x:ref> are used in support of other
        HTTP/2 features.

        HTTP/2中基本的协议单位是<xref target="FrameHeader">帧</xref>。每个帧都有不同的类型和用途。例如，<x:ref>报头(HEADERS)</x:ref>和<x:ref>数据(DATA)</x:ref>帧组成了基本的<xref target="HttpSequence">HTTP 请求和响应</xref>；其他帧例如 <x:ref>设置(SETTINGS)</x:ref>,<x:ref>窗口更新(WINDOW_UPDATE)</x:ref>, 和<x:ref>推送承诺(PUSH_PROMISE)</x:ref> 是用来支持HTTP/2的其他功能。
      </t>
      <t>
        Multiplexing of requests is achieved by having each HTTP request-response exchanged assigned
        to a single <xref target="StreamsLayer">stream</xref>.  Streams are largely independent of
        each other, so a blocked or stalled request does not prevent progress on other requests.

        请求多路复用是通过给每个HTTP请求响应分配在一个<xref target="StreamsLayer">流</xref>上实现的。流在很大程度上是相互独立的，因此一个请求上的阻塞或终止并不会影响其他请求的处理。
      </t>
      <t>
        Flow control and prioritization ensure that it is possible to properly use multiplexed
        streams.  <xref target="FlowControl">Flow control</xref> helps to ensure that only data that
        can be used by a receiver is transmitted.  <xref
        target="StreamPriority">Prioritization</xref> ensures that limited resources can be directed
        to the most important requests first.

        流量控制和优先级能确保正确使用复用流。<xref target="FlowControl">流量控制</xref>确保数据只可以被传播的接收者使用。<xref target="StreamPriority">优先级</xref> 能确保有限的资源能被首先传送。
      </t>
      <t>
        HTTP/2 adds a new interaction mode, whereby a server can <xref target="PushResources">push
        responses to a client</xref>.  Server push allows a server to speculatively send a client
        data that the server anticipates the client will need, trading off some network usage
        against a potential latency gain.  The server does this by synthesizing a request, which it
        sends as a <x:ref>PUSH_PROMISE</x:ref> frame.  The server is then able to send a response to
        the synthetic request on an separate stream.

        HTTP/2添加了一种新的交互模式，即服务器能<xref target="PushResources">推送消息给客户端</xref>。服务器推送允许服务端预测客户端需要来发送数据给客户端，交换网络使用来阻止潜在的延迟增长。服务器通过复用一个以<x:ref>PUSH_PROMISE</x:ref> 帧发送的请求来实现。然后服务端可以在一个单独的流里面发送响应给这个合成的请求。

      </t>
      <t>
        Frames that contain HTTP header fields are <xref target="HeaderBlock">compressed</xref>.
        HTTP requests can be highly redundant, so compression can reduce the size of requests and
        responses significantly.

        帧包含的HTTP报头字段是被<xref target="HeaderBlock">压缩的</xref>。HTTP请求可能是高度冗余的，因此压缩能显著见效请求和响应的大小。
      </t>

      <section title="Document Organization">
        <t>
          The HTTP/2 specification is split into four parts:
          HTTP/2协议被分为以下两个部分：
          <list style="symbols">
            <t>
              <xref target="starting">Starting HTTP/2</xref> covers how an HTTP/2 connection is
              initiated.

              <xref target="starting">启动HTTP/2</xref>包含了一个HTTP/2连接是如何初始化的。
            </t>
            <t>
              The <xref target="FramingLayer">framing</xref> and <xref
              target="StreamsLayer">streams</xref> layers describe the way HTTP/2 frames are
              structured and formed into multiplexed streams.

              <xref target="FramingLayer">帧</xref> 和 <xref
              target="StreamsLayer">流</xref>层描述了 HTTP/2流是如何建立并形成复用流的。
            </t>
            <t>
              <xref target="frame-types">Frame</xref> and <xref target="ErrorCodes">error</xref>
              definitions include details of the frame and error types used in HTTP/2.

              <xref target="frame-types">帧</xref> 和 <xref target="ErrorCodes">错误码</xref>
              定义了HTTP/2中使用的流和错误类型的详细内容。
            </t>
            <t>
              <xref target="HTTPLayer">HTTP mappings</xref> and <xref target="HttpExtra">additional
              requirements</xref> describe how HTTP semantics are biao using frames and
              streams.

              <xref target="HTTPLayer">HTTP寻址</xref> 和 <xref target="HttpExtra">拓展需求</xref> 描述了HTTP语义化是如何由帧和流表达的。
          </t>
          </list>
        </t>
        <t>
          While some of the frame and stream layer concepts are isolated from HTTP, the intent is
          not to define a completely generic framing layer. The framing and streams layers are
          tailored to the needs of the HTTP protocol and server push.

          虽然一些帧和流层的概念是与HTTP隔离的，它的意图并不是定义一个完全通用的帧层。这些帧和流层是为了HTTP协议和服务端推送的需求定制的。
        </t>
      </section>

      <section title="Conventions and Terminology">
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD
          NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
          described in <xref target="RFC2119">RFC 2119</xref>.

          文档中出现的关键字“必须”，“必须不”，“要求”，“应”，“不应”，“应该”，“不应该”，“建议”，“或许”及“可选”的可在此找到解释<xref target="RFC2119">RFC 2119</xref>.
        </t>
        <t>
          All numeric values are in network byte order.  Values are unsigned unless otherwise
          indicated.  Literal values are provided in decimal or hexadecimal as appropriate.
          Hexadecimal literals are prefixed with <spanx style="verb">0x</spanx> to distinguish them
          from decimal literals.

          所有的数值都是按网络字节顺序。值是无符号的除非有另外说明。按情况提供十进制或十六进制的文本值。十六进制以前缀<spanx style="verb">0x</spanx>来区分。
        </t>
        <t>
          The following terms are used:

          文中术语包括：
          <list style="hanging">
            <t hangText="client:">
              The endpoint initiating the HTTP/2 connection.

              客户端：发起HTTP/2请求的端点
            </t>
            <t hangText="connection:">
              A transport-level connection between two endpoints.

              连接：在两个端点之间的传输层级别的连接。
            </t>
            <t hangText="connection error:">
              An error that affects the entire HTTP/2 connection.

              连接错误：HTTP/2连接整个过程中发生的错误
            </t>
            <t hangText="endpoint:">
              Either the client or server of the connection.

              端点：连接的客户端或服务器。
            </t>
            <t hangText="frame:">
              The smallest unit of communication within an HTTP/2 connection, consisting of a header
              and a variable-length sequence of bytes structured according to the frame type.

              帧：HTTP/2.0通信连接中的最小单元，包括根据帧类型结构的字节的报头和可变长度的序列。
            </t>
            <t hangText="peer:">
              An endpoint.  When discussing a particular endpoint, "peer" refers to the endpoint
              that is remote to the primary subject of discussion.

              对等端：一个端点。当讨论特定的端点时，“对等端”指的是讨论的主题的远程端点
            </t>
            <t hangText="receiver:">
              An endpoint that is receiving frames.

              接收端：正在接收帧的端点。
            </t>
            <t hangText="sender:">
              An endpoint that is transmitting frames.

              发送端：正在传输帧的端点
            </t>
            <t hangText="server:">
              The endpoint which did not initiate the HTTP/2 connection.

              服务端：不是启动HTTP/2连接的端点。
            </t>
            <t hangText="stream:">
              A bi-directional flow of frames across a virtual channel within the HTTP/2 connection.

              流：一个双向字节帧流穿过HTTP/2连接中的虚拟通道。
            </t>
            <t hangText="stream error:">
              An error on the individual HTTP/2 stream.

              流错误：一个HTTP/2流中错误
            </t>
          </list>
        </t>
      </section>
    </section>

    <section anchor="starting" title="Starting HTTP/2">
      <t>
        An HTTP/2 connection is an application level protocol running on top of a TCP connection
        (<xref target="TCP"/>). The client is the TCP connection initiator.

        一个HTTP/2连接是运行在TCP连接(<xref target="TCP"/>)上的应用层协议。客户端是TCP连接发起者。
      </t>
      <t>
        HTTP/2 uses the same "http" and "https" URI schemes used by HTTP/1.1. HTTP/2 shares the same
        default port numbers: 80 for "http" URIs and 443 for "https" URIs.  As a result,
        implementations processing requests for target resource URIs like <spanx
        style="verb">http://example.org/foo</spanx> or <spanx
        style="verb">https://example.com/bar</spanx> are required to first discover whether the
        upstream server (the immediate peer to which the client wishes to establish a connection)
        supports HTTP/2.

        HTTP/2使用与HTTP/1.1相同的"http" and "https" 资源标识符(URI)。使用相同的默认端口："http"80端口及“https”443端口。因此，实现对例如<spanx
        style="verb">http://example.org/foo</spanx>或<spanx
        style="verb">https://example.com/bar</spanx>目标资源的URI请求处理需要首先确定上游服务端(当前客户端希望建立连接的对等端)是否支持HTTP/2。
      </t>

      <t>
        The means by which support for HTTP/2 is determined is different for "http" and "https"
        URIs. Discovery for "http" URIs is described in <xref target="discover-http"/>.  Discovery
        for "https" URIs is described in <xref target="discover-https"/>.

        检测“http”及“https”的URIs是否支持HTTP/2的方法是不一样的。检测"http" URIs在<xref target="discover-http"/>中描述。检测"https" URIs在<xref target="discover-https"/>中描述。

      </t>

      <section anchor="versioning" title="HTTP/2 Version Identification">
        <t>
          The protocol defined in this document is identified using the string "h2".  This
          identification is used in the HTTP/1.1 Upgrade header field, in the <xref
          target="TLSALPN">TLS application layer protocol negotiation extension</xref> field, and
          other places where protocol identification is required.  When serialised into an ALPN
          protocol identifier (which is a sequence of octets), the "h2" string is encoded using
          <xref target="UTF-8">UTF-8</xref>.

          文档中定义的协议用字符"h2"标记。这种方式用在HTTP/1.1的升级字段、<xref
          target="TLSALPN">TLS 应用层协议协商扩展</xref>字段以及其他需要定义协议的地方。当在定义ALPN协议(序列化的字节)中序列化时，"h2"字符使用<xref target="UTF-8">UTF-8</xref>编码。
        </t>
        <t>
          Negotiating "h2" implies the use of the transport, security, framing and message
          semantics described in this document.

          协定"h2"用于文档中的传输、安全、帧及语义化消息部分。
        </t>
        <t>
          <cref>Editor's Note: please remove the remainder of this section prior to the publication
          of a final version of this document.</cref>
        </t>
        <t>
          Only implementations of the final, published RFC can identify themselves as "h2".
          Until such an RFC exists, implementations MUST NOT identify themselves using "h2".
        </t>
        <t>
          Examples and text throughout the rest of this document use "h2" as a matter of
          editorial convenience only.  Implementations of draft versions MUST NOT identify using
          this string.
        </t>
        <t>
          Implementations of draft versions of the protocol MUST add the string "-" and the
          corresponding draft number to the identifier. For example, draft-ietf-httpbis-http2-09
          is identified using the string "h2-09".
        </t>
        <t>
          Non-compatible experiments that are based on these draft versions MUST append the string
          "-" and an experiment name to the identifier.  For example, an experimental implementation
          of packet mood-based encoding based on draft-ietf-httpbis-http2-09 might identify itself
          as "h2-09-emo".  Note that any label MUST conform to the "token" syntax defined in
          <xref target="HTTP-p1" x:fmt="of" x:rel="#field.components"/>.  Experimenters are
          encouraged to coordinate their experiments on the ietf-http-wg@w3.org mailing list.
        </t>
      </section>

      <section anchor="discover-http" title="Starting HTTP/2 for &quot;http&quot; URIs">
        <t>
          A client that makes a request to an "http" URI without prior knowledge about support for
          HTTP/2 uses the HTTP Upgrade mechanism (<xref target="HTTP-p1" x:fmt="of"
          x:rel="#header.upgrade"/>).  The client makes an HTTP/1.1 request that includes an Upgrade
          header field identifying HTTP/2 with the h2 token.  The HTTP/1.1 request MUST include
          exactly one <xref target="Http2SettingsHeader">HTTP2-Settings</xref> header field.

          客户端发起“http” URI请求不支持HTTP/2的使用HTTP升级机制(<xref target="HTTP-p1" x:fmt="of"
          x:rel="#header.upgrade"/>)。客户端发起一个http1.1请求，其中包含识别HTTP/2的升级头部字段与h2令牌。HTTP/1.1必须包含一个确切的<xref target="Http2SettingsHeader">HTTP2-Settings</xref>中的头部字段。

        </t>
        <figure>
          <preamble>For example: 例如：</preamble>
          <artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  "><![CDATA[
GET /default.htm HTTP/1.1
Host: server.example.com
Connection: Upgrade, HTTP2-Settings
Upgrade: h2
HTTP2-Settings: <base64url encoding of HTTP/2 SETTINGS payload>

]]></artwork>
        </figure>
        <t>
          Requests that contain an entity body MUST be sent in their entirety before the client can
          send HTTP/2 frames.  This means that a large request entity can block the use of the
          connection until it is completely sent.

          包含主体内容的请求必须在客户端能发送HTTP/2帧前全部发送。这意味着一个大的请求实例能阻塞连接的使用直到其全部被发送。

        </t>
        <t>
          If concurrency of an initial request with subsequent requests is important, a small
          request can be used to perform the upgrade to HTTP/2, at the cost of an additional
          round-trip.

          如果一个请求的并发后续请求是重要的，那么一个小的请求可以用来执行升级到HTTP/2,消耗一个额外的往返成本。
        </t>
        <t>
          A server that does not support HTTP/2 can respond to the request as though the Upgrade
          header field were absent:

          不支持HTTP/2的服务端对请求返回一个不包含升级的头部字段的响应：
        </t>
        <figure>
          <artwork type="message/http; msgtype=&#34;response&#34;" x:indent-with="  ">
HTTP/1.1 200 OK
Content-Length: 243
Content-Type: text/html

...
</artwork>
        </figure>
        <t>
          A server that supports HTTP/2 can accept the upgrade with a 101 (Switching Protocols)
          response.  After the empty line that terminates the 101 response, the server can begin
          sending HTTP/2 frames.  These frames MUST include a response to the request that initiated
          the Upgrade.

          支持HTTP/2的服务端可以返回一个101(转换协议)响应来接受升级请求。在101空内容响应终止后，服务端可以开始发送HTTP/2帧。这些帧必须包含一个标示升级的响应。
        </t>

        <figure>
          <artwork type="message/http; msgtype=&#34;response&#34;" x:indent-with="  ">
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: h2

[ HTTP/2 connection ...
</artwork>
        </figure>
        <t>
          The first HTTP/2 frame sent by the server is a <x:ref>SETTINGS</x:ref> frame (<xref
          target="SETTINGS"/>). Upon receiving the 101 response, the client sends a <xref
          target="ConnectionHeader">connection preface</xref>, which includes a
          <x:ref>SETTINGS</x:ref> frame.

          第一个被服务端发送的HTTP/2帧是一个<x:ref>设置(SETTINGS)</x:ref>帧(<xref target="SETTINGS"/>)。在收到101响应后，客户端发送一个包含<x:ref>设置(SETTINGS)</x:ref>帧的连接序言。
        </t>
        <t>
          The HTTP/1.1 request that is sent prior to upgrade is assigned stream identifier 1 and is
          assigned the highest possible priority.  Stream 1 is implicitly half closed from the
          client toward the server, since the request is completed as an HTTP/1.1 request.  After
          commencing the HTTP/2 connection, stream 1 is used for the response.

          HTTP/1.1最初用来升级的请求用1来标示流并将赋予最高优先级。流1对发送到服务端的客户端是隐式半封闭的，因为这个请求已经以一个HTTP/1.1请求完成了。HTTP/2连接开始后,流1在响应中使用。
        </t>

        <section anchor="Http2SettingsHeader" title="HTTP2-Settings Header Field">
          <t>
            A request that upgrades from HTTP/1.1 to HTTP/2 MUST include exactly one <spanx
            style="verb">HTTP2-Settings</spanx> header field.  The <spanx
            style="verb">HTTP2-Settings</spanx> header field is a hop-by-hop header field that
            includes parameters that govern the HTTP/2 connection, provided in anticipation of the
            server accepting the request to upgrade.  A server MUST reject an attempt to upgrade if
            this header field is not present.

            从HTTP/1.1升级到HTTP/2的请求必须包含一个确切的<spanx style="verb">HTTP2-Settings</spanx>头部字段。这个<spanx
            style="verb">HTTP2-Settings</spanx>头部字段是一个包含管理HTTP/2连接参数的逐跳头部字段。如果没有此头部字段，服务端必须拒绝升级。
          </t>
          <figure>
            <artwork type="abnf" x:indent-with="  "><![CDATA[
HTTP2-Settings    = token68
]]></artwork>
          </figure>

          <t>
            The content of the <spanx style="verb">HTTP2-Settings</spanx> header field is the
            payload of a <x:ref>SETTINGS</x:ref> frame (<xref target="SETTINGS"/>), encoded as a
            base64url string (that is, the URL- and filename-safe Base64 encoding described in <xref
            target="RFC4648" x:fmt="of" x:sec="5"/>, with any trailing '=' characters omitted).  The
            <xref target="RFC5234">ABNF</xref> production for <spanx style="verb">token68</spanx> is
            defined in <xref target="HTTP-p7" x:fmt="of" x:rel="#challenge.and.response"/>.

            这个<spanx style="verb">HTTP2-Settings</spanx>头部字段的内容是<x:ref>设置(SETTINGS)</x:ref>帧的有效载体，使用base64url字符编码(URL及文件名安全的Base64编码，编码描述在<xref target="RFC4648" x:fmt="of" x:sec="5"/>中)。
          </t>
          <t>
            The client MUST include values for the following 
            <xref target="SettingFormat">SETTINGS parameters</xref>:
            客户端必须包含以下<xref target="SettingFormat">设置(SETTINGS) 参数</xref>：
            <list style="symbols">
              <t><x:ref>SETTINGS_MAX_CONCURRENT_STREAMS</x:ref></t>
              <t><x:ref>最大连接数设置</x:ref></t>
              <t><x:ref>SETTINGS_INITIAL_WINDOW_SIZE</x:ref></t>
              <t><x:ref>初始化窗口大小设置</x:ref></t>
            </list>
          </t>
          <t>
            As a hop-by-hop header field, the <spanx style="verb">Connection</spanx> header field
            MUST include a value of <spanx style="verb">HTTP2-Settings</spanx> in addition to <spanx
            style="verb">Upgrade</spanx> when upgrading to HTTP/2.

            作为一个逐跳的报文头部字段，当升级到HTTP/2时，此<spanx style="verb">连接</spanx> 头部字段必须包含一个<spanx style="verb">HTTP2设置(HTTP2-Settings)</spanx>的值。
          </t>
          <t>
            A server decodes and interprets these values as it would any other
            <x:ref>SETTINGS</x:ref> frame.  <xref target="SettingsSync">Acknowledgement of the
            SETTINGS parameters</xref> is not necessary, since a 101 response serves as implicit
            acknowledgment.  Providing these values in the Upgrade request ensures that the protocol
            does not require default values for the above SETTINGS parameters, and gives a client an
            opportunity to provide other parameters prior to receiving any frames from the server.

            服务端就像对任何其他 <x:ref>设置(SETTINGS</x:ref>帧一样对这些值进行解码。因为101响应的隐式声明，对这些<xref target="SettingsSync">设置参数的确认</xref>不是必须的。这些升级请求中的值使得协议不需要上述设置参数的默认值，同时使客户端有机会提供其他优先参数来从服务端获取任何帧。
          </t>
        </section>
      </section>

      <section anchor="discover-https" title="Starting HTTP/2 for &quot;https&quot; URIs">
        <t>
          A client that makes a request to an "https" URI without prior knowledge about support for
          HTTP/2 uses <xref target="TLS12">TLS</xref> with the <xref target="TLSALPN">application
          layer protocol negotiation extension</xref>.

          客户端发起“https”的URI请求无法预知服务端是否支持HTTP/2的使用 <xref target="TLS12">TLS</xref>与<xref target="TLSALPN">应用层协议协商扩展</xref>。

        </t>
        <t>
          Once TLS negotiation is complete, both the client and the server send a <xref
          target="ConnectionHeader">connection preface</xref>.

          TSL协议一旦完成，客户端和服务端都可以发送<xref target="ConnectionHeader">连接序言</xref>。
        </t>
      </section>

      <section anchor="known-http" title="Starting HTTP/2 with Prior Knowledge">
        <t>
          A client can learn that a particular server supports HTTP/2 by other means.  For example,
          <xref target="AltSvc"/> describes a mechanism for advertising this capability in an HTTP
          header field.  A client MAY immediately send HTTP/2 frames to a server that is known to
          support HTTP/2, after the <xref target="ConnectionHeader">connection preface</xref>.  A
          server can identify such a connection by the use of the "PRI" method in the connection
          preface. This only affects the resolution of "http" URIs; servers supporting HTTP/2 are
          required to support <xref target="TLSALPN">protocol negotiation in TLS</xref> for "https"
          URIs.

          客户端可以通过其他方式判断服务端是否支持HTTP/2。例如， <xref target="AltSvc"/>定义一种机制让HTTP头字段进行广播。客户端可以对支持HTTP/2的服务端在<xref target="ConnectionHeader">连接序言</xref>之后立即发送HTTP/2帧。服务端可以通过连接序言中的“PRI”方法来区分这种连接。这种对"http"URI改变的唯一影响是，支持HTTP/2的服务端对“https”URI需要支持<xref target="TLSALPN">TLS中的协商扩展</xref>。
        </t>
        <t>
          Prior support for HTTP/2 is not a strong signal that a given server will support HTTP/2
          for future connections.  It is possible for server configurations to change or for
          configurations to differ between instances in clustered server.  Interception proxies
          (a.k.a. "transparent" proxies) are another source of variability.

          对HTTP/2之前的支持并不是强烈信号表明一个给定的服务器会在以后的连接中支持HTTP/2。服务器配置有可能改变或者集群中不同服务器配置有差异。拦截代理(又叫“透明”代理)是另一个可能得原因。
        </t>
      </section>

      <section anchor="ConnectionHeader" title="HTTP/2 Connection Preface">
        <t>
          Upon establishment of a TCP connection and determination that HTTP/2 will be used by both
          peers, each endpoint MUST send a connection preface as a final confirmation and to
          establish the initial SETTINGS parameters for the HTTP/2 connection.

          在建立TCP连接并且检测到HTTP/2会被各个对等端使用后，每个端点必须发送一个连接序言最终确认和作为建立HTTP/2连接的初始设置参数。
        </t>
        <t>
          The client connection preface starts with a sequence of 24 octets, which in hex notation
          are:

          客户端连接序言以24个字节的序列开始，以十六进制表示是：
        </t>
        <figure>
          <artwork type="inline" x:indent-with="  "><![CDATA[
0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a
]]></artwork>
        </figure>
        <t>
          (the string <spanx style="verb">PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n</spanx>).  This sequence
          is followed by a <x:ref>SETTINGS</x:ref> frame (<xref target="SETTINGS"/>).  The client
          sends the client connection preface immediately upon receipt of a 101 Switching Protocols
          response (indicating a successful upgrade), or as the first application data octets of a
          TLS connection. If starting an HTTP/2 connection with prior knowledge of server support
          for the protocol, the client connection preface is sent upon connection establishment.

          (字符串<spanx style="verb">PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n</spanx>)。这个序列后跟着一个<x:ref>设置</x:ref>帧(<xref target="SETTINGS"/>)。客户端在收到101转换协议响应(升级成功指示)后马上发送客户端连接序言，或者作为TLS连接的第一个应用数据字节。如果在对服务器支持HTTP/2具有先验知识的情况下启动HTTP/2连接，客户端连接序言在连接建立后就发送。

        </t>
        <t>
          <list>
            <t>
              The client connection preface is selected so that a large proportion of HTTP/1.1 or
              HTTP/1.0 servers and intermediaries do not attempt to process further frames.  Note
              that this does not address the concerns raised in <xref target="TALKING"/>.

              客户端连接序言是这样选择的：大部分的HTTP/1.1或者HTTP/1.0服务端以及中介者不试图进一步处理帧。注意这并不能解决<xref target="TALKING"/>中提到的问题。
            </t>
          </list>
        </t>
        <t>
          The server connection preface consists of just a <x:ref>SETTINGS</x:ref> frame (<xref
          target="SETTINGS"/>) that MUST be the first frame the server sends in the HTTP/2
          connection.

          服务端连接序言仅包含一个必须在HTTP/2连接中首个发送的<x:ref>设置(SETTINGS)</x:ref> 帧 (<xref target="SETTINGS"/>)。
        </t>
        <t>
          To avoid unnecessary latency, clients are permitted to send additional frames to the
          server immediately after sending the client connection preface, without waiting to receive
          the server connection preface.  It is important to note, however, that the server
          connection preface <x:ref>SETTINGS</x:ref> frame might include parameters that necessarily
          alter how a client is expected to communicate with the server. Upon receiving the
          <x:ref>SETTINGS</x:ref> frame, the client is expected to honor any parameters established.

          为了避免不必要的延迟，允许客户端在发送客户端连接序言之后立即发送其他额外的帧，不需要等待收到服务端连接序言。不过需要注意的是，服务端连接序言<x:ref>设置(SETTINGS)</x:ref>帧可能包含一些关于期望客户端如何与服务端通信的所必须修改的参数。在收到这些<x:ref>设置(SETTINGS)</x:ref>帧之后，客户端应当遵守任何建立的参数。
        </t>
        <t>
          Clients and servers MUST terminate the TCP connection if either peer does not begin with a
          valid connection preface.  A <x:ref>GOAWAY</x:ref> frame (<xref target="GOAWAY"/>) MAY be
          omitted if it is clear that the peer is not using HTTP/2.

          任意一个端点没有以一个有效的连接序言开始，客户端以及服务端必须终止TCP连接。如果端点并没有使用HTTP/2此时<x:ref>超时GOAWAY</x:ref> 帧可能可以省略。
        </t>
      </section>
    </section>

    <section anchor="FramingLayer" title="HTTP Frames">
      <t>
        Once the HTTP/2 connection is established, endpoints can begin exchanging frames.

        HTTP/2连接一旦建立，端点之间可以马上交换数据帧。
      </t>

      <section anchor="FrameHeader" title="Frame Format">
        <t>
          All frames begin with an 8-octet header followed by a payload of between 0 and 16,383
          octets.

          所有的帧以8字节的头部开始并且跟着0-16,383长度的主体。
        </t>
        <figure title="Frame Header">
          <artwork type="inline"><![CDATA[
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | R |     Length (14)           |   Type (8)    |   Flags (8)   |
 +-+-+-----------+---------------+-------------------------------+
 |R|                 Stream Identifier (31)                      |
 +-+-------------------------------------------------------------+
 |                   Frame Payload (0...)                      ...
 +---------------------------------------------------------------+
]]></artwork>
        </figure>
        <t>
          The fields of the frame header are defined as:
          帧头部字段定义是：
          <list style="hanging">
            <x:lt hangText="R:">
              <t>
                A reserved 2-bit field.  The semantics of these bits are undefined and the bits MUST
                remain unset (0) when sending and MUST be ignored when receiving.

                保留的2字节字段。这些字节的语义是未定义的，并且在发送的时候必须保留未设置(0)，在接受的时候必须被忽略。
              </t>
            </x:lt>
            <x:lt hangText="Length:">
              <t>
                The length of the frame payload expressed as an unsigned 14-bit integer. The 8 octets
                of the frame header are not included in this value.

                以14字节无符号整数的帧主体的长度。8字节长度的帧头部信息不计算在此内。


              </t>
            </x:lt>
            <x:lt hangText="Type:">
              <t>
                The 8-bit type of the frame.  The frame type determines how the remainder of the
                frame header and payload are interpreted.  Implementations MUST treat the receipt of
                an unknown frame type (any frame types not defined in this document) as a <xref
                target="ConnectionErrorHandler">connection error</xref> of type
                <x:ref>PROTOCOL_ERROR</x:ref>.

                帧的8字节类型。帧类型定义了剩余的帧报头和帧主体将如何被解释。具体实现必须处理收到未知帧类型(任何未在文档中定义的帧)时作为 <xref target="ConnectionErrorHandler">连接错误</xref>中的
                <x:ref>类型协议错误PROTOCOL_ERROR</x:ref>。
              </t>
            </x:lt>
            <x:lt hangText="Flags:">
              <t>
                An 8-bit field reserved for frame-type specific boolean flags.

                为帧类型保留的8字节字段有具体的布尔标识。
              </t>
              <t>
                Flags are assigned semantics specific to the indicated frame type.
                Flags that have no defined semantics for a particular frame type
                MUST be ignored, and MUST be left unset (0) when sending.

                标识针对确定的帧类型赋予特定的语义。确定帧类型定义语义以外的标示必须被忽略，并且必须在发送的时候保留未设置(0)。
              </t>
            </x:lt>
            <x:lt hangText="R:">
              <t>
                A reserved 1-bit field.  The semantics of this bit are undefined and the bit MUST
                remain unset (0) when sending and MUST be ignored when receiving.

                1字节的保留字段。这个字段的语义未设置并且必须在发送的时候保持未设置(0),在接受的时候必须被忽略。
              </t>
            </x:lt>
            <x:lt hangText="Stream Identifier:">
              <t>
                A 31-bit stream identifier (see <xref target="StreamIdentifiers"/>).  The value 0 is
                reserved for frames that are associated with the connection as a whole as opposed to
                an individual stream.

                31字节的流标识符(见<xref target="StreamIdentifiers"/>)。0是保留的，标明帧是与连接相关作为一个整体而不是一个单独的流。
              </t>
            </x:lt>
          </list>
        </t>
        <t>
          The structure and content of the frame payload is dependent entirely on the frame type.

          帧主体的结构和内容完全取决于帧类型。
        </t>
      </section>

      <section anchor="FrameSize" title="Frame Size">
        <t>
          The maximum size of a frame payload varies by frame type. The absolute maximum size of a
          frame payload is 2<x:sup>14</x:sup>-1 (16,383) octets, meaning that the maximum frame
          size is 16,391 octets. All implementations SHOULD be capable of receiving and minimally
          processing frames up to this maximum size.

          帧主体的最大长度限制因不同的帧类型而不同。最大帧主体的绝对长度是2<x:sup>14</x:sup>-1 (16,383)字节，表示最大的帧长度是16,391字节。所有的实现应当具备接收和处理此最大长度帧的能力。

        </t>
        <t>
          Certain frame types, such as <x:ref>PING</x:ref> (see <xref target="PING"/>), impose
          additional limits on the amount of payload data allowed.  Likewise, additional size limits
          can be set by specific application uses (see <xref target="HttpExtra" />).

          某些帧类型，例如<x:ref>PING</x:ref>(见 <xref target="PING"/>)，对主体数据大小有额外的限制。同样的，一些特定的应用也可能使用额外的大小限制(见 <xref target="HttpExtra" />)。
        </t>
        <t>
          If a frame size exceeds any defined limit, or is too small to contain mandatory frame
          data, the endpoint MUST send a <x:ref>FRAME_SIZE_ERROR</x:ref> error. A frame size error
          in a frame that could alter the state of the entire connection MUST be treated as a <xref
          target="ConnectionErrorHandler">connection error</xref>; this includes any frame carrying
          a <xref target="HeaderBlock">header block</xref> (that is, <x:ref>HEADERS</x:ref>,
          <x:ref>PUSH_PROMISE</x:ref>, and <x:ref>CONTINUATION</x:ref>), <x:ref>SETTINGS</x:ref>,
          and any <x:ref>WINDOW_UPDATE</x:ref> frame with a stream identifier of 0.

          如果一个帧大小超过任何设定的限制，或者太小无法包含强制的帧数据，这个端点必须发送一个<x:ref>帧大小错误FRAME_SIZE_ERROR</x:ref>。如果帧大小错误可能修改整个连接状态，必须作为一个<xref
          target="ConnectionErrorHandler">连接错误</xref>处理；这包括与0流一起的携带<xref target="HeaderBlock">头部块</xref>(即<x:ref>报文头HEADERS</x:ref>，<x:ref>推送许可PUSH_PROMISE</x:ref>和<x:ref>延续CONTINUATION</x:ref>)、<x:ref>设置SETTINGS</x:ref>以及任何<x:ref>窗口更新WINDOW_UPDATE</x:ref>的帧。
        </t>
      </section>

      <section anchor="HeaderBlock" title="Header Compression and Decompression">
        <t>
          A header field in HTTP/2 is a name-value pair with one or more associated values. They are
          used within HTTP request and response messages as well as server push operations (see
          <xref target="PushResources" />).

          HTTP/2报文头部字段是包含一个或多个相关意义的键值对。他们在HTTP请求响应消息及服务器推送操作(见<xref target="PushResources" />)中使用。
        </t>
        <t>
          Header sets are collections of zero or more header fields.  When transmitted over a
          connection, a header set is serialized into a header block using <xref
          target="COMPRESSION">HTTP Header Compression</xref>.  The serialized header block is then
          divided into one or more octet sequences, called header block fragments, and transmitted
          within the payload of <xref target="HEADERS">HEADERS</xref>, <xref
          target="PUSH_PROMISE">PUSH_PROMISE</xref> or <xref
          target="CONTINUATION">CONTINUATION</xref> frames.

          报头集合是0个或多个报头字段的集合。当传输一个连接的时候，报头集合将使用<xref target="COMPRESSION">HTTP头部压缩</xref>序列化到报文头部块中。序列化的报头块被分割成一个或多个的字节序列，称为报头分区，并在<xref target="HEADERS">报头HEADERS</xref>、<xref target="PUSH_PROMISE">推送约定PUSH_PROMISE</xref>及<xref
          target="CONTINUATION">延续CONTINUATION</xref>的载体中传送，
        </t>
        <t>
          HTTP Header Compression does not preserve the relative ordering of header fields.  Header
          fields with multiple values are encoded into a single header field using a special
          delimiter; see <xref target="HeaderOrdering"/>.

          HTTP报文头压缩并不保留报头字段的相关顺序。通用多个值的报头字段使用特定的分割器被编码分割到一个单独的报头区域；见<xref target="HeaderOrdering"/>。
        </t>
        <t>
          The <xref target="COOKIE">Cookie header field</xref> is treated specially by the HTTP
          mapping; see <xref target="CompressCookie"/>.

          报文头<xref target="COOKIE">Cookie字段</xref>被通过HTTP映射特殊处理；见<xref target="CompressCookie"/>。
        </t>
        <t>
          A receiving endpoint reassembles the header block by concatenating its fragments, then
          decompresses the block to reconstruct the header set.

          接收端点连接报头区块重新组装，并且解压缩区块后重建报头集合。
        </t>
        <t>
          A complete header block consists of either:

          一个完整的报头区块可以包含：
          <list style="symbols">
            <t>
              a single <x:ref>HEADERS</x:ref> or <x:ref>PUSH_PROMISE</x:ref> frame,
              with the END_HEADERS flag set, or

              一个包含头部终止标记集合的单独的<x:ref>报头HEADERS</x:ref> 或 <x:ref>推送约定PUSH_PROMISE</x:ref>帧，或者
            </t>
            <t>
              a <x:ref>HEADERS</x:ref> or <x:ref>PUSH_PROMISE</x:ref> frame with the END_HEADERS
              flag cleared and one or more <x:ref>CONTINUATION</x:ref> frames,
              where the last <x:ref>CONTINUATION</x:ref> frame has the END_HEADERS flag set.

              一个头部终止标记被清除的<x:ref>报头HEADERS</x:ref> 或 <x:ref>推送约定PUSH_PROMISE</x:ref>帧以及一个或多个<x:ref>延续CONTINUATION</x:ref>帧，最后一个<x:ref>延续CONTINUATION</x:ref>帧拥有头部终止标记设置。
            </t>
          </list>
        </t>
        <t>
          Header blocks MUST be transmitted as a contiguous sequence of frames, with no interleaved
          frames of any other type or from any other stream.  The last frame in a sequence of
          <x:ref>HEADERS</x:ref> or <x:ref>CONTINUATION</x:ref> frames MUST have the END_HEADERS
          flag set.  The last frame in a sequence of <x:ref>PUSH_PROMISE</x:ref> or
          <x:ref>CONTINUATION</x:ref> frames MUST have the END_HEADERS flag set.

          报头区块必须作为一个连续的帧序列传输，没有任何类型或任何其他流的交错帧。一个<x:ref>报头HEADERS</x:ref>或者<x:ref>延续CONTINUATION</x:ref>帧序列的最后一帧必须有头部终止标记设置。<x:ref>推送约定PUSH_PROMISE</x:ref>或者<x:ref>延续CONTINUATION</x:ref>帧序列的最后一帧必须具有头部终止标记设置。
        </t>
        <t>
          Header block fragments can only be sent as the payload of <x:ref>HEADERS</x:ref>,
          <x:ref>PUSH_PROMISE</x:ref> or <x:ref>CONTINUATION</x:ref> frames, because these frames
          carry data that can modify the compression context maintained by a receiver.  An endpoint
          receiving <x:ref>HEADERS</x:ref>, <x:ref>PUSH_PROMISE</x:ref> or
          <x:ref>CONTINUATION</x:ref> frames MUST reassemble header blocks and perform decompression
          even if the frames are to be discarded.  A receiver MUST terminate the connection with a
          <xref target="ConnectionErrorHandler">connection error</xref> of type
          <x:ref>COMPRESSION_ERROR</x:ref> if it does not decompress a header block.

          报头区块必须被<x:ref>报头HEADERS</x:ref>、<x:ref>推送约定PUSH_PROMISE</x:ref>或<x:ref>延续CONTINUATION</x:ref>的有效载体发送，因为这些帧中携带了能被接收端修改的压缩上下文数据。端点在接收<x:ref>报头HEADERS</x:ref>、<x:ref>推送约定PUSH_PROMISE</x:ref>或<x:ref>延续CONTINUATION</x:ref>帧时必须重新组装报头区块并且执行解压缩，即便这些帧将被废弃。如何不能重建头部区间，接收端必须终止连接并报<x:ref>解压缩错误COMPRESSION_ERROR</x:ref>的<xref target="ConnectionErrorHandler">连接错误connection error</xref>。


        </t>
      </section>
    </section>

    <section anchor="StreamsLayer" title="Streams and Multiplexing">
        <t>
          A "stream" is an independent, bi-directional sequence of <x:ref>HEADERS</x:ref> and
          <x:ref>DATA</x:ref> frames exchanged between the client and server within an HTTP/2
          connection.  Streams have several important characteristics:

          流是一个独立的，客户端和服务端在HTTP/2连接下交换<x:ref>报头HEADERS</x:ref>和 <x:ref>数据DATA</x:ref>帧的双向序列。
          <list style="symbols">
            <t>
              A single HTTP/2 connection can contain multiple concurrently open streams, with either
              endpoint interleaving frames from multiple streams.

              一个单独的HTTP/2连接能够保护多个同时打开的流，各个端点间从多个流中交错帧。
            </t>
            <t>
              Streams can be established and used unilaterally or shared by either the client or
              server.

              流可以被被客户端或者服务端单方面建立使用或分享。
            </t>
            <t>
              Streams can be closed by either endpoint.

              流可以被任何一个终端关闭。
            </t>
            <t>
              The order in which frames are sent within a stream is significant. Recipients process
              frames in the order they are received.

              在流内发送帧的顺序很重要。它们将按被接收的顺序处理。
            </t>
            <t>
              Streams are identified by an integer.  Stream identifiers are assigned to streams by
              the endpoint initiating the stream.

              流以一个整数标识。标识符有启动流的终端分配。
            </t>
          </list>
        </t>

     <section anchor="StreamStates" title="Stream States">
        <t>
          The lifecycle of a stream is shown in <xref target="StreamStatesFigure"/>.

          流的生存周期如<xref target="StreamStatesFigure"/>所以：
        </t>

        <figure anchor="StreamStatesFigure" title="Stream States">
          <artwork type="drawing">
            <![CDATA[
                       +--------+
                 PP    |        |    PP
              ,--------|  idle  |--------.
             /         |        |         \
            v          +--------+          v
     +----------+          |           +----------+
     |          |          | H         |          |
 ,---| reserved |          |           | reserved |---.
 |   | (local)  |          v           | (remote) |   |
 |   +----------+      +--------+      +----------+   |
 |      |          ES  |        |  ES          |      |
 |      | H    ,-------|  open  |-------.      | H    |
 |      |     /        |        |        \     |      |
 |      v    v         +--------+         v    v      |
 |   +----------+          |           +----------+   |
 |   |   half   |          |           |   half   |   |
 |   |  closed  |          | R         |  closed  |   |
 |   | (remote) |          |           | (local)  |   |
 |   +----------+          |           +----------+   |
 |        |                v                 |        |
 |        |  ES / R    +--------+  ES / R    |        |
 |        `----------->|        |<-----------'        |
 |  R                  | closed |                  R  |
 `-------------------->|        |<--------------------'
                       +--------+

   H:  HEADERS frame (with implied CONTINUATIONs)
   PP: PUSH_PROMISE frame (with implied CONTINUATIONs)
   ES: END_STREAM flag
   R:  RST_STREAM frame
]]>
          </artwork>
        </figure>

        <t>
          Both endpoints have a subjective view of the state of a stream that could be different
          when frames are in transit.  Endpoints do not coordinate the creation of streams; they are
          created unilaterally by either endpoint.  The negative consequences of a mismatch in
          states are limited to the "closed" state after sending <x:ref>RST_STREAM</x:ref>, where
          frames might be received for some time after closing.

          当流在传输的时候，各个端点对流状态的主观认识可能不同。终端并不协调流的创建；它们是被任意终端单方面创建的。不匹配的状态导致的消极结果是在发送<x:ref>RST_STREAM</x:ref>流之后它们的“关闭”是受限制的，因为可能在关闭之后帧才被接收。
        </t>
        <t>
          Streams have the following states:

          流有以下状态：
          <list style="hanging">

            <x:lt hangText="idle:">
              <t>
                <vspace blankLines="0"/>
                All streams start in the "idle" state.  In this state, no frames have been
                exchanged.

                所有流以“空闲”状态开始。在这种状态下，没有任何帧的交换。
              </t>
              <t>
                The following transitions are valid from this state:

                下列传输在这种状态下是有效的：
                <list style="symbols">
                  <t>
                    Sending or receiving a <x:ref>HEADERS</x:ref> frame causes the stream to become
                    "open".  The stream identifier is selected as described in <xref
                    target="StreamIdentifiers"/>.  The same <x:ref>HEADERS</x:ref> frame can also
                    cause a stream to immediately become "half closed".

                    发送或者接收一个<x:ref>报头HEADERS</x:ref>帧导致流变成“打开”。流标识符如<xref target="StreamIdentifiers"/>说明。这个<x:ref>报头HEADERS</x:ref>帧同样可能导致流立即变成“半关闭”状态。
                  </t>
                  <t>
                    Sending a <x:ref>PUSH_PROMISE</x:ref> frame marks the associated stream for
                    later use.  The stream state for the reserved stream transitions to "reserved
                    (local)".

                    发送一个<x:ref>推送约定PUSH_PROMISE</x:ref>帧标记相关的流后续再使用。保留流状态将转换为“预留(本地)”。
                  </t>
                  <t>
                    Receiving a <x:ref>PUSH_PROMISE</x:ref> frame marks the associated stream as
                    reserved by the remote peer.  The state of the stream becomes "reserved
                    (remote)".

                    接收一个<x:ref>推送约定PUSH_PROMISE</x:ref>帧标记相关的流为远程端点预留的流。这些流的状态变成“预留(远程)”
                  </t>
                </list>
              </t>
            </x:lt>

            <x:lt hangText="reserved (local):">
              <t>
                <vspace blankLines="0"/>
                A stream in the "reserved (local)" state is one that has been promised by sending a
                <x:ref>PUSH_PROMISE</x:ref> frame.  A <x:ref>PUSH_PROMISE</x:ref> frame reserves an
                idle stream by associating the stream with an open stream that was initiated by the
                remote peer (see <xref target="PushResources"/>).

                在“预留(本地)”状态的是已经被承诺发送<x:ref>推送约定PUSH_PROMISE</x:ref>帧的流。一个<x:ref>推送约定PUSH_PROMISE</x:ref>帧通过使一个流与一个由远端对等端初始化的打开的流相关联来保留一个空闲流。 
              </t>
              <t>
                In this state, only the following transitions are possible:

                在这种状态下，只有下列传输是可能的：
                <list style="symbols">
                  <t>
                    The endpoint can send a <x:ref>HEADERS</x:ref> frame.  This causes the stream to
                    open in a "half closed (remote)" state.

                    端点可以发送<x:ref>报头HEADERS</x:ref>帧，致使流打开到“半封闭(远程)”状态。
                  </t>
                  <t>
                    Either endpoint can send a <x:ref>RST_STREAM</x:ref> frame to cause the stream
                    to become "closed".  This releases the stream reservation.

                    任意端点能发送一个<x:ref>RST_STREAM</x:ref>帧来使流变成“关闭”。这将释放流的保留。
                  </t>
                </list>
              </t>
              <t>
                An endpoint MUST NOT send frames other than <x:ref>HEADERS</x:ref> or
                <x:ref>RST_STREAM</x:ref> in this state.

                在这种状态下一个端绝对不能发送<x:ref>报头HEADERS</x:ref>帧和<x:ref>RST_STREAM</x:ref>以外的帧。
              </t>
              <t>
                A <x:ref>PRIORITY</x:ref> frame MAY be received in this state.  Receiving any frames
                other than <x:ref>RST_STREAM</x:ref>, or <x:ref>PRIORITY</x:ref> MUST be treated as
                a <xref target="ConnectionErrorHandler">connection error</xref> of type
                <x:ref>PROTOCOL_ERROR</x:ref>.

                在这种状态下一个<x:ref>优先级PRIORITY</x:ref>帧可能被接收。接收到任何<x:ref>报头HEADERS</x:ref>帧、<x:ref>RST_STREAM</x:ref>帧或者<x:ref>优先级PRIORITY</x:ref>帧以外的帧都将被认为是类型为<x:ref>协议错误PROTOCOL_ERROR</x:ref>的<xref target="ConnectionErrorHandler">连接错误connection error</xref>。
              </t>
            </x:lt>

            <x:lt hangText="reserved (remote):">
              <t>
                <vspace blankLines="0"/>
                A stream in the "reserved (remote)" state has been reserved by a remote peer.

                在“保留(远程)”状态下的流说明已经被远程对等端所保留。
              </t>
              <t>
                In this state, only the following transitions are possible:

                在这种状态下，只有下列传输是可能的：
                <list style="symbols">
                  <t>
                    Receiving a <x:ref>HEADERS</x:ref> frame causes the stream to transition to
                    "half closed (local)".

                    接收一个<x:ref>报头HEADERS</x:ref>帧并致使流转换到“半封闭(本地)”状态。
                  </t>
                  <t>
                    Either endpoint can send a <x:ref>RST_STREAM</x:ref> frame to cause the stream
                    to become "closed".  This releases the stream reservation.

                    任意一个端点能发送一个<x:ref>RST_STREAM</x:ref> 帧来使流变成“关闭”。这将释放流的保留。

                  </t>
                </list>
              </t>
              <t>
                An endpoint MAY send a <x:ref>PRIORITY</x:ref> frame in this state to reprioritize
                the reserved stream.  An endpoint MUST NOT send any other type of frame other than
                <x:ref>RST_STREAM</x:ref> or <x:ref>PRIORITY</x:ref>.

                这种状态下终端可以发送一个<x:ref>优先级PRIORITY</x:ref>帧来变更保留流的优先级顺序。终端绝对不能发送任何<x:ref>RST_STREAM</x:ref> 和<x:ref>优先级PRIORITY</x:ref>以外的帧。
              </t>
              <t>
                Receiving any other type of frame other than <x:ref>HEADERS</x:ref> or
                <x:ref>RST_STREAM</x:ref> MUST be treated as a <xref
                target="ConnectionErrorHandler">connection error</xref> of type
                <x:ref>PROTOCOL_ERROR</x:ref>.

                接收任何<x:ref>RST_STREAM</x:ref> 和<x:ref>优先级PRIORITY</x:ref>以外的帧必须作为类型为 <x:ref>协议错误PROTOCOL_ERROR</x:ref>的<xref target="ConnectionErrorHandler">连接错误</xref>来处理。
              </t>
            </x:lt>

            <x:lt hangText="open:">
              <t>
                <vspace blankLines="0"/>
                A stream in the "open" state may be used by both peers to send frames of any type.
                In this state, sending peers observe advertised <xref target="FlowControl">stream
                level flow control limits</xref>.

                处于“打开”状态的流可以被两个对等端来发送任何类型的帧。在这种状态下，发送数据的对等端检查被广播端<xref target="FlowControl">流量控制限制。
                </xref>
              </t>
              <t>
                From this state either endpoint can send a frame with an END_STREAM flag set, which
                causes the stream to transition into one of the "half closed" states: an endpoint
                sending an END_STREAM flag causes the stream state to become "half closed (local)"; an
                endpoint receiving an END_STREAM flag causes the stream state to become "half closed
                (remote)".  A <x:ref>HEADERS</x:ref> frame bearing an END_STREAM flag can be followed
                by <x:ref>CONTINUATION</x:ref> frames.

                在这种状态下每个终端可以发送一个带有END_STREAM结束流标记的帧来使流转换到以下一种“半关闭”状态：一个终端发送一个结束流END_STREAM标记使流变成“半封闭”状态；一个终端接收一个结束流END_STREAM标记使流变成“半封闭(远程)”状态。带有结束流END_STREAM标记的<x:ref>报头HEADERS</x:ref>帧后面可以跟着<x:ref>延续CONTINUATION</x:ref>帧。 
              </t>
              <t>
                Either endpoint can send a <x:ref>RST_STREAM</x:ref> frame from this state, causing it
                to transition immediately to "closed".

                这种状态下各个终端可以发送一个<x:ref>RST_STREAM</x:ref>帧来使流转换到"关闭"状态。
              </t>
            </x:lt>

            <x:lt hangText="half closed (local):">
              <t>
                <vspace blankLines="0"/>
                A stream that is in the "half closed (local)" state cannot be used for sending frames.

                “半封闭(本地)”状态下的流不能发送帧。
              </t>
              <t>
                A stream transitions from this state to "closed" when a frame that contains an
                END_STREAM flag is received, or when either peer sends a <x:ref>RST_STREAM</x:ref>
                frame.  A <x:ref>HEADERS</x:ref> frame bearing an END_STREAM flag can be followed by
                <x:ref>CONTINUATION</x:ref> frames.

                这种状态下，当流接收到包含END_STREAM标记的帧或者某个终端发送了<x:ref>RST_STREAM</x:ref>帧，流转换到“关闭”状态。带有结束流END_STREAM标记的<x:ref>报头HEADERS</x:ref>帧后面可以跟着<x:ref>延续CONTINUATION</x:ref>帧。 
              </t>
              <t>
                A receiver can ignore <x:ref>WINDOW_UPDATE</x:ref> or <x:ref>PRIORITY</x:ref> frames
                in this state.  These frame types might arrive for a short period after a frame
                bearing the END_STREAM flag is sent.

                这种状态下接收端可以忽略<x:ref>窗口更新WINDOW_UPDATE</x:ref>或<x:ref>优先级PRIORITY</x:ref>帧。这种类型的帧有可能在结束流END_STREAM标记到达一小段时间后才收到。
              </t>
            </x:lt>

            <x:lt hangText="half closed (remote):">
              <t>
                <vspace blankLines="0"/>
                A stream that is "half closed (remote)" is no longer being used by the peer to send
                frames.  In this state, an endpoint is no longer obligated to maintain a receiver
                flow control window if it performs flow control.

                "半封闭(远程)"状态下的流不再被对等端用来发送帧。这种状态下，执行流量控制的终端不在承担接收留空控制窗口的工作。
              </t>
              <t>
                If an endpoint receives additional frames for a stream that is in this state, other
                than <x:ref>CONTINUATION</x:ref> frames, it MUST respond with a <xref
                target="StreamErrorHandler">stream error</xref> of type
                <x:ref>STREAM_CLOSED</x:ref>.

                如果终端接收到处于这种状态下的流发送的额外的帧，除非是<x:ref>延续CONTINUATION</x:ref>帧，否则必须返回类型为<x:ref>流关闭STREAM_CLOSED</x:ref>的<xref target="StreamErrorHandler">流错误</xref>
              </t>
              <t>
                A stream can transition from this state to "closed" by sending a frame that contains
                an END_STREAM flag, or when either peer sends a <x:ref>RST_STREAM</x:ref> frame.

                这种状态下，当流发送一个带有终止流END_STREAM标记的帧或者某个终端发送了一个<x:ref>RST_STREAM</x:ref>帧，流将转换到“关闭”状态。
              </t>
            </x:lt>

            <x:lt hangText="closed:">
              <t>
                <vspace blankLines="0"/>
                The "closed" state is the terminal state.

                “关闭”状态是终止状态。
              </t>
              <t>
                An endpoint MUST NOT send frames on a closed stream.  An endpoint that receives any
                frame after receiving a <x:ref>RST_STREAM</x:ref> MUST treat that as a <xref
                target="StreamErrorHandler">stream error</xref> of type
                <x:ref>STREAM_CLOSED</x:ref>.  Similarly, an endpoint that receives any frames after
                receiving a <x:ref>DATA</x:ref> frame with the END_STREAM flag set, or any frames
                except a <x:ref>CONTINUATION</x:ref> frame after receiving a <x:ref>HEADERS</x:ref>
                frame with an END_STREAM flag set MUST treat that as a <xref
                target="StreamErrorHandler">stream error</xref> of type
                <x:ref>STREAM_CLOSED</x:ref>.

                终端绝对不能通过关闭的流发送帧。终端在收到<x:ref>RST_STREAM</x:ref>后接收的任何帧必须作为类型为<x:ref>流关闭STREAM_CLOSED</x:ref>的<xref target="StreamErrorHandler">流错误stream error</xref>处理。相似的，终端接收到带有END_STREAM标记设置的<x:ref>数据DATA</x:ref>帧之后的任何帧，或在带有END_STREAM终止流标记且后面没有<x:ref>延续CONTINUATION</x:ref>帧的<x:ref>报头HEADERS</x:ref>帧之后收到任何帧都必须作为类型为<x:ref>流关闭STREAM_CLOSED</x:ref>的<xref
                target="StreamErrorHandler">流错误</xref>处理。
              </t>
              <t>
                <x:ref>WINDOW_UPDATE</x:ref>, <x:ref>PRIORITY</x:ref>, or <x:ref>RST_STREAM</x:ref>
                frames can be received in this state for a short period after a <x:ref>DATA</x:ref>
                or <x:ref>HEADERS</x:ref> frame containing an END_STREAM flag is sent.  Until the
                remote peer receives and processes the frame bearing the END_STREAM flag, it might
                send frame of any of these types.  Endpoints MUST ignore
                <x:ref>WINDOW_UPDATE</x:ref>, <x:ref>PRIORITY</x:ref>, or <x:ref>RST_STREAM</x:ref>
                frames received in this state, though endpoints MAY choose to treat frames that
                arrive a significant time after sending END_STREAM as a <xref
                target="ConnectionErrorHandler">connection error</xref> of type
                <x:ref>PROTOCOL_ERROR</x:ref>.

                这种状态下，<x:ref>WINDOW_UPDATE</x:ref>, <x:ref>PRIORITY</x:ref>, or <x:ref>RST_STREAM</x:ref>帧可以在带有END_STREAM标记的<x:ref>数据DATA</x:ref>或者<x:ref>报头HEADERS</x:ref>帧发送一小段时间内被接收。在远端对等端接收并处理带有END_STREAM标记的帧之前，可以发送任意这几种帧。
                在这种状态下终端必须忽略接收到的<x:ref>WINDOW_UPDATE</x:ref>, <x:ref>PRIORITY</x:ref>, 或 <x:ref>RST_STREAM</x:ref>帧，但终端也可以当作<x:ref>协议错误PROTOCOL_ERROR</x:ref>或者<xref
                target="ConnectionErrorHandler">连接错误</xref>来处理。

              </t>
              <t>
                If this state is reached as a result of sending a <x:ref>RST_STREAM</x:ref> frame,
                the peer that receives the <x:ref>RST_STREAM</x:ref> might have already sent - or
                enqueued for sending - frames on the stream that cannot be withdrawn.  An endpoint
                MUST ignore frames that it receives on closed streams after it has sent a
                <x:ref>RST_STREAM</x:ref> frame.  An endpoint MAY choose to limit the period over
                which it ignores frames and treat frames that arrive after this time as being in
                error.

                如果流在发送<x:ref>RST_STREAM</x:ref>帧转换到这种状态，接收到<x:ref>RST_STREAM</x:ref>的对等端可能已经发送或者队列中准备发送无法取消的帧。终端必须忽略从已经发送<x:ref>RST_STREAM</x:ref>帧的流接收到的帧。终端可以选择设置忽略帧的超时时间并在超过限制后作为错误处理。
              </t>
              <t>
                Flow controlled frames (i.e., <x:ref>DATA</x:ref>) received after sending
                <x:ref>RST_STREAM</x:ref> are counted toward the connection flow control window.
                Even though these frames might be ignored, because they are sent before the sender
                receives the <x:ref>RST_STREAM</x:ref>, the sender will consider the frames to count
                against the flow control window.

                在发送<x:ref>RST_STREAM</x:ref>之后收到的流量受限帧(如<x:ref>数据DATA</x:ref>帧)转向流量控制窗口连接处理。尽管这些帧可以被忽略，但他们是在发送端接收到<x:ref>RST_STREAM</x:ref>之前发送的，发送端会认为这些帧与流量控制窗口不符。
              </t>
              <t>
                An endpoint might receive a <x:ref>PUSH_PROMISE</x:ref> frame after it sends
                <x:ref>RST_STREAM</x:ref>.  <x:ref>PUSH_PROMISE</x:ref> causes a stream to become
                "reserved" even if the associated stream has been reset.  Therefore, a
                <x:ref>RST_STREAM</x:ref> is needed to close an unwanted promised streams.

                终端可能在发送<x:ref>RST_STREAM</x:ref>之后收到<x:ref>PUSH_PROMISE</x:ref>帧。即便相关的流已经被重置，<x:ref>PUSH_PROMISE</x:ref>也能使流变成“预留”状态。因此，需要<x:ref>RST_STREAM</x:ref>来关闭一个不想要的被承诺流。
              </t>
            </x:lt>
          </list>
        </t>
        <t>
          In the absence of more specific guidance elsewhere in this document, implementations
          SHOULD treat the receipt of a message that is not expressly permitted in the description
          of a state as a <xref target="ConnectionErrorHandler">connection error</xref> of type
          <x:ref>PROTOCOL_ERROR</x:ref>.

          本文档中没有明确说明的地方，具体实现时接收描述状态中没有明确许可的信息都应作为类型为<x:ref>协议错误PROTOCOL_ERROR</x:ref>的<xref target="ConnectionErrorHandler">连接错误</xref>来处理。
        </t>

        <section anchor="StreamIdentifiers" title="Stream Identifiers">
          <t>
            Streams are identified with an unsigned 31-bit integer.  Streams initiated by a client
            MUST use odd-numbered stream identifiers; those initiated by the server MUST use
            even-numbered stream identifiers.  A stream identifier of zero (0x0) is used for
            connection control messages; the stream identifier zero MUST NOT be used to establish a
            new stream.

            流由31位字节的无符号整数定义。客户端发起的流必须以奇数标示；服务器发起的流必须使用偶数来标示。0(0x0)用来标识连接控制信息流，且绝对不能用来建立一个新流。
          </t>
          <t>
            HTTP/1.1 requests that are upgraded to HTTP/2 (see <xref target="discover-http"/>) are
            responded to with a stream identifier of one (0x1).  After the upgrade
            completes, stream 0x1 is "half closed (local)" to the client.  Therefore, stream 0x1
            cannot be selected as a new stream identifier by a client that upgrades from HTTP/1.1.

            HTTP/1.1升级到HTTP/2的请求将收到一个1(0x1)标识的响应流。升级完成后，0x1流将对客户端处于“半封闭(本地)”状态。因此，0x1流不能被从HTTP/1.1升级的客户端用来作为一个新的流的标识符。
          </t>
          <t>
            The identifier of a newly established stream MUST be numerically greater than all
            streams that the initiating endpoint has opened or reserved.  This governs streams that
            are opened using a <x:ref>HEADERS</x:ref> frame and streams that are reserved using
            <x:ref>PUSH_PROMISE</x:ref>.  An endpoint that receives an unexpected stream identifier
            MUST respond with a <xref target="ConnectionErrorHandler">connection error</xref> of
            type <x:ref>PROTOCOL_ERROR</x:ref>.

            一个新建立的流标识符必须数值大于任何终端已经打开或者保留的流标识符。规则适用于使用<x:ref>HEADERS</x:ref>帧打开的流以及使用<x:ref>PUSH_PROMISE</x:ref>保留的流。终端收到不规范的流标识符必须响应一个类型为 <x:ref>PROTOCOL_ERROR</x:ref>的<xref target="ConnectionErrorHandler">连接错误connection error</xref>。
          </t>
          <t>
            The first use of a new stream identifier implicitly closes all streams in the "idle"
            state that might have been initiated by that peer with a lower-valued stream identifier.
            For example, if a client sends a <x:ref>HEADERS</x:ref> frame on stream 7 without ever
            sending a frame on stream 5, then stream 5 transitions to the "closed" state when the
            first frame for stream 7 is sent or received.

            新的流标识符第一次被使用时将隐式关闭所有处于“空闲”状态下，可能已经被对等端初始化而且流标识符数字小于新标识符的流。例如，一个客户端发送一个流7的<x:ref>HEADERS</x:ref>帧，那么在流7发送或者接收帧后从没有发送帧的流5将转换为“关闭”状态。
          </t>
          <t>
            Stream identifiers cannot be reused.  Long-lived connections can result in endpoint
            exhausting the available range of stream identifiers.  A client that is unable to
            establish a new stream identifier can establish a new connection for new streams.

            流标识符不能被重复使用。生存期长的连接可能导致流标识符可用范围耗尽。客户端不能新建流标识符时可以针对新流建立一个新的连接。
          </t>
        </section>

        <section title="Stream Concurrency">
          <t>
            A peer can limit the number of concurrently active streams using the
            <x:ref>SETTINGS_MAX_CONCURRENT_STREAMS</x:ref> parameters within a
            <x:ref>SETTINGS</x:ref> frame. The maximum concurrent streams setting is specific to
            each endpoint and applies only to the peer that receives the setting. That is, clients
            specify the maximum number of concurrent streams the server can initiate, and servers
            specify the maximum number of concurrent streams the client can initiate.  Endpoints
            MUST NOT exceed the limit set by their peer.

            对等端可以使用<x:ref>SETTINGS</x:ref>帧里面的<x:ref>SETTINGS_MAX_CONCURRENT_STREAMS</x:ref>参数来限制流的并发量。最大并发流设置仅适用于终端并且只对接收到此设置的对等端有效。也就是说：客户端可以指定服务端能启动的流最大并发量，而且服务端能指定客户端能启动的流最大并发量。终端绝对不能超过对等端设置的限制。
          </t>
          <t>
            Streams that are in the "open" state, or either of the "half closed" states count toward
            the maximum number of streams that an endpoint is permitted to open.  Streams in any of
            these three states count toward the limit advertised in the
            <x:ref>SETTINGS_MAX_CONCURRENT_STREAMS</x:ref> setting (see <xref
            target="SettingValues"/>).

            处于“打开”或者任意一种“半封闭”状态的流均计入终端被允许启动的流次数中。处于任意这三种状态下的流都将计入<x:ref>SETTINGS_MAX_CONCURRENT_STREAMS</x:ref> 设置次数中 (see <xref target="SettingValues"/>).
          </t>
          <t>
            Streams in either of the "reserved" states do not count as open.

            处于任意一种“保留”状态下的流不计入打开次数中。
          </t>
        </section>
      </section>

     <section anchor="FlowControl" title="Flow Control">
        <t>
          Using streams for multiplexing introduces contention over use of the TCP connection,
          resulting in blocked streams.  A flow control scheme ensures that streams on the same
          connection do not destructively interfere with each other.  Flow control is used for both
          individual streams and for the connection as a whole.

          使用复用流介绍了针对TCP连接的资源争夺导致了流的阻塞。流量控制方案等确保同意连接上的流相互之间不会造成破坏性的干扰。流量控制使用在单个流及整个连接过程中。
        </t>
        <t>
          HTTP/2 provides for flow control through use of the <x:ref>WINDOW_UPDATE</x:ref> frame
          type.

          HTTP/2 通过使用<x:ref>WINDOW_UPDATE</x:ref>帧类型来提供流量控制。

        </t>

        <section anchor="fc-principles" title="Flow Control Principles">
          <t>
            HTTP/2 stream flow control aims to allow for future improvements to flow control
            algorithms without requiring protocol changes.  Flow control in HTTP/2 has the following
            characteristics:

            HTTP/2流流量控制目标在于允许不需要协议改动的情况下改进流量控制算法。HTTP/2中的流量控制有以下特点：
            <list style="numbers">
              <t>
                Flow control is hop-by-hop, not end-to-end.
                流量控制是逐跳的，而不是头尾连接的。
              </t>
              <t>
                Flow control is based on window update frames.  Receivers advertise how many bytes
                they are prepared to receive on a stream and for the entire connection.  This is a
                credit-based scheme.

                流量控制是基于窗口更新帧的。接收端广播自己准备在流及整个连接过程中接收的字节大小。这是一个信用为基础的方案。
              </t>
              <t>
                Flow control is directional with overall control provided by the receiver.  A
                receiver MAY choose to set any window size that it desires for each stream and for
                the entire connection.  A sender MUST respect flow control limits imposed by a
                receiver.  Clients, servers and intermediaries all independently advertise their
                flow control window as a receiver and abide by the flow control limits set by
                their peer when sending.

                流量控制是有方向性的，由接收端全权掌握。接收端可以选择针对流及整个连接设置任意的窗口大小。发送端必须遵守接收端的流量控制限制。客户端、服务端及中端代理作为接收者时都独立的向外广播他们各自的流量控制窗口，作为发送者时遵守接收端的限制。
              </t>
              <t>
                The initial value for the flow control window is 65,535 bytes for both new streams
                and the overall connection.

                每个新的流及整个连接的流量控制窗口初始值是65,535字节。
              </t>
              <t>
                The frame type determines whether flow control applies to a frame.  Of the frames
                specified in this document, only <x:ref>DATA</x:ref> frames are subject to flow
                control; all other frame types do not consume space in the advertised flow control
                window.  This ensures that important control frames are not blocked by flow control.

                帧类型决定了是否适用流量控制规则。本文档定义的帧中，只有<x:ref>DATA</x:ref>帧受流量控制；所有其他的帧不受广播的流量控制窗口影响。这保证了重要的控制帧不因流量控制所阻塞。
              </t>
              <t>
                Flow control cannot be disabled.
                流量控制不能被禁用。
              </t>
              <t>
                HTTP/2 standardizes only the format of the <x:ref>WINDOW_UPDATE</x:ref> frame (<xref
                target="WINDOW_UPDATE"/>).  This does not stipulate how a receiver decides when to
                send this frame or the value that it sends.  Nor does it specify how a sender
                chooses to send packets.  Implementations are able to select any algorithm that
                suits their needs.

                HTTP/2只标准化<x:ref>WINDOW_UPDATE</x:ref>帧格式(<xref target="WINDOW_UPDATE"/>)。它没有规定接收端是何时发送帧或者发送什么值，也没有规定发送端如何选择发送包。具体实现可以选择任何满足需求的算法。

              </t>
            </list>
          </t>
          <t>
            Implementations are also responsible for managing how requests and responses are sent
            based on priority; choosing how to avoid head of line blocking for requests; and
            managing the creation of new streams.  Algorithm choices for these could interact with
            any flow control algorithm.

            具体实现还负责管理请求和响应是如何基于优先级发送的；如何避免请求头阻塞以及管理新流的创建。这些算法能够与任何流量控制算法相互作用。
          </t>
        </section>

        <section anchor="DisableFlowControl" title="Appropriate Use of Flow Control">
          <t>
            Flow control is defined to protect endpoints that are operating under resource
            constraints.  For example, a proxy needs to share memory between many connections, and
            also might have a slow upstream connection and a fast downstream one.  Flow control
            addresses cases where the receiver is unable process data on one stream, yet wants to
            continue to process other streams in the same connection.

            流量控制的定义是用来保护端点在资源约束条件下的操作。例如，一个代理需要在很多连接之间共享内存，也有可能有缓慢的上游连接和快速的下游连接。流量控制解决的情况是接收端在一个流上处理数据的同时同样想继续处理同个连接上的其他流。
          </t>
          <t>
            Deployments that do not require this capability can advertise a flow control window of
            the maximum size, incrementing the available space when new data is received. Sending
            data is always subject to the flow control window advertised by the receiver.

            调度过程中不需要这种能力时可以广播一个最大值的流量控制窗口，增加接收新数据时的可用空间。发送数据时总是受接收端广播的流量控制窗口的管理。
          </t>
          <t>
            Deployments with constrained resources (for example, memory) MAY employ flow control to
            limit the amount of memory a peer can consume.  Note, however, that this can lead to
            suboptimal use of available network resources if flow control is enabled without
            knowledge of the bandwidth-delay product (see <xref target="RFC1323"/>).

            资源约束下(例如内存)的调度可以使用流量来限制一个对等端可以消耗的内存数量。需要注意的是如果在不知道带宽延迟乘积的时候启用流量控制可能导致无法最优的利用可用的网络资源(see <xref target="RFC1323"/>)。
          </t>
          <t>
            Even with full awareness of the current bandwidth-delay product, implementation of flow
            control can be difficult.  When using flow control, the receiver MUST read from the TCP
            receive buffer in a timely fashion.  Failure to do so could lead to a deadlock when
            critical frames, such as <x:ref>WINDOW_UPDATE</x:ref>, are not available to HTTP/2.
            However, flow control can ensure that constrained resources are protected without any
            reduction in connection utilization.

            即便是对当前的网络延迟乘积有充分的认识，流量控制的实现也可能很复杂。当使用流量控制时，接收端必须及时地从TCP接收缓冲区读取数据。这样做可能导致在一些例如<x:ref>WINDOW_UPDATE</x:ref>的关键帧在HTTP/2不可用时导致死锁。但是流量控制可以保证约束资源能在不需要减少连接利用的情况下得到保护。
          </t>
        </section>
      </section>

      <section anchor="StreamPriority" title="Stream priority">
        <t>
          The endpoint establishing a new stream can assign a priority for the stream.  Priority is
          represented as an unsigned 31-bit integer.  0 represents the highest priority and
          2<x:sup>31</x:sup>-1 represents the lowest priority.

          新建流的终端可以对流标记优先级。优先级使用31字节无符号整数表示。0表示最高优先级，2的31次方-1表示最低优先级。
        </t>
        <t>
          The purpose of this value is to allow an endpoint to express the relative priority of a
          stream.  An endpoint can use this information to preferentially allocate resources to a
          stream.  Within HTTP/2, priority can be used to select streams for transmitting frames
          when there is limited capacity for sending.  For instance, an endpoint might enqueue
          frames for all concurrently active streams.  As transmission capacity becomes available,
          frames from higher priority streams might be sent before lower priority streams.

          这个值的目的是允许终端表示流的相对优先级。端点可以用这些信息按优先级来给流分配资源。HTTP/2中，当发送能力有限时，可以使用优先级来选择流传输帧。例如，终端可能对当前并发激活的流进行排队，当传输容量可用后，拥有高优先级的流可能在低优先级流前先发送帧。
        </t>
        <t>
          Explicitly setting the priority for a stream does not guarantee any particular processing
          or transmission order for the stream relative to any other stream. Nor is there any
          mechanism provided by which the initiator of a stream can force or require a receiving
          endpoint to process concurrent streams in a particular order.

          明确设置流的优先级并不能保证能相当其他相关流有特殊的处理或者传输顺序。也没提供任何机制让流的发起者能强制或要求接收端对当前流进行特殊处理。
        </t>
        <t>
          Unless explicitly specified in the <x:ref>HEADERS</x:ref> frame (<xref target="HEADERS"/>)
          during stream creation, the default stream priority is 2<x:sup>30</x:sup>.

          除非在<x:ref>HEADERS</x:ref>(<xref target="HEADERS"/>)帧中明确设置，默认的流优先级是2的三十次方。
        </t>
        <t>
          <xref target="PushResources">Pushed streams</xref> have a lower priority than their
          associated stream.  The promised stream inherits the priority value of the associated
          stream plus one, up to a maximum of 2<x:sup>31</x:sup>-1.

          <xref target="PushResources">推送流</xref>比其他相关的流优先级低。被承诺的流继承了其相关的流优先级并加1，最多2<x:sup>31</x:sup>-1.
        </t>
      </section>

      <section title="Error Handling">
        <t>
          HTTP/2 framing permits two classes of error:

          HTTP/2框架允许两类错误：
          <list style="symbols">
            <t>
              An error condition that renders the entire connection unusable is a connection error.

              使整个连接不可用的错误。
            </t>
            <t>
              An error in an individual stream is a stream error.

              单个流中出现的错误。
            </t>
          </list>
        </t>
        <t>
          A list of error codes is included in <xref target="ErrorCodes"/>.

          错误码列表可以在<xref target="ErrorCodes"/>找到。
        </t>

        <section anchor="ConnectionErrorHandler" title="Connection Error Handling">
          <t>
            A connection error is any error which prevents further processing of the framing layer,
            or which corrupts any connection state.

            流错误是阻止帧层更进一步进行处理或者破坏任何流状态的错误。
          </t>
          <t>
            An endpoint that encounters a connection error SHOULD first send a <x:ref>GOAWAY</x:ref>
            frame (<xref target="GOAWAY"/>) with the stream identifier of the last stream that it
            successfully received from its peer.  The <x:ref>GOAWAY</x:ref> frame includes an error
            code that indicates why the connection is terminating.  After sending the
            <x:ref>GOAWAY</x:ref> frame, the endpoint MUST close the TCP connection.

            发送流错误的终端应当首先发送一个<x:ref>超时GOAWAY</x:ref>帧(<xref target="GOAWAY"/>)，并带有最近的一个成功从对等端接收帧的流的标识符。<x:ref>GOAWAY</x:ref>超时帧包含链接终端的错误码。发送<x:ref>GOAWAY</x:ref>后，终端必须关闭TCP连接。
          </t>
          <t>
            It is possible that the <x:ref>GOAWAY</x:ref> will not be reliably received by the
            receiving endpoint.  In the event of a connection error, <x:ref>GOAWAY</x:ref> only
            provides a best-effort attempt to communicate with the peer about why the connection is
            being terminated.

            <x:ref>超时GOAWAY</x:ref>帧有可能不被接收端有效接收。在连接错误事件中，<x:ref>超时GOAWAY</x:ref>帧是尝试跟对等端通信告知连接终止原因的最佳实践。
          </t>
          <t>
            An endpoint can end a connection at any time.  In particular, an endpoint MAY choose to
            treat a stream error as a connection error.  Endpoints SHOULD send a
            <x:ref>GOAWAY</x:ref> frame when ending a connection, as long as circumstances permit
            it.

            终端可以在任何时候终止一个连接。类似的，终端可以选择将流错误作为连接错误处理。只要环境许可，终端在终止连接时应当发送一个<x:ref>GOAWAY</x:ref>帧。
          </t>
        </section>

        <section anchor="StreamErrorHandler" title="Stream Error Handling">
          <t>
            A stream error is an error related to a specific stream identifier that does not affect
            processing of other streams.

            流错误是与特定标识的流相关的错误，并且不会影响其他流的处理。
          </t>
          <t>
            An endpoint that detects a stream error sends a <x:ref>RST_STREAM</x:ref> frame (<xref
            target="RST_STREAM"/>) that contains the stream identifier of the stream where the error
            occurred.  The <x:ref>RST_STREAM</x:ref> frame includes an error code that indicates the
            type of error.

            终端检测到流错误时发送一个带有错误发生时的流标识符的<x:ref>RST_STREAM</x:ref>帧(<xref
            target="RST_STREAM"/>)。<x:ref>RST_STREAM</x:ref>帧带有表示错误类型的错误码。
          </t>
          <t>
            A <x:ref>RST_STREAM</x:ref> is the last frame that an endpoint can send on a stream.
            The peer that sends the <x:ref>RST_STREAM</x:ref> frame MUST be prepared to receive any
            frames that were sent or enqueued for sending by the remote peer.  These frames can be
            ignored, except where they modify connection state (such as the state maintained for
            <xref target="HeaderBlock">header compression</xref>).

            <x:ref>RST_STREAM</x:ref>是终端可以发送一个流的最后一帧。发送<x:ref>RST_STREAM</x:ref>帧的对等端必须准备好接收任何由远端对等端发送或者准备发送的帧。这些帧可以被忽略，除非连接状态被修改（例如报头压缩中的状态）。
          </t>
          <t>
            Normally, an endpoint SHOULD NOT send more than one <x:ref>RST_STREAM</x:ref> frame for
            any stream. However, an endpoint MAY send additional <x:ref>RST_STREAM</x:ref> frames if
            it receives frames on a closed stream after more than a round-trip time.  This behavior
            is permitted to deal with misbehaving implementations.

            通常，终端不应该在任何流觞发送多个<x:ref>RST_STREAM</x:ref>帧。但是，终端如果在一个关闭的流上超过rtt时间后收到帧，则可以发送的额外的<x:ref>RST_STREAM</x:ref>帧。这种做法是被允许用来处理这种非常规情况。
          </t>
          <t>
            An endpoint MUST NOT send a <x:ref>RST_STREAM</x:ref> in response to an
            <x:ref>RST_STREAM</x:ref> frame, to avoid looping.

            终端绝不能在收到<x:ref>RST_STREAM</x:ref>帧后响应一个<x:ref>RST_STREAM</x:ref>帧，避免死循环。
          </t>
        </section>

        <section title="Connection Termination">
          <t>
            If the TCP connection is torn down while streams remain in open or half closed states,
            then the endpoint MUST assume that those streams were abnormally interrupted and could
            be incomplete.

            如果TCP连接在流仍然保持打开或者半封闭状态下断开，那么终端必须假定这些流是异常终端且不完整的。
          </t>
        </section>
      </section>
    </section>

    <section anchor="frame-types" title="Frame Definitions">
        <t>
          This specification defines a number of frame types, each identified by a unique 8-bit type
          code. Each frame type serves a distinct purpose either in the establishment and management
          of the connection as a whole, or of individual streams.

          本规范定义了一系列的帧类型，每种类型由独特的8位类型代码标记。不管是在连接管理或单独的流中，每种帧都为了特定的目的而服务。
        </t>
        <t>
          The transmission of specific frame types can alter the state of a connection. If endpoints
          fail to maintain a synchronized view of the connection state, successful communication
          within the connection will no longer be possible. Therefore, it is important that
          endpoints have a shared comprehension of how the state is affected by the use any given
          frame.

          特定帧类型的传输可以修改连接的状态。如果终端不能保持同步的连接状态，连接中的通信将失败。因此，终端对于如何使用给定帧修改状态需要达成共识。
        </t>

        <section anchor="DATA" title="DATA">
          <t>
            DATA frames (type=0x0) convey arbitrary, variable-length sequences of octets associated
            with a stream. One or more DATA frames are used, for instance, to carry HTTP request or
            response payloads.

            数据帧（类型=0x0）表示随意，由伴随流的可变长度序列组成。例如，一个或多个数据帧被用来携带HTTP请求或者响应的载体。
          </t>
          <t>
            DATA frames MAY also contain arbitrary padding.  Padding can be added to DATA frames to
            hide the size of messages.

            数据帧也可以包含任意包装物。包装物可以添加到数据帧中来隐藏消息的大小。
          </t>
          <figure title="DATA Frame Payload">
            <artwork type="inline"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | [Pad High(8)] | [Pad Low (8)] |          Data (*)             .
 +---------------+---------------+-------------------------------+
 .                            Data (*)                         ...
 +---------------------------------------------------------------+
 |                           Padding (*)                       ...
 +---------------------------------------------------------------+
]]></artwork>
          </figure>
          <t>
            The DATA frame contains the following fields:

            数据帧包含以下字段：
            <list style="hanging">
              <t hangText="Pad High:">
                An 8-bit field containing an amount of padding in units of 256 octets.  This field
                is optional and is only present if the PAD_HIGH flag is set.  This field, in
                combination with Pad Low, determines how much padding there is on a frame.

                包含单位为256字节的填充量的8位字段。这个字段是可选的，并且只在设置了PAD_HIGH标记的情况下呈现。这个字段与Pad Low一起决定了帧上面有多少填充量。
              </t>
              <t hangText="Pad Low:">
                An 8-bit field containing an amount of padding in units of single octets.  This
                field is optional and is only present if the PAD_LOW flag is set.  This field, in
                combination with Pad High, determines how much padding there is on a frame.

                包含单位为单个字节的填充量的8为字段。这个字段是可选的并且只在设置了PAD_LOW标记的情况下呈现。这个字段与Pad High一起决定了帧上面有多少填充量。
              </t>
              <t hangText="Data:">
                Application data.  The amount of data is the remainder of the frame payload after
                subtracting the length of the other fields that are present.

                应用数据。数据量的大小是帧的有效载荷减去其他呈现字段的长度。
              </t>
              <t hangText="Padding:">
                Padding octets that contain no application semantic value.  Padding octets MUST be
                set to zero when sending and ignored when receiving.

                填充字节不包含任何应用语义值。天聪字节必须在发送的时候设置为0，在接受的时候忽略。
              </t>
            </list>
          </t>

          <t>
            The DATA frame defines the following flags:

            数据帧定义了以下标记：
            <list style="hanging">
              <t hangText="END_STREAM (0x1):">
                Bit 1 being set indicates that this frame is the last that the endpoint will send
                for the identified stream.  Setting this flag causes the stream to enter one of
                <xref target="StreamStates">the "half closed" states or the "closed" state</xref>.

                1位用来表示当前帧是确定的流发送的最后一帧。设置这个标记时流进入到一种半封闭状态或者关闭状态。
              </t>
              <t hangText="END_SEGMENT (0x2):">
                Bit 2 being set indicates that this frame is the last for the current segment.
                Intermediaries MUST NOT coalesce frames across a segment boundary and MUST preserve
                segment boundaries when forwarding frames.

                2位表示是当前端的最后一帧。代理端绝对不能跨越多个端的边界来合并帧，转发帧的时候代理端必须保持片段的边界。
              </t>
              <t hangText="PAD_LOW (0x10):">
                Bit 5 being set indicates that the Pad Low field is present.

                5位用来表示Pad Low 字段是可见的。
              </t>
              <t hangText="PAD_HIGH (0x20):">
                Bit 6 being set indicates that the Pad High field is present.  This bit MUST NOT be
                set unless the PAD_LOW flag is also set.  Endpoints that receive a frame with
                PAD_HIGH set and PAD_LOW cleared MUST treat this as a <xref
                target="ConnectionErrorHandler">connection error</xref> of type
                <x:ref>PROTOCOL_ERROR</x:ref>.

                6位用来标识Pad High字段是可见的。除非设置了PAD_LOW标记才能设置此标记。终端接收到带有PAD_HIGH设置但是PAD_LOW被清除的必须作为类型为协议错误的连接错误来处理。
              </t>
            </list>
          </t>
          <t>
            DATA frames MUST be associated with a stream. If a DATA frame is received whose stream
            identifier field is 0x0, the recipient MUST respond with a <xref
            target="ConnectionErrorHandler">connection error</xref> of type
            <x:ref>PROTOCOL_ERROR</x:ref>.

            数据帧绝对需要与流相关联。如果接收到流标记字段是0x0的数据帧，必须响应一个类型为协议错误的连接错误。
          </t>
          <t>
            DATA frames are subject to flow control and can only be sent when a stream is in the
            "open" or "half closed (remote)" states. Padding is included in flow control.  If
            a DATA frame is received whose stream is not in "open" or "half closed (local)" state,
            the recipient MUST respond with a <xref target="StreamErrorHandler">stream error</xref>
            of type <x:ref>STREAM_CLOSED</x:ref>.

            数据帧遵从流量控制，并且只有在流是打开或者半封闭(远端)状态下才能够被发送。填充同样包含在流量控制中。如果数据帧在相关流不是在打开和半封闭(本地)状态下被接收，接收端必须响应一个类型为流关闭的流错误。
          </t>
          <t>
            The total number of padding octets is determined by multiplying the value of the Pad
            High field by 256 and adding the value of the Pad Low field.  Both Pad High and Pad Low
            fields assume a value of zero if absent.  If the length of the padding is greater than
            the length of the remainder of the frame payload, the recipient MUST treat this as a
            <xref target="ConnectionErrorHandler">connection error</xref> of type
            <x:ref>PROTOCOL_ERROR</x:ref>.

            填充字节的总数由Pad High的值乘以256加上Pad Low 的值决定。二者默认值均为0。如果填充物的大小大于帧有效载荷的大小，接收端必须作为类型为协议错误的连接错误处理。

            <list style="hanging">
              <t hangText="Note:">
                A frame can be increased in size by one octet by including a Pad Low field with a
                value of zero.

                加上值为0的Pad Low值后，帧大小将加1字节。
              </t>
            </list>
          </t>
          <t>
            Use of padding is a security feature; as such, its use demands some care, see <xref
            target="padding"/>.

            使用填充是一种安全手段；例如，用来满足特定需求，见<xref target="padding"/>.
          </t>
        </section>

        <section anchor="HEADERS" title="HEADERS">
          <t>
            The HEADERS frame (type=0x1) carries name-value pairs. It is used to <xref
            target="StreamStates">open a stream</xref>.  HEADERS frames can be sent on a stream in
            the "open" or "half closed (remote)" states.

            报头帧(类型=0x1)由键值对组成。它用来打开一个流。报头帧能在流打开或者半封闭(远程)的状态下发送。
          </t>
          <figure title="HEADERS Frame Payload">
            <artwork type="inline"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | [Pad High(8)] | [Pad Low (8)] |X|      [Priority (31)]      ...
 +---------------+---------------+-+-----------------------------+
 ...      [Priority]             | Header Block Fragment (*)   ...
 +-------------------------------+-------------------------------+
 |                   Header Block Fragment (*)                 ...
 +---------------------------------------------------------------+
 |                           Padding (*)                       ...
 +---------------------------------------------------------------+
]]></artwork>
          </figure>
          <t>
            The HEADERS frame payload has the following fields:

            报头帧主体有以下字段：
            <list style="hanging">
              <t hangText="Pad High:">
                Padding size high bits.  This field is only present if the PAD_HIGH flag is set.

                填充大小的高位。这个字段只有在设置了PAD_HIGH 标记的情况下才呈现。

              </t>
              <t hangText="Pad Low:">
                Padding size low bits.  This field is only present if the PAD_LOW flag is set.

                填充大小低位。这个字段只有在设置了PAD_LOW 标记的情况下才呈现。
              </t>
              <t hangText="X:">
                A single reserved bit.  This field is optional and is only present if the PRIORITY
                flag is set.

                单一保留位。这个字段是可选的，并且只在优先级标记设置的情况下才呈现。
              </t>
              <t hangText="Priority:">
                Prioritization information for the stream, see <xref target="StreamPriority"/>.
                This field is optional and is only present if the PRIORITY flag is set.

                流的优先级信息。见<xref target="StreamPriority"/>.这个字段是可选的，并且只在优先级标记设置的情况下才呈现。
              </t>
              <t hangText="Header Block Fragment:">
                A <xref target="HeaderBlock">header block fragment</xref>.

                报头块碎片。
              </t>
              <t hangText="Padding:">
                Padding octets.

                填充字节。
              </t>
            </list>
          </t>

          <t>
            The HEADERS frame defines the following flags:

            报头帧定义了以下标记：
            <list style="hanging">
              <x:lt hangText="END_STREAM (0x1):">
                <t>
                  Bit 1 being set indicates that the <xref target="HeaderBlock">header block</xref>
                  is the last that the endpoint will send for the identified stream.  Setting this
                  flag causes the stream to enter one of <xref target="StreamStates">"half closed"
                  states</xref>.

                  1位用来标识这是发送端对确定的流发送的最后报头区块。设置这个标记将使流进入一种半封闭状态。
                </t>
                <t>
                  A HEADERS frame that is followed by <x:ref>CONTINUATION</x:ref> frames carries the
                  END_STREAM flag that signals the end of a stream.  A <x:ref>CONTINUATION</x:ref>
                  frame cannot be used to terminate a stream.

                  后面伴随带有END_STREAM标记的延续帧的报头帧表示流的终止。延续帧不用来用终止流。
                </t>
              </x:lt>
              <x:lt hangText="END_SEGMENT (0x2):">
                <t>
                  Bit 2 being set indicates that this frame is the last for the current segment.
                  Intermediaries MUST NOT coalesce frames across a segment boundary and MUST preserve
                  segment boundaries when forwarding frames.

                  位2表示这是当前端的最后一帧。中介者绝对不能跨片段来合并帧，且在转发帧的时候必须保持片段的边界。
                </t>
              </x:lt>
              <x:lt hangText="END_HEADERS (0x4):">
                <t>
                  Bit 3 being set indicates that this frame contains an entire <xref
                  target="HeaderBlock">header block</xref> and is not followed by any
                  <x:ref>CONTINUATION</x:ref> frames.

                  3 位表示帧包含了整个的报头块，且后面没有延续帧。
                </t>
                <t>
                  A HEADERS frame without the END_HEADERS flag set MUST be followed by a
                  <x:ref>CONTINUATION</x:ref> frame for the same stream.  A receiver MUST treat the
                  receipt of any other type of frame or a frame on a different stream as a <xref
                  target="ConnectionErrorHandler">connection error</xref> of type
                  <x:ref>PROTOCOL_ERROR</x:ref>.

                  不带有END_HEADERS标记的报头帧在同个流上后面必须跟着延续帧。接收端接收到任何其他类型的帧或者在其他流上的帧必须作为类型为协议错误的连接错误处理。
                </t>
              </x:lt>
              <x:lt hangText="PRIORITY (0x8):">
                <t>
                  Bit 4 being set indicates that the frame contains a single reserved bit and a
                  31-bit priority; see <xref target="StreamPriority"/>. If this bit is not set,
                  those four bytes do not appear.

                  4 位表示帧带有单独的保留为并且和一个31位的优先级。见<xref target="StreamPriority"/>.如果此为未设置，那四个字节不会出现。
                </t>
              </x:lt>
              <x:lt hangText="PAD_LOW (0x10):">
                <t>
                  Bit 5 being set indicates that the Pad Low field is present.

                  位5 表示Pad Low 字段会呈现。
                </t>
              </x:lt>
              <x:lt hangText="PAD_HIGH (0x20):">
                <t>
                  Bit 6 being set indicates that the Pad High field is present.  This bit MUST NOT
                  be set unless the PAD_LOW flag is also set.  Endpoints that receive a frame with
                  PAD_HIGH set and PAD_LOW cleared MUST treat this as a <xref
                  target="ConnectionErrorHandler">connection error</xref> of type
                  <x:ref>PROTOCOL_ERROR</x:ref>.

                  为6表示Pad High字段会呈现。除非PAD_LOW标记设置此标记才能设置。终端收到带有Pad High设置但是没有PAD_LOW标记的必须作为类型为协议错误的连接错误处理。
                </t>
              </x:lt>
            </list>
          </t>

          <t>
            The payload of a HEADERS frame contains a <xref target="HeaderBlock">header block
            fragment</xref>.  A header block that does not fit within a HEADERS frame is continued
            in a <xref target="CONTINUATION">CONTINUATION frame</xref>.

            报头帧的主体包含一个报头区块碎片。报头区块大于一个报头帧的将在延续帧中继续传送。
          </t>

          <t>
            HEADERS frames MUST be associated with a stream. If a HEADERS frame is received whose
            stream identifier field is 0x0, the recipient MUST respond with a <xref
            target="ConnectionErrorHandler">connection error</xref> of type
            <x:ref>PROTOCOL_ERROR</x:ref>.

            报头帧必须与一个流相关联。如果一个接收到一个流标示识0x0得报头帧，接收端必须响应一个类型为协议错误的连接错误。
          </t>

          <t>
            The HEADERS frame changes the connection state as described in <xref
            target="HeaderBlock" />.

            报头帧改变连接状态在此中表述。
          </t>

          <t>
            The HEADERS frame includes optional padding.  Padding fields and flags are identical to
            those defined for <xref target="DATA">DATA frames</xref>.

            报头帧包含可选的填充段。填充字段和标记同数据帧中描述。
          </t>
        </section>

        <section anchor="PRIORITY" title="PRIORITY">
          <t>
            The PRIORITY frame (type=0x2) specifies the sender-advised priority of a stream.  It can
            be sent at any time for an existing stream. This enables reprioritisation of existing
            streams.

            优先级帧(type=0x2)明确了发送者建议的流的优先级。它可以任意时间在存在的流中发送。这个使存在的流有了优先级次序。
          </t>
          <figure title="PRIORITY Frame Payload">
            <artwork type="inline"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |X|                        Priority (31)                        |
 +-+-------------------------------------------------------------+
]]></artwork>
          </figure>
          <t>
            The payload of a PRIORITY frame contains a single reserved bit and a 31-bit priority.

            优先级帧的主体包含一个保留的位及31位的优先级。
          </t>
          <t>
            The PRIORITY frame does not define any flags.

            优先级不定义任何标记。
          </t>

          <t>
            The PRIORITY frame is associated with an existing stream. If a PRIORITY frame is
            received with a stream identifier of 0x0, the recipient MUST respond with a <xref
            target="ConnectionErrorHandler">connection error</xref> of type
            <x:ref>PROTOCOL_ERROR</x:ref>.

            优先级与存在的流相关联。如果接收端收到流标识为0的优先级帧，必须响应一个类型为协议错误的连接错误。
          </t>
          <t>
            The PRIORITY frame can be sent on a stream in any of the "reserved (remote)", "open",
            "half-closed (local)", or "half closed (remote)" states, though it cannot be sent
            between consecutive frames that comprise a single <xref target="HeaderBlock">header
            block</xref>.  Note that this frame could arrive after processing or frame sending has
            completed, which would cause it to have no effect.  For a stream that is in the "half
            closed (remote)" state, this frame can only affect processing of the stream and not
            frame transmission.

            优先级帧可以在流状态为“保留(远端)”、“打开"、“半封闭(本地)”或者“半封闭(远程)”状态下发送,但它不能在由单个报头区块组成的连续帧之间发送。需要注意的是这个帧可能在处理或者帧发送已经完成之后才到达，这可能导致没有效果。对于处于“半封闭(远程)”状态下的流，优先级帧只能影响流的处理而不是传输。
          </t>
        </section>

        <section anchor="RST_STREAM" title="RST_STREAM">
          <t>
            The RST_STREAM frame (type=0x3) allows for abnormal termination of a stream.  When sent
            by the initiator of a stream, it indicates that they wish to cancel the stream or that
            an error condition has occurred.  When sent by the receiver of a stream, it indicates
            that either the receiver is rejecting the stream, requesting that the stream be
            cancelled or that an error condition has occurred.

            RST_STREAM帧(type=0x3)允许流的异常终止。当被流的指示器发送时，它表示期望取消流或者错误条件发生。当被接收端的流发送时，它表示接收者希望拒绝流、流被取消或者发生了错误。
          </t>
          <figure title="RST_STREAM Frame Payload">
            <artwork type="inline"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                        Error Code (32)                        |
 +---------------------------------------------------------------+
]]></artwork>
          </figure>

          <t>
            The RST_STREAM frame contains a single unsigned, 32-bit integer identifying the <xref
            target="ErrorCodes">error code</xref>.  The error code indicates why the stream is being
            terminated.

            RST_STREAM 帧由一个无符号的32位整数标记错误码。错误码指明流被终止的原因。
          </t>

          <t>
            The RST_STREAM frame does not define any flags.

            RST_STREAM 帧未定义任何标记。
          </t>

          <t>
            The RST_STREAM frame fully terminates the referenced stream and causes it to enter the
            closed state. After receiving a RST_STREAM on a stream, the receiver MUST NOT send
            additional frames for that stream. However, after sending the RST_STREAM, the sending
            endpoint MUST be prepared to receive and process additional frames sent on the stream
            that might have been sent by the peer prior to the arrival of the RST_STREAM.

            RST_STREAM 帧完全终止相关的流并使其转入关闭状态。在接收到流的RST_STREAM帧后，接收端绝对不能在流上发送额外的帧。然而，在发送RST_STREAM帧后，发送端必须要准备接收并处理流上的其他帧，因为对等端有可能在收到RST_STREAM帧前就已经发送。
          </t>

          <t>
            RST_STREAM frames MUST be associated with a stream.  If a RST_STREAM frame is received
            with a stream identifier of 0x0, the recipient MUST treat this as a <xref
            target="ConnectionErrorHandler">connection error</xref> of type
            <x:ref>PROTOCOL_ERROR</x:ref>.

            RST_STREAM 帧必须与流相关联。如果接收端收到流标示符为0x0的RST_STREAM 帧，必须作为类型为协议错误的连接错误处理。
          </t>

          <t>
            RST_STREAM frames MUST NOT be sent for a stream in the "idle" state.  If a RST_STREAM
            frame identifying an idle stream is received, the recipient MUST treat this as a <xref
            target="ConnectionErrorHandler">connection error</xref> of type
            <x:ref>PROTOCOL_ERROR</x:ref>.

            RST_STREAM帧绝对不能在流处于“空闲”状态下发送。如果接收端收到流状态为空闲的RST_STREAM帧，必须作为类型为协议错误的连接错误处理。
          </t>

        </section>

        <section anchor="SETTINGS" title="SETTINGS">
          <t>
            The SETTINGS frame (type=0x4) conveys configuration parameters (such as preferences and
            constraints on peer behavior) that affect how endpoints communicate, and is also used
            to acknowledge the receipt of those parameters. Individually, a SETTINGS parameter can
            also be referred to as a "setting".

            设置帧(type=0x4)包含影响如何与终端通信的设置参数(例如偏好设置以及对等端的行为约束)，并且用来确认这些参数的接收。单个的设置参数也可以被认为是“设置”。
          </t>
          <t>
            SETTINGS parameters are not negotiated; they describe characteristics of the sending
            peer, which are used by the receiving peer. Different values for the same parameter can
            be advertised by each peer. For example, a client might set a high initial flow control
            window, whereas a server might set a lower value to conserve resources.

            设置参数不是通过协商确定的；它们描述发送端的特点，并被接收端使用。相同的参数对不同的对等端设置可能不同。例如，一个客户端可能设置一个较高的流量控制窗口，而服务器为了保存资源可能设置一个较低的值。
          </t>

          <t>
            A SETTINGS frame MUST be sent by both endpoints at the start of a connection, and MAY
            be sent at any other time by either endpoint over the lifetime of the connection.
            Implementations MUST support all of the parameters defined by this specification.

            设置帧必须由两个终端在连接开始的时候发送，并且可以由各个终端在连接生存期的任意时间发送。
            具体实现必须支持本规范定义的所有参数。
          </t>

          <t>
            Each parameter in a SETTINGS frame replaces any existing value for that parameter.
            Parameters are processed in the order in which they appear, and a receiver of a
            SETTINGS frame does not need to maintain any state other than the current value of its
            parameters. Therefore, the value of a SETTINGS parameter is the last value that is seen
            by a receiver.

            设置帧的所有参数将替换参数中现有值。参数由他们出现的顺序来处理，而且接收设置帧并不需要保存当前值以外的任何状态。因此，设置参数的值是接收端接收到的最后一个值。
          </t>
          <t>
            SETTINGS parameters are acknowledged by the receiving peer. To enable this, the SETTINGS
            frame defines the following flag:

            设置参数是被接收端公认的。为了实现这个，设置帧定义了以下标记：
            <list style="hanging">
              <t hangText="ACK (0x1):">
                Bit 1 being set indicates that this frame acknowledges receipt and application of
                the peer's SETTINGS frame.  When this bit is set, the payload of the SETTINGS frame
                MUST be empty.  Receipt of a SETTINGS frame with the ACK flag set and a length field
                value other than 0 MUST be treated as a <xref
                target="ConnectionErrorHandler">connection error</xref> of type
                <x:ref>FRAME_SIZE_ERROR</x:ref>.  For more info, see <xref
                target="SettingsSync">Settings Synchronization</xref>.

                位1表示设置帧已被接收端接收并应用。如果这个位设置了，设置帧的载体必须为空。接收到字段长度不是0的带有ACK标记的设置帧必须作为类型为帧大小错误的连接错误处理。更多信息，见此。
              </t>
            </list>
          </t>
          <t>
            SETTINGS frames always apply to a connection, never a single stream.  The stream
            identifier for a SETTINGS frame MUST be zero. If an endpoint receives a SETTINGS frame
            whose stream identifier field is anything other than 0x0, the endpoint MUST respond with
            a <xref target="ConnectionErrorHandler">connection error</xref> of type
            <x:ref>PROTOCOL_ERROR</x:ref>.

            设置帧总是应用于连接，而不是一个单独的流。流的设置帧标识必须为0.如果终端接收到流设置帧标识不是0的设置帧，必须响应一个类型为协议错误的连接错误。
          </t>
          <t>
            The SETTINGS frame affects connection state.  A badly formed or incomplete SETTINGS
            frame MUST be treated as a <xref target="ConnectionErrorHandler">connection error</xref>
            of type <x:ref>PROTOCOL_ERROR</x:ref>.

            设置帧影响连接状态。格式错误或者未完成的设置帧必须作为类型为协议错误的连接错误处理。
          </t>

          <section title="SETTINGS Format" anchor="SettingFormat">
            <t>
              The payload of a SETTINGS frame consists of zero or more parameters, each consisting
              of an unsigned 8-bit identifier and an unsigned 32-bit value.

              设置帧载体包含0个或多个参数，每个包含一个无符号的8位标识以及一个无符号的32位值。
            </t>

            <figure title="Setting Format">
              <artwork type="inline"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |Identifier (8) |                 Value (32)                  ...
 +---------------+-----------------------------------------------+
 ...Value        |
 +---------------+
]]></artwork>
            </figure>
          </section>

          <section anchor="SettingValues" title="Defined SETTINGS Parameters">
            <t>
              The following parameters are defined:

              定义了以下参数：
              <list style="hanging">
                <x:lt hangText="SETTINGS_HEADER_TABLE_SIZE (1):" anchor="SETTINGS_HEADER_TABLE_SIZE">
                  <t>
                    Allows the sender to inform the remote endpoint of the size of the
                    header compression table used to decode header blocks. The encoder can reduce
                    this size by using signaling specific to the header compression format inside a
                    header block.  The initial value is 4,096 bytes.

                    允许发送端通知远端终端解码报头区块的报头压缩表的大小。这个编码器可以在报头区块中使用特定信号来减少报头压缩的大小。初始值是4,096个字节。
                  </t>
                </x:lt>
                <x:lt hangText="SETTINGS_ENABLE_PUSH (2):" anchor="SETTINGS_ENABLE_PUSH">
                  <t>
                    This setting can be use to disable <xref target="PushResources">server
                    push</xref>. An endpoint MUST NOT send a <x:ref>PUSH_PROMISE</x:ref> frame if
                    it receives this parameter set to a value of 0. An endpoint that has both set
                    this parameter to 0 and had it acknowledged MUST treat the receipt of a
                    <x:ref>PUSH_PROMISE</x:ref> frame as a <xref
                    target="ConnectionErrorHandler">connection error</xref> of type
                    <x:ref>PROTOCOL_ERROR</x:ref>.

                    这个参数可以用来关闭服务器推送。终端在接收到此参数为0的情况下绝对不能发送服务器推送帧。终端在已经设置此参数为0并且承认的情况下必须对接收到的服务器推送作为类型为协议错误的连接错误处理。
                  </t>
                  <t>
                    The initial value is 1, which indicates that push is permitted. Any value other
                    than 0 or 1 MUST be treated as a  <xref
                      target="ConnectionErrorHandler">connection error</xref> of type
                    <x:ref>PROTOCOL_ERROR</x:ref>.

                    初始值是1，表示推送是许可的。任何不是0或1的值必须作为类型为协议错误的连接错误处理。
                  </t>
                </x:lt>
                <x:lt hangText="SETTINGS_MAX_CONCURRENT_STREAMS (3):" anchor="SETTINGS_MAX_CONCURRENT_STREAMS">
                  <t>
                    Indicates the maximum number of concurrent streams that the sender will allow.
                    This limit is directional: it applies to the number of streams that the sender
                    permits the receiver to create. Initially there is no limit to this value.  It
                    is recommended that this value be no smaller than 100, so as to not
                    unnecessarily limit parallelism.

                    标明发送者允许的最大并发流。此限制是定向的：它适用于发送端允许接收端创建的最大并发流的数量。初始化时这个值没有限制。建议值不要大于100,以免不必要的限制并行。
                  </t>
                  <t>
                    A value of 0 for SETTINGS_MAX_CONCURRENT_STREAMS SHOULD NOT be treated as
                    special by endpoints.  A zero value does prevent the creation of new streams,
                    however this can also happen for any limit that is exhausted with active
                    streams.  Servers SHOULD only set a zero value for short durations; if a server
                    does not wish to accept requests, closing the connection could be preferable.

                    此设置为0的值不应该被终端认为是特殊的。0的值阻止了新的流的创建，另外它也适用于被激活的流用尽的任何限制。对于短连接不应该设置此参数为0；如果服务端不希望接收任何请求，最佳的做法是关闭连接。
                   </t>
                </x:lt>
                <x:lt hangText="SETTINGS_INITIAL_WINDOW_SIZE (4):" anchor="SETTINGS_INITIAL_WINDOW_SIZE">
                  <t>
                    Indicates the sender's initial window size (in bytes) for stream level flow
                    control.  The initial value is 65,535.

                    表示发送端对流层流量控制的初始窗口大小(字节单位)。初始值是65,535。
                  </t>
                  <t>
                    This setting affects the window size of all streams, including existing
                    streams, see <xref target="InitialWindowSize"/>.

                    这个参数影响了所有流的窗口大小，包括现有的流。见<xref target="InitialWindowSize"/>.
                  </t>
                  <t>
                    Values above the maximum flow control window size of 2<x:sup>31</x:sup> - 1 MUST
                    be treated as a <xref target="ConnectionErrorHandler">connection error</xref> of
                    type <x:ref>FLOW_CONTROL_ERROR</x:ref>.

                    流量控制窗口大小值大于2的31次方-1的必须被作为流量控制错误的连接错误处理。
                  </t>
                </x:lt>
              </list>
            </t>
            <t>
              An endpoint that receives a SETTINGS frame with any other identifier MUST
              treat this as a <xref target="ConnectionErrorHandler">connection error</xref> of type
              <x:ref>PROTOCOL_ERROR</x:ref>.

              终端收到其他标记的设置帧必须作为类型为协议错误的连接错误处理。
            </t>
          </section>

          <section anchor="SettingsSync" title="Settings Synchronization">
            <t>
              Most values in SETTINGS benefit from or require an understanding of when the peer has
              received and applied the changed the communicated parameter values. In order to
              provide such synchronization timepoints, the recipient of a SETTINGS frame in which
              the ACK flag is not set MUST apply the updated parameters as soon as possible upon
              receipt.

              大部分设置值收益于或者需要了解对等端接收到并且改变了通信过的参数的值的时机。为了提供这样一种同步的时间点，接收到没有设置ACK标记的设置帧必须尽快将更新过的参数适用于接收端上。
            </t>
            <t>
              The values in the SETTINGS frame MUST be applied in the order they appear, with no
              other frame processing between values. Once all values have been applied, the
              recipient MUST immediately emit a SETTINGS frame with the ACK flag set. Upon
              receiving a SETTINGS frame with the ACK flag set, the sender of the altered parameters
              can rely upon their application.

              设置帧的值必须按照它们出现的顺序被使用，在处理值中间不能处理其他帧。一旦所有的值被应用，接收端必须马上发送一个带有ACK标记的设置帧。在接收到带有ACK标记的设置帧后，修改参数的发送端可以认为修改已生效。
            </t>
            <t>
              If the sender of a SETTINGS frame does not receive an acknowledgement within a
              reasonable amount of time, it MAY issue a <xref
              target="ConnectionErrorHandler">connection error</xref> of type
              <x:ref>SETTINGS_TIMEOUT</x:ref>.

              如果设置参数的发送端没有在一定时间内收到认可的响应，它可以发出一个类型为设置超时的连接错误。
            </t>
          </section>
        </section>

        <section anchor="PUSH_PROMISE" title="PUSH_PROMISE">
          <t>
            The PUSH_PROMISE frame (type=0x5) is used to notify the peer endpoint in advance of
            streams the sender intends to initiate.  The PUSH_PROMISE frame includes the unsigned
            31-bit identifier of the stream the endpoint plans to create along with a set of
            headers that provide additional context for the stream.  <xref target="PushResources"/>
            contains a thorough description of the use of PUSH_PROMISE frames.

            推送帧(type=0x5)用来在流发送者准备发送流之前告知对等端。推送帧包含了终端准备创建的长流的31位无符号标记以及提供附加上下文的报头的集合。<xref target="PushResources"/>中详细描述了推送帧的使用。
          </t>
          <t>
            PUSH_PROMISE MUST NOT be sent if the <x:ref>SETTINGS_ENABLE_PUSH</x:ref> setting of the
            peer endpoint is set to 0.

            如果SETTINGS_ENABLE_PUSH设置参数为0，推送帧绝对不能被发送。
          </t>

          <figure title="PUSH_PROMISE Payload Format">
            <artwork type="inline"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | [Pad High(8)] | [Pad Low (8)] |X|  Promised Stream ID (31)  ...
 +---------------+---------------+-+-----------------------------+
 ...    Promised Stream ID       | Header Block Fragment (*)   ...
 +-------------------------------+-------------------------------+
 |                   Header Block Fragment (*)                 ...
 +---------------------------------------------------------------+
 |                           Padding (*)                       ...
 +---------------------------------------------------------------+
]]></artwork>
          </figure>
          <t>
            The HEADERS frame payload has the following fields:

            报头帧载体包含以下字段：
            <list style="hanging">
              <t hangText="Pad High:">
                Padding size high bits.  This field is only present if the PAD_HIGH flag is set.

                填充大小高位。这个字段只有在PAD_HIGH标记设置的情况下才呈现。
              </t>
              <t hangText="Pad Low:">
                Padding size low bits.  This field is only present if the PAD_LOW flag is set.

                填充大小低位。这个字段只有在PAD_LOW标记设置的情况下才呈现。
              </t>
              <t hangText="X:">
                A single reserved bit.

                单独的保留位。
              </t>
              <t hangText="Promised Stream ID:">
                This unsigned 31-bit integer identifies the stream the endpoint intends to start
                sending frames for.  The promised stream identifier MUST be a valid choice for the
                next stream sent by the sender (see <xref target="StreamIdentifiers">new stream
                identifier</xref>).

                这个无符号31位整数表示终端准备发送的流标记。被承诺的流标记必须对发送端准备发送的下一个流来说是有效选择。
              </t>
              <t hangText="Header Block Fragment:">
                A <xref target="HeaderBlock">header block fragment</xref> containing request header
                fields.

                包含请求头字段的报头区块碎片。
              </t>
              <t hangText="Padding:">
                Padding octets.

                填充字节。
              </t>
            </list>
          </t>

          <t>
            The PUSH_PROMISE frame defines the following flags:

            推送帧定义了以下标记：
            <list style="hanging">
              <x:lt hangText="END_HEADERS (0x4):">
                <t>
                  Bit 3 being set indicates that this frame contains an entire <xref
                  target="HeaderBlock">header block</xref> and is not followed by any
                  <x:ref>CONTINUATION</x:ref> frames.

                  位3 表明帧包含了整个报头区块并且不跟着延续帧。
                </t>
                <t>
                  A PUSH_PROMISE frame without the END_HEADERS flag set MUST be followed by a
                  CONTINUATION frame for the same stream.  A receiver MUST treat the receipt of any
                  other type of frame or a frame on a different stream as a <xref
                  target="ConnectionErrorHandler">connection error</xref> of type
                  <x:ref>PROTOCOL_ERROR</x:ref>.

                  不带有END_HEADERS标记的推送承诺帧在同个流上面后面必须跟着延续帧。接收端接收到任何其他类型或者其他流觞的帧必须作为类型为协议错误的连接错误处理。
                </t>
              </x:lt>
              <x:lt hangText="PAD_LOW (0x10):">
                <t>
                  Bit 5 being set indicates that the Pad Low field is present.

                  位5 表明Pad Low字段是已设置。
                </t>
              </x:lt>
              <x:lt hangText="PAD_HIGH (0x20):">
                <t>
                  Bit 6 being set indicates that the Pad High field is present.  This bit MUST NOT
                  be set unless the PAD_LOW flag is also set.  Endpoints that receive a frame with
                  PAD_HIGH set and PAD_LOW cleared MUST treat this as a <xref
                  target="ConnectionErrorHandler">connection error</xref> of type
                  <x:ref>PROTOCOL_ERROR</x:ref>.

                  位6表明Pad High字段已设置。除非Pad High也设置了否则这个位绝对不能设置。终端接收到有PAD_HIGH 设置但是没有PAD_LOW设置的必须作为类型为协议错误的连接错误处理。
                </t>
              </x:lt>
            </list>
          </t>

          <t>
            PUSH_PROMISE frames MUST be associated with an existing, peer-initiated stream. If the
            stream identifier field specifies the value 0x0, a recipient MUST respond with a <xref
            target="ConnectionErrorHandler">connection error</xref> of type
            <x:ref>PROTOCOL_ERROR</x:ref>.

            推送承诺帧必须与现有的由对等端初始化的流相关联。如果流标识字段为0x0，接收端必须响应一个类型为协议错误的连接错误。
          </t>

          <t>
            Promised streams are not required to be used in order promised.  The PUSH_PROMISE only
            reserves stream identifiers for later use.

            被承诺的流并不需要以被承诺的顺序使用。推送承诺只保留接下来会使用的流的标识符。
          </t>

          <t>
            Recipients of PUSH_PROMISE frames can choose to reject promised streams by returning a
            <x:ref>RST_STREAM</x:ref> referencing the promised stream identifier back to the sender
            of the PUSH_PROMISE.

            推送承诺的接收端可以选择给推送承诺的发送端返回一个与被承诺的流标识符相关的RST_STREAM标记来拒绝接收承诺流。
          </t>

          <t>
            The PUSH_PROMISE frame modifies the connection state as defined in <xref
            target="HeaderBlock" />.

            推送承诺帧对连接章台的修改见HeaderBlock中定义。
          </t>
          <t>
            A PUSH_PROMISE frame modifies the connection state in two ways.  The inclusion of a
            <xref target="HeaderBlock">header block</xref> potentially modifies the compression
            state.  PUSH_PROMISE also reserves a stream for later use, causing the promised stream
            to enter the "reserved" state.  A sender MUST NOT send a PUSH_PROMISE on a stream unless
            that stream is either "open" or "half closed (remote)"; the sender MUST ensure that the
            promised stream is a valid choice for a <xref target="StreamIdentifiers">new stream
            identifier</xref> (that is, the promised stream MUST be in the "idle" state).

            PUSH_PROMISE通过两种方式修改连接状态。这包括一个报头区块可能修改压缩状态。PUSH_PROMISE同样保留流后续使用，导致被推送的流进入到“保留”状态。发送端绝对不能在流上发送PUSH_PROMISE除非流是“打开”或者“半封闭(远程)”状态；发送端绝对要保证被承诺的流对于新的流标示来说是一个有效的选择(就是说，被承诺的流必须进入"空闲"状态)。
          </t>
          <t>
            Since PUSH_PROMISE reserves a stream, ignoring a PUSH_PROMISE frame causes the stream
            state to become indeterminate.  A receiver MUST treat the receipt of a PUSH_PROMISE on a
            stream that is neither "open" nor "half-closed (local)" as a <xref
            target="ConnectionErrorHandler">connection error</xref> of type
            <x:ref>PROTOCOL_ERROR</x:ref>.  Similarly, a receiver MUST treat the receipt of a
            PUSH_PROMISE that promises an <xref target="StreamIdentifiers">illegal stream
            identifier</xref> (that is, an identifier for a stream that is not currently in the
            "idle" state) as a <xref target="ConnectionErrorHandler">connection error</xref> of type
            <x:ref>PROTOCOL_ERROR</x:ref>.

            由于PUSH_PROMISE保留了一个流、忽略一个PUSH_PROMISE 帧都会导致流状态变得不确定。接收端接收到流状态不是“打开”或者“半封闭(本地)”的流的推送帧必须作为类型为协议错误的连接错误处理。相似的，接收端必须对在一个非法标示的流(即流的标识当前不在空闲状态)上建立的推送承诺作为类型为协议错误的连接错误处理。
          </t>

          <t>
            The PUSH_PROMISE frame includes optional padding.  Padding fields and flags are
            identical to those defined for <xref target="DATA">DATA frames</xref>.

            PUSH_PROMISE帧填充是可选的。填充字段及标记同数据帧中定义。
          </t>
        </section>

        <section anchor="PING" title="PING">
          <t>
            The PING frame (type=0x6) is a mechanism for measuring a minimal round-trip time from
            the sender, as well as determining whether an idle connection is still functional.  PING
            frames can be sent from any endpoint.

            PING帧(type=0x6)是一种从发送端测量最小的RTT时间的机制，同样也是一种检测连接是否可用的方法。PING帧可以被任何终端发送。
          </t>
          <figure title="PING Payload Format">
            <artwork type="inline"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 |                      Opaque Data (64)                         |
 |                                                               |
 +---------------------------------------------------------------+
]]></artwork>
          </figure>

          <t>
            In addition to the frame header, PING frames MUST contain 8 octets of data in the
            payload.  A sender can include any value it chooses and use those bytes in any fashion.

            除了帧报头之外，PING帧必须在载体中包含一个8字节长度的数据。发送端可以选择使用任何指并在任何时候使用。
          </t>
          <t>
            Receivers of a PING frame that does not include a ACK flag MUST send a PING frame with
            the ACK flag set in response, with an identical payload.  PING responses SHOULD be given
            higher priority than any other frame.

            接收到不包含ACK标记的PING帧必须发送一个带有ACK比标记的PING帧响应，以及一个相同的载荷。PING响应应当设置比其他帧更高的优先级。
          </t>

          <t>
            The PING frame defines the following flags:

            PING帧定义了以下标记：
            <list style="hanging">
              <t hangText="ACK (0x1):">
                Bit 1 being set indicates that this PING frame is a PING response.  An endpoint MUST
                set this flag in PING responses.  An endpoint MUST NOT respond to PING frames
                containing this flag.

                位1表示PING帧是一个PING响应。终端必须在PING响应中设置此标记。终端绝对不能对包含此标记的PING帧做出响应。
              </t>
            </list>
          </t>
          <t>
            PING frames are not associated with any individual stream. If a PING frame is received
            with a stream identifier field value other than 0x0, the recipient MUST respond with a
            <xref target="ConnectionErrorHandler">connection error</xref> of type
            <x:ref>PROTOCOL_ERROR</x:ref>.

            PING帧捕鱼任何独立的流相关联。如果收到流标示字段不是0x0的PING帧，接收端必须响应一个类型为协议错误的连接错误。
          </t>
          <t>
            Receipt of a PING frame with a length field value other than 8 MUST be treated as a
            <xref target="ConnectionErrorHandler">connection error</xref> of type
            <x:ref>FRAME_SIZE_ERROR</x:ref>.

            接收到字段长度不是8的PING帧必须作为类型为帧大小错误的连接错误处理。
          </t>

        </section>

        <section anchor="GOAWAY" title="GOAWAY">
          <t>
            The GOAWAY frame (type=0x7) informs the remote peer to stop creating streams on this
            connection.  GOAWAY can be sent by either the client or the server.  Once sent, the
            sender will ignore frames sent on new streams for the remainder of the
            connection. Receivers of a GOAWAY frame MUST NOT open additional streams on the
            connection, although a new connection can be established for new streams.  The purpose
            of this frame is to allow an endpoint to gracefully stop accepting new streams (perhaps
            for a reboot or maintenance), while still finishing processing of previously established
            streams.

            超时帧(type=0x7)通知远端对等端不要在这个连接上建立新流。超时帧可以由客户端或者服务端发送。一旦发送，发动端将忽略当前连接上新的流的帧的发送。接收端接收到超时帧后绝对不能在这个连接上打开新的流，但是可以针对新的流创建一个新的连接。这个帧的目的是允许终端优雅的停止接收新的流(也许是重新启动或者维护)，但仍然接续完成之前已经建立的流的处理。
          </t>
          <t>
            There is an inherent race condition between an endpoint starting new streams and the
            remote sending a GOAWAY frame.  To deal with this case, the GOAWAY contains the stream
            identifier of the last stream which was processed on the sending endpoint in this
            connection.  If the receiver of the GOAWAY used streams that are newer than the
            indicated stream identifier, they were not processed by the sender and the receiver may
            treat the streams as though they had never been created at all (hence the receiver may
            want to re-create the streams later on a new connection).

            在终端启动新的流及远端发送超时帧之间有一个内在的竞争条件。为了处理这种情况，超时帧带有当前连接中发送终端处理的最后一个流的标识。如果超时帧的接收端使用了比指定的流更新的流，它们将不会被发送端处理，而且接收端可以认为这些流根本没有被创建(因此接收端可以稍后在新的连接上重新创建这些流)。
          </t>
          <t>
            Endpoints SHOULD always send a GOAWAY frame before closing a connection so that the
            remote can know whether a stream has been partially processed or not.  For example, if
            an HTTP client sends a POST at the same time that a server closes a connection, the
            client cannot know if the server started to process that POST request if the server does
            not send a GOAWAY frame to indicate where it stopped working.  An endpoint might choose
            to close a connection without sending GOAWAY for misbehaving peers.

            终端在关闭一个连接之前总是应当发送一个超时帧，这样远端就能知道一个流是否已被部分处理。例如，如果一个HTTP客户端在服务端关闭连接的时候发送了一个POST请求，如果服务端不发送一个指示它在哪里停止工作的超时帧，客户端将不知道这个POST请求是否被处理。对于不规范的对等端，终端可以选择不发送超时帧的情况下关闭连接。
          </t>

          <t>
            After sending a GOAWAY frame, the sender can discard frames for new streams.  However,
            any frames that alter connection state cannot be completely ignored.  For instance,
            <x:ref>HEADERS</x:ref>, <x:ref>PUSH_PROMISE</x:ref> and <x:ref>CONTINUATION</x:ref>
            frames MUST be minimally processed to ensure a consistent compression state (see <xref
            target="HeaderBlock"/>); similarly DATA frames MUST be counted toward the connection
            flow control window.

            发送超时帧后，发送端可以丢弃新流的帧。然而，任何改变连接状态的帧不能被完全忽略。例如，报头、PUSH_PROMISE和延续帧必须被最低限度的处理以确保一致的压缩状态(见HeaderBlock)；相似的数据帧必须被计入连接流量控制窗口。
          </t>

          <figure title="GOAWAY Payload Format">
            <artwork type="inline"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |X|                  Last-Stream-ID (31)                        |
 +-+-------------------------------------------------------------+
 |                      Error Code (32)                          |
 +---------------------------------------------------------------+
 |                  Additional Debug Data (*)                    |
 +---------------------------------------------------------------+
]]></artwork>
          </figure>
          <t>
            The GOAWAY frame does not define any flags.

            超时帧没有定义任何标记。
          </t>
          <t>
            The GOAWAY frame applies to the connection, not a specific stream.  An endpoint MUST
            treat a <x:ref>GOAWAY</x:ref> frame with a stream identifier other than 0x0 as a <xref
            target="ConnectionErrorHandler">connection error</xref> of type
            <x:ref>PROTOCOL_ERROR</x:ref>.

            超时帧适用于连接而不是特定的流。终端接收到流标识符不是0x0的超时帧必须作为类型为协议错误的连接错误处理。
          </t>
          <t>
            The last stream identifier in the GOAWAY frame contains the highest numbered stream
            identifier for which the sender of the GOAWAY frame has received frames and might
            have taken some action on.  All streams up to and including the identified stream might
            have been processed in some way.  The last stream identifier is set to 0 if no streams
            were processed.

            超时帧中最后一个流的标识包含了接收端接收到并可能已经进行某些处理的流的标识的最大值。所有小于或等于此指定标识符的流都可能通过某种方式被处理。如果没有流被处理，最后流的标识符设置为0。


            <list>
              <t>
                Note: In this case, "processed" means that some data from the stream was passed to
                some higher layer of software that might have taken some action as a result.

                注意：这个案例中，“已处理”表示流中的某些数据已经被传到软件的更高的层并被进行某些处理。
              </t>
            </list>
            If a connection terminates without a GOAWAY frame, this value is effectively the highest
            stream identifier.

            如果连接在没有超时帧的情况下终止，这个值有效的是最大的流标识符。
          </t>
          <t>
            On streams with lower or equal numbered identifiers that were not closed completely
            prior to the connection being closed, re-attempting requests, transactions, or any
            protocol activity is not possible (with the exception of idempotent actions like HTTP
            GET, PUT, or DELETE).  Any protocol activity that uses higher numbered streams can be
            safely retried using a new connection.

            连接关闭前小于或等于标识符上的流没有完全关闭的，重试请求，交换，或者任何协议活动都是不可能的(例如HTTP GET,PUT,或者删除等等幂行为例外)。任何使用更高的流数值的协议行为可以在新的连接上安全地重试。
          </t>
          <t>
            Activity on streams numbered lower or equal to the last stream identifier might still
            complete successfully.  The sender of a GOAWAY frame might gracefully shut down a
            connection by sending a GOAWAY frame, maintaining the connection in an open state until
            all in-progress streams complete.

            小于或等于最后流标识符上的流的活动可能仍然能成功完成。超时帧的发送端可能通过发送超时帧优雅地关闭了连接，保持连接在打开状态直到正在处理的流全部处理完成。
          </t>
          <t>
            The last stream ID MUST be 0 if no streams were acted upon.

            如果没有流起作用，最后流的ID必须是0。
          </t>
          <t>
            If an endpoint maintains the connection and continues to exchange frames, ignored frames
            MUST be counted toward <xref target="FlowControl">flow control limits</xref> or update
            <xref target="HeaderBlock">header compression state</xref>. Otherwise, flow control or
            header compression state can become unsynchronized.

            如果终端保持了连接并且继续交换帧，忽略的帧必须被计入流量控制限制或者更新报头压缩状态。否则，流量控制或者报头压缩状态可能会不同步。
          </t>
          <t>
            The GOAWAY frame also contains a 32-bit <xref target="ErrorCodes">error code</xref> that
            contains the reason for closing the connection.

            超时帧同样包含一个32位的错误码，里面包含了关闭连接的原因。
          </t>
          <t>
            Endpoints MAY append opaque data to the payload of any GOAWAY frame.  Additional debug
            data is intended for diagnostic purposes only and carries no semantic value.  Debug
            information could contain security- or privacy-sensitive data.  Logged or otherwise
            persistently stored debug data MUST have adequate safeguards to prevent unauthorized
            access.

            终端可以在超时帧载体上附加不透明数据。额外的调试数据仅用来诊断没有语义值。调试信息可以包含安全或者隐私敏感的数据。登录或者其他持续存储的数据必须有足够的保障措施，以防止未经授权的访问。
          </t>
        </section>

        <section anchor="WINDOW_UPDATE" title="WINDOW_UPDATE">
          <t>
            The WINDOW_UPDATE frame (type=0x8) is used to implement flow control; see <xref
            target="FlowControl"/> for an overview.

            WINDOW_UPDATE帧(type=0x8)用来实现流量控制；概述见<xref target="FlowControl"/> 
          </t>
          <t>
            Flow control operates at two levels: on each individual stream and on the entire
            connection.

            流量控制在两种层面上操作：每个单独的流或者整个连接。
          </t>
          <t>
            Both types of flow control are hop by hop; that is, only between the two endpoints.
            Intermediaries do not forward WINDOW_UPDATE frames between dependent connections.
            However, throttling of data transfer by any receiver can indirectly cause the
            propagation of flow control information toward the original sender.

            所有类型的流量控制都是逐跳的；就是说，只在两个终端之间作用。中介者不在依赖的连接上转接WINDOW_UPDATE帧。接收端对数据的显示可以直接导致流量控制信息的传播转到原始发送端。
          </t>
          <t>
            Flow control only applies to frames that are identified as being subject to flow
            control.  Of the frame types defined in this document, this includes only
            <x:ref>DATA</x:ref> frame.  Frames that are exempt from flow control MUST be accepted
            and processed, unless the receiver is unable to assign resources to handling the frame.
            A receiver MAY respond with a <xref target="StreamErrorHandler">stream error</xref> or
            <xref target="ConnectionErrorHandler">connection error</xref> of type
            <x:ref>FLOW_CONTROL_ERROR</x:ref> if it is unable accept a frame.

            流量控制只适用于确定受流量控制影响的帧。文档中定义的帧类型中，只包括数据帧。不受流量控制的帧必须被接收和处理，除非接收端无法为帧分配资源。接收端如果无法接收帧，可以响应一个流错误或者类型为流量控制错误的连接错误。
          </t>
          <figure title="WINDOW_UPDATE Payload Format">
            <artwork type="inline"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |X|              Window Size Increment (31)                     |
 +-+-------------------------------------------------------------+
]]></artwork>
          </figure>
          <t>
            The payload of a WINDOW_UPDATE frame is one reserved bit, plus an unsigned 31-bit
            integer indicating the number of bytes that the sender can transmit in addition to the
            existing flow control window.  The legal range for the increment to the flow control
            window is 1 to 2<x:sup>31</x:sup> - 1 (0x7fffffff) bytes.

            WINDOW_UPDATE帧的载体是一个保留字节，加上一个无符号32为整数表明发送端除了现有的流量控制窗口可以发送的字节数。留空控制窗口有效的增量范围是1到2的31次方-1(0x7fffffff)  字节
          </t>
          <t>
            The WINDOW_UPDATE frame does not define any flags.

            WINDOW_UPDATE帧没有定义任何标记。
          </t>
          <t>
            The WINDOW_UPDATE frame can be specific to a stream or to the entire connection.  In the
            former case, the frame's stream identifier indicates the affected stream; in the latter,
            the value "0" indicates that the entire connection is the subject of the frame.

            WINDOW_UPDATE可以专指某个流或者整个连接。在前者的情况下，帧的流标识符指的是被影响的流；在后者情况下，值"0"表示整个连接都受这个帧的影响。
          </t>
          <t>
            WINDOW_UPDATE can be sent by a peer that has sent a frame bearing the END_STREAM flag.
            This means that a receiver could receive a WINDOW_UPDATE frame on a "half closed
            (remote)" or "closed" stream.  A receiver MUST NOT treat this as an error, see <xref
            target="StreamStates"/>.

            WINDOW_UPDATE可以由一个已经发送带有END_STREAM标记的帧的对等端来发送。这意味着接收端可以在“半封闭(远程)”或者“关闭”的流上接收WINDOW_UPDATE帧。接收端绝对不能作为错误处理，见StreamStates
          </t>
          <t>
            A receiver that receives a flow controlled frame MUST always account for its
            contribution against the connection flow control window, unless the receiver treats this
            as a <xref target="ConnectionErrorHandler">connection error</xref>.  This is necessary
            even if the frame is in error.  Since the sender counts the frame toward the flow
            control window, if the receiver does not, the flow control window at sender and receiver
            can become different.

            接收端收到受流量控制的帧必须总是计算流量对整个连接流量控制的影响量，除非接收端将这作为连接错误处理。即使帧出错这也是必须的。因为发送端将这个帧计入了流量控制窗口，如果接收端没有这样做，发送端和接收端的流量控制会不相同。
          </t>

          <section title="The Flow Control Window">
            <t>
              Flow control in HTTP/2 is implemented using a window kept by each sender on every
              stream. The flow control window is a simple integer value that indicates how many
              bytes of data the sender is permitted to transmit; as such, its size is a measure of
              the buffering capability of the receiver.

              HTTP/2中流量控制是通过每个发送端在每个流上携带一个窗口来实现的。流量控制窗口是一个简单的整数值，指示发送端被允许传输的字节数；因此，它的大小是接收端的缓存能力的衡量。
            </t>
            <t>
              Two flow control windows are applicable: the stream flow control window and the
              connection flow control window.  The sender MUST NOT send a flow controlled frame with
              a length that exceeds the space available in either of the flow control windows
              advertised by the receiver.  Frames with zero length with the END_STREAM flag set (for
              example, an empty data frame) MAY be sent if there is no available space in either
              flow control window.

              流量控制窗口对流和连接的流量控制窗口都适用。发送端绝对不能发送超出接收端广播的流量控制窗口大小的可用空间长度的受流量控制影响的帧。在各个流量控制窗口中没有可用空间时，可以发送带有END_STREAM标记的长度为0的帧(例如，空数据帧)。
            </t>
            <t>
              For flow control calculations, the 8 byte frame header is not counted.

              流量控制计算中，8字节的帧报头不被计入。
            </t>
            <t>
              After sending a flow controlled frame, the sender reduces the space available in both
              windows by the length of the transmitted frame.

              在发送一个流量控制帧后，发送端在各个窗口中可用空间中减去发送的帧长度。
            </t>
            <t>
              The receiver of a frame sends a WINDOW_UPDATE frame as it consumes data and frees up
              space in flow control windows.  Separate WINDOW_UPDATE frames are sent for the stream
              and connection level flow control windows.

              接收端发送一个WINDOW_UPDATE帧因为它消耗并释放了流量控制窗口的空间。单独的WINDOW_UPDATE帧用于流及连接层面的流量控制窗口中。
            </t>
            <t>
              A sender that receives a WINDOW_UPDATE frame updates the corresponding window by the
              amount specified in the frame.

              发送端收到WINDOW_UPDATE后按帧中指定的大小更新到正确的窗口。
            </t>
            <t>
              A sender MUST NOT allow a flow control window to exceed 2<x:sup>31</x:sup> - 1 bytes.
              If a sender receives a WINDOW_UPDATE that causes a flow control window to exceed this
              maximum it MUST terminate either the stream or the connection, as appropriate.  For
              streams, the sender sends a <x:ref>RST_STREAM</x:ref> with the error code of
              <x:ref>FLOW_CONTROL_ERROR</x:ref> code; for the connection, a <x:ref>GOAWAY</x:ref>
              frame with a <x:ref>FLOW_CONTROL_ERROR</x:ref> code.

              发送端绝对不允许流量控制窗口超过2的31次方-1字节。如果发送端接收到WINDOW_UPDATE使得流量控制窗口超过这个最大值，它必须适当地终止这个流或者这个连接。对于流，发送端发送一个带有流量控制错误的错误码的ST_STREAM帧；对于连接，发送一个带有流量控制错误码的超时帧。
            </t>
            <t>
              Flow controlled frames from the sender and WINDOW_UPDATE frames from the receiver are
              completely asynchronous with respect to each other. This property allows a receiver to
              aggressively update the window size kept by the sender to prevent streams from
              stalling.

              发送端发送的受流量控制的帧以及接收端收到的WINDOW_UPDATE帧是完全异步的并且相互认可对方的值。这种属性让接收端积极的更新发送端携带的窗口大小来防止流停转。
            </t>
          </section>

          <section anchor="InitialWindowSize" title="Initial Flow Control Window Size">
            <t>
              When an HTTP/2 connection is first established, new streams are created with an
              initial flow control window size of 65,535 bytes. The connection flow control window
              is 65,535 bytes.  Both endpoints can adjust the initial window size for new streams by
              including a value for <x:ref>SETTINGS_INITIAL_WINDOW_SIZE</x:ref> in the
              <x:ref>SETTINGS</x:ref> frame that forms part of the connection preface.  The
              connection flow control window initial size cannot be changed.

              HTTP/2连接初次建立时，新的流创建的初始化流量控制大小是65,535字节。连接的流量控制大小是65,535字节。两个终端都能通过在组成连接序言的设置帧中携带一个SETTINGS_INITIAL_WINDOW_SIZE设置调整新流的初始化窗口大小。连接的流量控制初始化大小不能被修改。
            </t>
            <t>
              Prior to receiving a <x:ref>SETTINGS</x:ref> frame that sets a value for
              <x:ref>SETTINGS_INITIAL_WINDOW_SIZE</x:ref>, an endpoint can only use the default
              initial window size when sending flow controlled frames.  Similarly, the connection
              flow control window is set to the default initial window size until a WINDOW_UPDATE
              frame is received.

              在收到设置帧指定SETTINGS_INITIAL_WINDOW_SIZE前，终端只能只有流量控制的默认窗口值。类似的，连接的流量控制窗口初始化时也是默认值知道收到WINDOW_UPDATE帧。
            </t>
            <t>
              A <x:ref>SETTINGS</x:ref> frame can alter the initial flow control window size for all
              current streams. When the value of <x:ref>SETTINGS_INITIAL_WINDOW_SIZE</x:ref>
              changes, a receiver MUST adjust the size of all stream flow control windows that it
              maintains by the difference between the new value and the old value.  A
              <x:ref>SETTINGS</x:ref> frame cannot alter the connection flow control window.

              设置帧可以针对所有当前的流修改流量控制初始化大小。当SETTINGS_INITIAL_WINDOW_SIZE值改变时，接收端必须将根据新旧值调整其保留的所有流的窗口大小设置帧不能修改连接的流量控制窗口。
            </t>
            <t>
              An endpoint MUST treat a change to <x:ref>SETTINGS_INITIAL_WINDOW_SIZE</x:ref> that
              causes any flow control window to exceed the maximum size as a <xref
              target="ConnectionErrorHandler">connection error</xref> of type
              <x:ref>FLOW_CONTROL_ERROR</x:ref>.

              终端必须将SETTINGS_INITIAL_WINDOW_SIZE的修改导致流量控制窗口超过最大值的情况作为类型为流量控制错误的连接错误处理。
            </t>
            <t>
              A change to <x:ref>SETTINGS_INITIAL_WINDOW_SIZE</x:ref> can cause the available space
              in a flow control window to become negative.  A sender MUST track the negative flow
              control window, and MUST NOT send new flow controlled frames until it receives
              WINDOW_UPDATE frames that cause the flow control window to become positive.

              SETTINGS_INITIAL_WINDOW_SIZE的改变可能导致流量控制窗口中的可用空间变成负数。发送端必须记录负数的流量控制窗口，并且在收到WINDOW_UPDATE帧使流量控制窗口变成正数前绝对不能发送新的受流量控制的帧。
            </t>
            <t>
              For example, if the client sends 60KB immediately on connection establishment, and the
              server sets the initial window size to be 16KB, the client will recalculate the
              available flow control window to be -44KB on receipt of the <x:ref>SETTINGS</x:ref>
              frame.  The client retains a negative flow control window until WINDOW_UPDATE frames
              restore the window to being positive, after which the client can resume sending.

              例如，如果终端在当前建立的连接上立即发送了60KB,然后服务器设置初始化窗口大小是16KB,那么客户端在接收到设置帧后计算的流量控制窗口的可用空间就是-44KB。客户端在收到WINDOW_UPDATE帧使得窗口重新变为证书钱一直保留负数的流量控制窗口，在这之后客户端可以重新发送数据。
            </t>
          </section>

          <section title="Reducing the Stream Window Size">
            <t>
              A receiver that wishes to use a smaller flow control window than the current size can
              send a new <x:ref>SETTINGS</x:ref> frame.  However, the receiver MUST be prepared to
              receive data that exceeds this window size, since the sender might send data that
              exceeds the lower limit prior to processing the <x:ref>SETTINGS</x:ref> frame.

              接收端希望使用比当前大小更小的流量控制窗口可以发送一个新的设置帧。然而，接收端必须准备好接收超过窗口大小的数据，因为发送端在处理设置帧之前发送了超过更低限制大小的数据。
            </t>
            <t>
               After sending a SETTINGS frame that reduces the initial flow control window size, a
               receiver has two options for handling streams that exceed flow control limits:

               在发送见效初始化流量控制窗口大小的设置后，接收端有两种选择处理流超过流量限制的情况：
              <list style="numbers">
                <t>
                  The receiver can immediately send <x:ref>RST_STREAM</x:ref> with
                  <x:ref>FLOW_CONTROL_ERROR</x:ref> error code for the affected streams.

                  接收端可以针对受影响的流立即发送带有流量控制错误错误码的RST_STREAM帧。
                </t>
                <t>
                  The receiver can accept the streams and tolerate the resulting head of line
                  blocking, sending WINDOW_UPDATE frames as it consumes data.

                  接收端如果在消耗数据可以接受流并且忍受报头阻塞的结果，并发送WINDOW_UPDATE帧。
                </t>
              </list>
            </t>
          </section>
        </section>

        <section anchor="CONTINUATION" title="CONTINUATION">
          <t>
            The CONTINUATION frame (type=0x9) is used to continue a sequence of <xref
            target="HeaderBlock">header block fragments</xref>.  Any number of CONTINUATION frames
            can be sent on an existing stream, as long as the preceding frame on the same stream is
            one of <x:ref>HEADERS</x:ref>, <x:ref>PUSH_PROMISE</x:ref> or CONTINUATION without the
            END_HEADERS flag set.

            延续帧(type=0x9)用来延续一个报头区块碎片序列。在现有流上可以发送任意数量的延续帧，只要相同流上的前一阵是报头帧、推送承诺帧或者不带有END_HEADERS标记的延续帧。
          </t>

          <figure title="CONTINUATION Frame Payload">
            <artwork type="inline"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | [Pad High(8)] | [Pad Low (8)] |  Header Block Fragment (*)    .
 +---------------+---------------+-------------------------------+
 |                   Header Block Fragment (*)                 ...
 +---------------------------------------------------------------+
 |                           Padding (*)                       ...
 +---------------------------------------------------------------+
]]></artwork>
          </figure>
          <t>
            The CONTINUATION frame payload has the following fields:

            延续帧载体有以下字段：
            <list style="hanging">
              <t hangText="Pad High:">
                填充大小高位。这个字段只有在设置PAD_HIGH标记的情况下才呈现。
                Padding size high bits.  This field is only present if the PAD_HIGH flag is set.
              </t>
              <t hangText="Pad Low:">
                Padding size low bits.  This field is only present if the PAD_LOW flag is set.

                填充大小低位。这个字段只有在设置PAD_LOW标记的情况下才呈现。
              </t>
              <t hangText="Header Block Fragment:">
                A <xref target="HeaderBlock">header block fragment</xref>.
                报头区块碎片。
              </t>
              <t hangText="Padding:">
                Padding octets.

                填充字节。
              </t>
            </list>
          </t>

          <t>
            The CONTINUATION frame defines the following flags:

            延续帧定义了以下状态：
            <list style="hanging">
              <x:lt hangText="END_HEADERS (0x4):">
                <t>
                  Bit 3 being set indicates that this frame ends a <xref
                  target="HeaderBlock">header block</xref>.

                  位3表示是报头区块的终止。
                </t>
                <t>
                  If the END_HEADERS bit is not set, this frame MUST be followed by another
                  CONTINUATION frame.  A receiver MUST treat the receipt of any other type of frame
                  or a frame on a different stream as a <xref
                  target="ConnectionErrorHandler">connection error</xref> of type
                  <x:ref>PROTOCOL_ERROR</x:ref>.

                  如果没有设置END_HEADERS位，那么帧后面必须跟着其他延续帧。接收到收到任何其他类型或者其他流觞的帧必须作为类型为协议错误的连接错误处理。
                </t>
              </x:lt>
              <x:lt hangText="PAD_LOW (0x10):">
                <t>
                  Bit 5 being set indicates that the Pad Low field is present.

                  位5表示Pad Low字段已设置。
                </t>
              </x:lt>
              <x:lt hangText="PAD_HIGH (0x20):">
                <t>
                  Bit 6 being set indicates that the Pad High field is present.  This bit MUST NOT
                  be set unless the PAD_LOW flag is also set.  Endpoints that receive a frame with
                  PAD_HIGH set and PAD_LOW cleared MUST treat this as a <xref
                  target="ConnectionErrorHandler">connection error</xref> of type
                  <x:ref>PROTOCOL_ERROR</x:ref>.

                  位6表示Pad High字段已设置。这个位绝对不能在没有设置PAD_LOW标记的情况下设置。终端接收到带有PAD_HIGH设置但是不带PAD_LOW设置的必须作为类型为协议错误的连接错误处理。
                </t>
              </x:lt>
            </list>
          </t>

          <t>
            The payload of a CONTINUATION frame contains a <xref target="HeaderBlock">header block
            fragment</xref>.

            延续帧的载体包含一个报头区块碎片。
          </t>

          <t>
            The CONTINUATION frame changes the connection state as defined in <xref
            target="HeaderBlock" />.

            延续帧改变连接状态如HeaderBlock中定义。
          </t>

          <t>
            CONTINUATION frames MUST be associated with a stream. If a CONTINUATION frame is
            received whose stream identifier field is 0x0, the recipient MUST respond with a <xref
            target="ConnectionErrorHandler">connection error</xref> of type PROTOCOL_ERROR.

            延续帧必须与流相关联。如果延续帧的相关流表示字段是0x0，终端必须响应一个类型为协议错误的连接错误。
          </t>

          <t>
            A CONTINUATION frame MUST be preceded by a <x:ref>HEADERS</x:ref>,
            <x:ref>PUSH_PROMISE</x:ref> or CONTINUATION frame without the END_HEADERS flag set.
            A recipient that observes violation of this rule MUST respond with a
            <xref target="ConnectionErrorHandler"> connection error</xref> of type
            <x:ref>PROTOCOL_ERROR</x:ref>.

            延续帧必须跟在不带有END_HEADERS设置的报头帧、推送承诺帧或延续帧后面。终端接收到不符合此规则的必须响应一个类型为协议错误的连接错误。
          </t>

          <t>
            The CONTINUATION frame includes optional padding.  Padding fields and flags are
            identical to those defined for <xref target="DATA">DATA frames</xref>.

            延续帧的填充是可选的。填充字段额标记同数据帧中定义。
          </t>
        </section>
    </section>

    <section anchor="ErrorCodes" title="Error Codes">
      <t>
        Error codes are 32-bit fields that are used in <x:ref>RST_STREAM</x:ref> and
        <x:ref>GOAWAY</x:ref> frames to convey the reasons for the stream or connection error.

        错误码是32为字段，用在RST_STREAM和超时帧中用来标识流或者链接错误的原因。
      </t>

      <t>
        Error codes share a common code space.  Some error codes only apply to specific conditions
        and have no defined semantics in certain frame types.

        错误码共享一个功能的代码空间。一些错误代码只适用于特定的条件，在某些帧类型没有定义的语义。
      </t>

      <t>
        The following error codes are defined:

        定义了以下错误码：
        <list style="hanging">
          <t hangText="NO_ERROR (0):" anchor="NO_ERROR">
            The associated condition is not as a result of an error.  For example, a
            <x:ref>GOAWAY</x:ref> might include this code to indicate graceful shutdown of a
            connection.

            相关的条件并不是错误的结果。例如超时帧可以携带此错误码指示连接的平滑关闭。
          </t>
          <t hangText="PROTOCOL_ERROR (1):" anchor="PROTOCOL_ERROR">
            The endpoint detected an unspecific protocol error.  This error is for use when a more
            specific error code is not available.

            终端检测到一个不确定的协议错误。这个错误用在一个更具体的错误码不可用的时候。
          </t>
          <t hangText="INTERNAL_ERROR (2):" anchor="INTERNAL_ERROR">
            The endpoint encountered an unexpected internal error.

            终端遇到意外的内部错误。
          </t>
          <t hangText="FLOW_CONTROL_ERROR (3):" anchor="FLOW_CONTROL_ERROR">
            The endpoint detected that its peer violated the flow control protocol.

            终端检测到对等端违反了流量控制协议。
          </t>
          <t hangText="SETTINGS_TIMEOUT (4):" anchor="SETTINGS_TIMEOUT">
            The endpoint sent a SETTINGS frame, but did not receive a response in a
            timely manner.  See <xref target="SettingsSync">Settings Synchronization</xref>.

            终端发送了设置帧，但是没有及时收到响应。见Settings Synchronization。
          </t>
          <t hangText="STREAM_CLOSED (5):" anchor="STREAM_CLOSED">
            The endpoint received a frame after a stream was half closed.

            终端在流半封闭的时候收到帧。
          </t>
          <t hangText="FRAME_SIZE_ERROR (6):" anchor="FRAME_SIZE_ERROR">
            The endpoint received a frame that was larger than the maximum size that it
            supports.

            终端收到大小超过最大尺寸的帧。
          </t>
          <t hangText="REFUSED_STREAM (7):" anchor="REFUSED_STREAM">
            The endpoint refuses the stream prior to performing any application processing, see
            <xref target="Reliability"/> for details.

            终端拒绝流执行任何应用处理，详见Reliability
          </t>
          <t hangText="CANCEL (8):" anchor="CANCEL">
            Used by the endpoint to indicate that the stream is no longer needed.

            终端使用这个标示某个流不再需要。
          </t>
          <t hangText="COMPRESSION_ERROR (9):" anchor="COMPRESSION_ERROR">
            The endpoint is unable to maintain the compression context for the connection.

            终端无法保持连接的压缩上下文。
          </t>
          <t hangText="CONNECT_ERROR (10):" anchor="CONNECT_ERROR">
            The connection established in response to a <xref target="CONNECT">CONNECT
            request</xref> was reset or abnormally closed.

            响应某个连接请求建立的连接被服为异常关闭。
          </t>
          <t hangText="ENHANCE_YOUR_CALM (11):" anchor="ENHANCE_YOUR_CALM">
            The endpoint detected that its peer is exhibiting a behavior over a given amount of time
            that has caused it to refuse to process further frames.

            终端检测出对等端在给定时间内表现出行为导致其拒绝处理更多帧。
          </t>
          <t hangText="INADEQUATE_SECURITY (12):" anchor="INADEQUATE_SECURITY">
            The underlying transport has properties that do not meet the minimum requirements
            imposed by this document (see <xref target="TLSUsage"/>) or the endpoint.

            基础传输包含属性不满足文档或者终端申明的最小要求。
          </t>
        </list>
      </t>
    </section>

    <section anchor="HTTPLayer" title="HTTP Message Exchanges">
      <t>
        HTTP/2 is intended to be as compatible as possible with current uses of HTTP. This means
        that, from the perspective of the server and client applications, the features of the
        protocol are unchanged. To achieve this, all request and response semantics are preserved,
        although the syntax of conveying those semantics has changed.

        HTTP/2的目的是尽可能的就按容目前使用的HTTP。这意味着，从服务端或者客户端应用的角度来看，该协议的特定是不变的。为了实现这点，所有响应与请求的语义都将保留，尽管包含这些语义的语法已经改变。
      </t>
      <t>
        Thus, the specification and requirements of HTTP/1.1 Semantics and Content <xref
        target="HTTP-p2"/>, Conditional Requests <xref target="HTTP-p4"/>, Range Requests <xref
        target="HTTP-p5"/>, Caching <xref target="HTTP-p6"/> and Authentication <xref
        target="HTTP-p7"/> are applicable to HTTP/2. Selected portions of HTTP/1.1 Message Syntax
        and Routing <xref target="HTTP-p1"/>, such as the HTTP and HTTPS URI schemes, are also
        applicable in HTTP/2, but the expression of those semantics for this protocol are defined
        in the sections below.

        因此，HTTP/1.1语义与内容、有条件的请求、范围请求、缓存与验证定义的规范与要求同样适用于HTTP/2.HTTP/1.1消息语法与路由选定的内容，例如HTTP与HTTPS URI方案，也同样适用于HTTP/2，但是表达这些协议的语义在下面的章节定义。
      </t>

      <section anchor="HttpSequence" title="HTTP Request/Response Exchange">
        <t>
          A client sends an HTTP request on a new stream, using a previously unused <xref
          target="StreamIdentifiers">stream identifier</xref>.  A server sends an HTTP response on
          the same stream as the request.

          客户端在一个新的流上发起HTTP请求，使用以前未使用的流标示。服务端在同个流上发起HTTP响应。
        </t>
        <t>
          An HTTP message (request or response) consists of:
          一个HTTP消息(请求或相应)包含：
          <list style="numbers">
            <t>
              one <x:ref>HEADERS</x:ref> frame, followed by zero or more
              <x:ref>CONTINUATION</x:ref> frames (containing the message headers; see <xref
              target="HTTP-p1" x:fmt="," x:rel="#header.fields"/>), and

              一个报头帧，后面跟着0个或多个延续帧(包含消息报头;见xx),以及
            </t>
            <t>
              zero or more <x:ref>DATA</x:ref> frames (containing the message payload; see <xref
              target="HTTP-p1" x:fmt="," x:rel="#message.body"/>), and

              0个或多个数据帧(包含消息载荷，见),以及
            </t>
            <t>
              optionally, one <x:ref>HEADERS</x:ref> frame, followed by zero or more
              <x:ref>CONTINUATION</x:ref> frames (containing the trailer-part, if present; see
              <xref target="HTTP-p1" x:fmt="," x:rel="#chunked.trailer.part"/>).

              一个可选的吧哦哦图真，后面跟着0个或多个延续帧(如果存在，包含尾部部分，见xxx)

            </t>
          </list>
          The last frame in the sequence bears an END_STREAM flag, though a <x:ref>HEADERS</x:ref>
          frame bearing the END_STREAM flag can be followed by <x:ref>CONTINUATION</x:ref> frames
          that carry any remaining portions of the header block.

          序列中的最后一帧具有END_STREAM标记，但是包含END_STREAM标记的报头帧后面可以跟着包含任意报头部分的延续帧。
        </t>
        <t>
          Other frames (from any stream) MUST NOT occur between either <x:ref>HEADERS</x:ref> frame
          and the following <x:ref>CONTINUATION</x:ref> frames (if present), nor between
          <x:ref>CONTINUATION</x:ref> frames.

          其他帧(来自任何流的)绝对不能出现在任意报头帧和延续帧(如果存在)之间,也不能出现在延续帧中间。
        </t>
        <t>
          Otherwise, frames MAY be interspersed on the stream between these frames, but those
          frames do not carry HTTP semantics. In particular, <x:ref>HEADERS</x:ref> frames (and any
          <x:ref>CONTINUATION</x:ref> frames that follow) other than the first and optional last
          frames in this sequence do not carry HTTP semantics.

          否则，流上的这些帧可能被打散，但是那些帧并不包含HTTP语义。特别是，报头帧(及任何跟在后面的延续帧)序列中第一帧及可选的最后一帧以外的并不包含HTTP语义。
        </t>

        <t>
          Trailing header fields are carried in a header block that also terminates the stream.
          That is, a sequence starting with a <x:ref>HEADERS</x:ref> frame, followed by zero or more
          <x:ref>CONTINUATION</x:ref> frames, where the <x:ref>HEADERS</x:ref> frame bears an
          END_STREAM flag.  Header blocks after the first that do not terminate the stream are not
          part of an HTTP request or response.

          报头区块中的报头尾部字段同样终止流。就是说，一个报头帧开始的序列，后面跟着0个或者多个带有END_STREAM标记的延续帧。第一个不终止流后面的报头区块不是当前HTTP请求与响应的一部分。
        </t>

        <t>
          An HTTP request/response exchange fully consumes a single stream.  A request starts with
          the <x:ref>HEADERS</x:ref> frame that puts the stream into an "open" state and ends with a
          frame bearing END_STREAM, which causes the stream to become "half closed" for the client.
          A response starts with a <x:ref>HEADERS</x:ref> frame and ends with a frame bearing
          END_STREAM, optionally followed by <x:ref>CONTINUATION</x:ref> frames, which places the
          stream in the "closed" state.

          一个HTTP 请求/响应的数据交换在同一个流上进行。一个请求由是流进入打开状态的报头帧开始，并由一个携带使流对客户端进入半封闭的END_STREAM标记的帧结束，另外可选的后面可以跟着延续帧，使流进入关闭状态。
        </t>

        <section anchor="informational-responses" title="Informational Responses">
          <t>
            The 1xx series of HTTP response status codes (<xref target="HTTP-p2" x:fmt=","
            x:rel="#status.1xx"/>) are not supported in HTTP/2.

            1xx系列的HTTP响应状态码在HTTP/2中不支持。
          </t>
          <t>
            The most common use case for 1xx is using an Expect header field with a <spanx
            style="verb">100-continue</spanx> token (colloquially, "Expect/continue") to indicate
            that the client expects a 100 (Continue) non-final response status code, receipt of
            which indicates that the client should continue sending the request body if it has not
            already done so.

            1xx最常见的用法是使用一个带有100-继续临牌(通俗的，“期待/继续”)的期望报头字段来表明客户端期望一个100(继续)非最终响应的状态码，收到这个表示客户端如果没有发送完应当继续发送请求正文。
          </t>
          <t>
            Typically, Expect/continue is used by clients wishing to avoid sending a large amount
            of data in a request body, only to have the request rejected by the origin server (thus
            leaving the connection potentially unusable).

            通常来说，期望/继续帧被客户端用来希望避免在请求正文中发送大量数据，只用来让请求被源服务器拒绝(因此让连接可能不可用).
          </t>
          <t>
            HTTP/2 does not enable the Expect/continue mechanism; if the server sends a final status
            code to reject the request, it can do so without making the underlying connection
            unusable.

            HTTP/2不支持期望/继续机制；如果服务端发送一个最终状态码来拒绝请求，它可以在不需要使当前连接不可用的情况下做到这个。
          </t>
          <t>
            Note that this means HTTP/2 clients sending requests with bodies may waste at least one
            round trip of sent data when the request is rejected. This can be mitigated by
            restricting the amount of data sent for the first round trip by bandwidth-constrained
            clients, in anticipation of a final status code.

            需要注意的是这意味着，HTTP/2客户端发送带有请求正文的请求在连接被拒绝时可能浪费至少一个发送数据的RTT时间。这可以通过限制带宽受限的客户端第一个RTT的数据大小来缓和，通过预期的最终状态码实现。
          </t>
          <t>
            Other defined 1xx status codes are not applicable to HTTP/2. For example, the semantics
            of 101 (Switching Protocols) aren't suitable to a multiplexed protocol. Likewise, 102
            (Processing) is no longer necessary, because HTTP/2 has a separate means of keeping the
            connection alive.

            其他定义的1xx状态码也不适用于HTTP/2。例如，101(转换协议)的语义不适用于多路复用协议。同样的，102(处理中)也不在需要，因为HTTP/2有单独的保持连接可用的方式。
          </t>
          <t>
            This difference between protocol versions necessitates special handling by
            intermediaries that translate between them:

            这些不同协议版本之间的差异需要被中介端在转换时特殊处理：
            <list style="symbols">
              <t>
                An intermediary that gateways HTTP/1.1 to HTTP/2 MUST generate a 100 (Continue)
                response if a received request includes and Expect header field with a <spanx
                style="verb">100-continue</spanx> token (<xref target="HTTP-p2" x:fmt=","
                x:rel="#header.expect"/>), unless it can immediately generate a final status code.
                It MUST NOT forward the <spanx style="verb">100-continue</spanx> expectation in the
                request header fields.

                转换HTTP/1.1到HTTP/2的中介网关如果收到请求包含带有100-继续令牌的期望报头字段，必须生成一个100(继续)响应，除非它能马上生成一个最终状态码。绝对不能转发请求报头中的100-继续期望字段。
              </t>
              <t>
                An intermediary that gateways HTTP/2 to HTTP/1.1 MAY add an Expect header field with
                a <spanx style="verb">100-continue</spanx> expectation when forwarding a request
                that has a body; see <xref target="HTTP-p2" x:fmt="," x:rel="#header.expect"/> for
                specific requirements.

                转换HTTP/2到HTTP/1.1的中介网关在转发一个带有正文的请求时可以添加一个带有100-继续的期望报头字段。特定要求见xxx.
              </t>
              <t>
                An intermediary that gateways HTTP/2 to HTTP/1.1 MUST discard all other 1xx
                informational responses.

                转换HTTP/2到HTTP/1.1的中介网关必须丢弃所有1xx以外的响应信息。
              </t>
            </list>
          </t>

        </section>

        <section title="Examples">
          <t>
            This section shows HTTP/1.1 requests and responses, with illustrations of equivalent
            HTTP/2 requests and responses.

            这个部分介绍了HTTP/1.1的请求与响应，并带有HTTP/2请求与响应的插图。
          </t>
          <t>
            An HTTP GET request includes request header fields and no body and is therefore
            transmitted as a single <x:ref>HEADERS</x:ref> frame, followed by zero or more
            <x:ref>CONTINUATION</x:ref> frames containing the serialized block of request header
            fields.  The last <x:ref>HEADERS</x:ref> frame in the sequence has both the END_HEADERS
            and END_STREAM flags set:

            一个带有请求报头字段但没有正文的HTTP GET请求将被转换成一个单独的报头帧，后面跟着0个或者多个包含序列化的报头字段区块的延续帧。序列中最后一个报头帧将有END_HEADERS和END_STREAM标记。

          </t>

          <figure>
            <artwork type="inline"><![CDATA[
  GET /resource HTTP/1.1           HEADERS
  Host: example.org          ==>     + END_STREAM
  Accept: image/jpeg                 + END_HEADERS
                                       :method = GET
                                       :scheme = https
                                       :path = /resource
                                       host = example.org
                                       accept = image/jpeg
]]></artwork>
          </figure>

          <t>
            Similarly, a response that includes only response header fields is transmitted as a
            <x:ref>HEADERS</x:ref> frame (again, followed by zero or more
            <x:ref>CONTINUATION</x:ref> frames) containing the serialized block of response header
            fields. The last <x:ref>HEADERS</x:ref> frame in the sequence has both the END_HEADERS
            and END_STREAM flag set:

            相似的，只带有报头字段的响应将被转换成一个报头帧(同样的，后面跟着0个护着多个延续帧)，且包含序列化的响应报头字段区块。序列中最后一个报头帧将有END_HEADERS和END_STREAM标记。
          </t>

          <figure>
            <artwork type="inline"><![CDATA[
  HTTP/1.1 304 Not Modified        HEADERS
  ETag: "xyzzy"              ==>     + END_STREAM
  Expires: Thu, 23 Jan ...           + END_HEADERS
                                       :status = 304
                                       etag: "xyzzy"
                                       expires: Thu, 23 Jan ...
]]></artwork>
          </figure>

          <t>
            An HTTP POST request that includes request header fields and payload data is
            transmitted as one <x:ref>HEADERS</x:ref> frame, followed by zero or more
            <x:ref>CONTINUATION</x:ref> frames containing the request header fields, followed by
            one or more <x:ref>DATA</x:ref> frames, with the last <x:ref>CONTINUATION</x:ref> (or
            <x:ref>HEADERS</x:ref>) frame having the END_HEADERS flag set and the final
            <x:ref>DATA</x:ref> frame having the END_STREAM flag set:

            带有报头和载荷数据的POST HTTP请求将被转换成一个报头帧，后面跟着一个或者多个带有请求报头字段的延续帧，同时后面跟着一个或者多个数据帧。延续帧或者报头帧的最后一帧有END_HEADERS标记，最后一个数据帧拥有END_STREAM标记。
          </t>

          <figure>
            <artwork type="inline"><![CDATA[
  POST /resource HTTP/1.1          HEADERS
  Host: example.org          ==>     - END_STREAM
  Content-Type: image/jpeg           + END_HEADERS
  Content-Length: 123                  :method = POST
                                       :scheme = https
  {binary data}                        :path = /resource
                                       :authority = example.org
                                       content-type = image/jpeg
                                       content-length = 123

                                   DATA
                                     + END_STREAM
                                   {binary data}
]]></artwork>
          </figure>

          <t>
            A response that includes header fields and payload data is transmitted as a
            <x:ref>HEADERS</x:ref> frame, followed by zero or more <x:ref>CONTINUATION</x:ref> frames,
            followed by one or more <x:ref>DATA</x:ref> frames, with
            the last <x:ref>DATA</x:ref> frame in the sequence having the END_STREAM flag set:

            带有报头字段及载荷数据的响应将被转换成一个报头帧，后面跟着0个或多个延续帧，另外后面跟着一个或多个数据帧，序列中的最后一个数据帧拥有END_STREAM标记。
          </t>

          <figure>
            <artwork type="inline"><![CDATA[
  HTTP/1.1 200 OK                  HEADERS
  Content-Type: image/jpeg   ==>     - END_STREAM
  Content-Length: 123                + END_HEADERS
                                       :status = 200
  {binary data}                        content-type = image/jpeg
                                       content-length = 123

                                   DATA
                                     + END_STREAM
                                   {binary data}
]]></artwork>
          </figure>

          <t>
            Trailing header fields are sent as a header block after both the request or response
            header block and all the <x:ref>DATA</x:ref> frames have been sent.  The sequence of
            <x:ref>HEADERS</x:ref>/<x:ref>CONTINUATION</x:ref> frames that bears the trailers
            includes a terminal frame that has both END_HEADERS and END_STREAM flags set.

            所有的请求或者响应报头区块以及所有的数据帧发送之后，尾报头字段作为一个报头区块发送。带有尾部的报头/延续帧序列包含一个带有END_HEADERS及END_STREAM标记的终止帧。
          </t>

          <figure>
            <artwork type="inline"><![CDATA[
  HTTP/1.1 200 OK                  HEADERS
  Content-Type: image/jpeg   ==>     - END_STREAM
  Transfer-Encoding: chunked         + END_HEADERS
  Trailer: Foo                         :status        = 200
                                       content-length = 123
  123                                  content-type   = image/jpeg
  {binary data}                        trailer        = Foo
  0
  Foo: bar                         DATA
                                     - END_STREAM
                                   {binary data}

                                   HEADERS
                                     + END_STREAM
                                     + END_HEADERS
                                       foo: bar
]]></artwork>
        </figure>
      </section>

      <section anchor="HttpHeaders" title="HTTP Header Fields">
        <t>
          HTTP header fields carry information as a series of key-value pairs. For a listing of
          registered HTTP headers, see the Message Header Field Registry maintained at
          <eref target="http://www.iana.org/assignments/message-headers"/>.

          HTTP报头字段以一系列键值对的形式携带信息。指定的报头字段列表，见xx中维护的消息报头字段注册表。
        </t>
        <t>
          While HTTP/1.x used the message start-line (see <xref target="HTTP-p1" x:fmt=","
                x:rel="#start.line"/>) to convey the target URI and method of
          the request, and the status code for the response, HTTP/2 uses special pseudo-headers
          beginning with ":" for these tasks.

          HTTP/1.x使用消息开始线(见xxx)来传达目标URI、请求的方法及相应状态码。但HTTP/2使用特殊的以":"开始的伪头部来实现这些任务。
        </t>
        <t>
          Just as in HTTP/1.x, header field names are strings of ASCII characters that are compared
          in a case-insensitive fashion. However, header field names MUST be converted to lowercase
          prior to their encoding in HTTP/2. A request or response containing uppercase header
          field names MUST be treated as <xref target="malformed">malformed</xref>.

          正如HTTP/1.x中，报头字段名称是ASCII字符，且不区分大小写。然而，HTTP/2中报头字段名称必须转成使用同样编码的小写字符。带有大写报头字段的请求或者响应必须被认为是不规范的。
        </t>
        <t>
          HTTP/2 does not use the Connection header field to indicate "hop-by-hop" header fields;
          in this protocol, connection-specific metadata is conveyed by other means. As such, a
          HTTP/2 message containing Connection MUST be treated as <xref
          target="malformed">malformed</xref>.

          HTTP/2不使用连接报头字段来指示“逐跳”的报头字段；在该协议中，连接特定的元数据是通过其他手段传输的。因此，包含连接的HTTP/2消息必须被认为是不规范的。

        </t>
        <t>
          This means that an intermediary transforming an HTTP/1.x message to
          HTTP/2 will need to remove any header fields nominated by the Connection header field,
          along with the Connection header field itself. Such intermediaries SHOULD also remove
          other connection-specific header fields, such as Keep-Alive, Proxy-Connection,
          Transfer-Encoding and Upgrade, even if they are not nominated by Connection.

          这意味着中介端转换一个HTTP/1.x消息到HTTP/2需要移除由连接报头字段指定的任何报头字段，包含连接报头字段本身。这样的中介端同样应当移除其他连接特定的报头字段，例如Keep-Alive、Proxy-Connection、Transfer-Encoding和Upgrade，即便它们不是由连接指定的。
        </t>
        <t>
          One exception to this is the TE header field, which MAY be present in an HTTP/2 request,
          but when it is MUST NOT contain any value other than "trailers".

          一个例外是TE报头字段，这个可能在 HTTP/2 请求中保留，但是它不能包含“trailers”以外的值。
        </t>
        <t>
          <list style="hanging">
            <t hangText="Note:">
              HTTP/2 purposefully does not support upgrade to another protocol.  The
              handshake methods described in <xref target="starting"/> are believed sufficient to
              negotiate the use of alternative protocols.

              HTTP/2不支持升级到其他协议。3章节中描述的握手协议被认为足够用来作为替代协议使用。
            </t>
          </list>
        </t>

        <section anchor="HttpRequest" title="Request Header Fields">
          <t>
            HTTP/2 defines a number of header fields starting with a colon ':' character that carry
            information about the request target:

            HTTP/2定义了一个以字符“:”开头的报头域，包含目标请求的信息：
            <list style="symbols">
              <x:lt>
                <t>
                  The <spanx style="verb">:method</spanx> header field includes the HTTP method
                  (<xref target="HTTP-p2" x:fmt="," x:rel="#methods"/>).
                  :method 报头字段包含了HTTP方法
                </t>
              </x:lt>
              <x:lt>
                <t>
                  The <spanx style="verb">:scheme</spanx> header field includes the scheme portion
                  of the target URI (<xref target="RFC3986" x:fmt="," x:sec="3.1"/>).
                  :scheme字段包含了目标URI方案部分。
                </t>
              </x:lt>
              <x:lt>
                <t>
                  The <spanx style="verb">:authority</spanx> header field includes the authority
                  portion of the target URI (<xref target="RFC3986" x:fmt="," x:sec="3.2"/>).  The
                  authority MUST NOT include the deprecated <spanx style="verb">userinfo</spanx>
                  subcomponent for <spanx style="verb">http:</spanx> or <spanx
                  style="verb">https:</spanx> URIs.

                  :authority报头字段包含了目标URI的权限部分。这个权限绝对不能包含http:或者https: URIs的废弃的用户信息子成份。
                </t>
                <t>
                  To ensure that the HTTP/1.1 request line can be reproduced accurately, this
                  header field MUST be omitted when translating from an HTTP/1.1 request that has a
                  request target in origin or asterisk form (see <xref target="HTTP-p1" x:fmt=","
                  x:rel="#request-target"/>). Clients that generate HTTP/2 requests directly SHOULD
                  instead omit the <spanx style="verb">Host</spanx> header field. An intermediary
                  that converts an HTTP/2 request to HTTP/1.1 MUST create a <spanx
                  style="verb">Host</spanx> header field if one is not present in a request by
                  copying the value of the <spanx style="verb">:authority</spanx> header field.

                  为了保证HTTP/1.1请求行能被精确复制，当原始请求有请求目标或者星号形式(见[ http-p1 ]，5.3节)的HTTP/1.1请求进行转换时这个字段必须被忽略。客户端直接生成HTTP/2请求的相反应该忽略Host报头字段。如果其中一个请求没有Host字段，中介端将HTTP/2请求转换为HTTP/1.1请求的时候必须复制:authority字段的值来生成Host字段。
                </t>
              </x:lt>
              <x:lt>
                <t>
                  The <spanx style="verb">:path</spanx> header field includes the path and query
                  parts of the target URI (the <spanx style="verb">path-absolute</spanx> production
                  from <xref target="RFC3986"/> and optionally a '?' character followed by the
                  <spanx style="verb">query</spanx> production, see <xref target="RFC3986" x:fmt=","
                  x:sec="3.3"/> and <xref target="RFC3986" x:fmt="," x:sec="3.4"/>).  This field
                  MUST NOT be empty; URIs that do not contain a path component MUST include a value
                  of '/', unless the request is an OPTIONS request in asterisk form, in which case
                  the <spanx style="verb">:path</spanx> header field MUST include '*'.

                  :path字段包含目标URI的路径及查询部分(绝对路径由[RFC3986]以及可选的‘?’字符后面跟着查询词组成见xx)。这个字段绝对不能为空；URI不包含path组件的必须包含一个'/'值，除非请求是一个星号形式的可选请求：这种情况下:path报头字段必须包含"*"。
                </t>
              </x:lt>
            </list>
            All HTTP/2 requests MUST include exactly one valid value for the <spanx
            style="verb">:method</spanx>, <spanx style="verb">:scheme</spanx>, and <spanx
            style="verb">:path</spanx> header fields, unless this is a <xref
            target="CONNECT">CONNECT request</xref>.  An HTTP request that omits mandatory header
            fields is <xref target="malformed">malformed</xref>.

            所有的HTTP/2请求都必须在:method、:scheme和:path字段上有准确的值，除非是一个连接请求。缺少基本报头字段的HTTP请求是不规范的。
          </t>
          <t>
            Header field names that start with a colon are only valid in the HTTP/2 context.  These
            are not HTTP header fields.  Implementations MUST NOT generate header fields that start
            with a colon, but they MUST ignore any header field that starts with a colon.  In
            particular, header fields with names starting with a colon MUST NOT be exposed as HTTP
            header fields.

            以冒号开头的报头字段只在HTTP/2上下文中有效。这些不是HTTP报头字段。实现的时候绝对不能生成以冒号开头的报头字段，但是他们必须忽略任何以冒号开头的报头字段。特别是，名称以冒号开头的报头字段绝对不能暴露在HTTP报头字段中。
          </t>
          <t>
            HTTP/2 does not define a way to carry the version identifier that is included in the
            HTTP/1.1 request line.

            HTTP/2没有定义中方式来包含版本标识，这个已经在HTTP/1.1请求行中包含。
          </t>
        </section>

        <section anchor="HttpResponse" title="Response Header Fields">
          <t>
            A single <spanx style="verb">:status</spanx> header field is defined that carries the
            HTTP status code field (see <xref target="HTTP-p2" x:fmt="," x:rel="#status.codes"/>).
            This header field MUST be included in all responses, otherwise the response is <xref
            target="malformed">malformed</xref>.

            一个单一的:status字段定义用来携带HTTP状态码字段(见xxx)。这个报头字段必须包含在所有响应中，除非响应是不规范的。
          </t>
          <t>
            HTTP/2 does not define a way to carry the version or reason phrase that is included in
            an HTTP/1.1 status line.

            HTTP/2没有定义一种方式来携带版本或原因短语，这些已经在HTTP/1.1状态行中包含。
          </t>
        </section>

        <section anchor="HeaderOrdering" title="Header Field Ordering">
          <t>
            <xref target="COMPRESSION">HTTP Header Compression</xref> does not preserve the order of
            header fields, because the relative order of header fields with different names is not
            important.  However, the same header field can be repeated to form a
            list (see <xref target="HTTP-p1" x:fmt="," x:rel="#field.order"/>), where the relative
            order of header field values is significant. This repetition can occur either as a
            single header field with a comma-separated list of values, or as several header fields
            with a single value, or any combination thereof. Therefore, in the latter case, ordering
            needs to be preserved before compression takes place.

            HTTP报头压缩并不保留报头字段的顺序，因为不同名称的字段的相对位置并不重要。然而，当相同字段重复组成一个列表的时候(见xxx)，报头字段值的相对位置就有意义。这种重复会出现在以逗号分隔的单个报头字段值列表中，或者作为几个报头字段的单一值，或他们的任何组合。因此，再后者情况下，报头需在再压缩前保留字段顺序。
          </t>
          <t>
            To preserve the order of multiple occurrences of a header field with the same name, its
            ordered values are concatenated into a single value using a zero-valued octet (0x0) to
            delimit them.

            为了保留同个名称的报头字段出现多次的顺序，他们的顺序使用单个以零值字节(0x0)分隔的值连接来保留。
          </t>
          <t>
            After decompression, header fields that have values containing zero octets (0x0) MUST be
            split into multiple header fields before being processed.

            解压缩后，报头字段包含有0字节的必须分割成多个报头字段之后才能进一步处理。
          </t>
          <t>For example, the following HTTP/1.x header block:</t>
          例如，下面的HTTP/1.x报头区块：
          <figure>
            <artwork type="inline"><![CDATA[
              Content-Type: text/html
              Cache-Control: max-age=60, private
              Cache-Control: must-revalidate
]]></artwork></figure>
          <t>
            contains three Cache-Control directives; two in the first Cache-Control header field,
            and the last one in the second Cache-Control field. Before compression, they would need
            to be converted to a form similar to this (with 0x0 represented as "\0"):

            包含三个缓存控制指令；两个在第一个缓存控制报头字段，一个在第二个缓存控制字段。在压缩前，它们需要转成类似格式("\0"表示0x0):
          </t>
          <figure>
            <artwork type="inline"><![CDATA[
              cache-control: max-age=60, private\0must-revalidate
              content-type: text/html
]]></artwork></figure>
          <t>
            Note here that the ordering between Content-Type and Cache-Control is not preserved, but
            the relative ordering of the Cache-Control directives -- as well as the fact that the
            first two were comma-separated, while the last was on a different line -- is.

            注意这里内容类型与缓存控制的顺序是不保留的，但是缓存控制指令的相对顺序——事实上也就是前两个是用逗号分隔，而后一个是在不一样的行——是保留的。
          </t>
          <t>
            Header fields containing multiple values MUST be concatenated into a single value unless
            the ordering of that header field is known to be insignificant.

            报头字段包含多个值必须组成单个值，除非报头字段的顺序是不重要的。
          </t>
          <t>
            The special case of <spanx style="verb">set-cookie</spanx> - which does not form a
            comma-separated list, but can have multiple values - does not depend on ordering.  The
            <spanx style="verb">set-cookie</spanx> header field MAY be encoded as multiple header
            field values, or as a single concatenated value.

            特殊情况是设置cookie——不需要形成一个逗号分隔的列表，但是可以有多个值——不需要依赖顺序。设置cookie字段可以被编码成多行报头字段值，或者单个的连接值。
          </t>
        </section>

        <section anchor="CompressCookie" title="Compressing the Cookie Header Field">
          <t>
            The <xref target="COOKIE">Cookie header field</xref> can carry a significant amount of
            redundant data.

            Cookie报头字段可以携带大量的冗余数据。
          </t>
          <t>
            The Cookie header field uses a semi-colon (";") to delimit cookie-pairs (or "crumbs").
            This header field doesn't follow the list construction rules in HTTP (see <xref
            target="HTTP-p1" x:fmt="," x:rel="#field.order"/>), which prevents cookie-pairs from
            being separated into different name-value pairs.  This can significantly reduce
            compression efficiency as individual cookie-pairs are updated.

            Cookie字段使用“;”来分割cookie-对(或叫面包屑)。这报头字段不遵循HTTP中的构建规则(见xxx)，以防cookie-对被分隔成不同的键值对。单个cookie-对更新的时候能显著提升压缩效率。
          </t>
          <t>
            To allow for better compression efficiency, the Cookie header field MAY be split into
            separate header fields, each with one or more cookie-pairs.  If there are multiple
            Cookie header fields after decompression, these MUST be concatenated into a single octet
            string using the two octet delimiter of 0x3B, 0x20 (the ASCII string "; ").

            为了更好的压缩效率，Cookie字段可以被分隔成多个报头字段，每个包含一个或者多个cookie对。如果解压后有多个Cookie报头字段，他们必须由两个字节的0x3B, 0x20(ASCII";")连接成单个字段。
          </t>
          <t>
            The Cookie header field MAY be split using a zero octet (0x0), as defined in <xref
            target="HeaderOrdering"/>.  When decoding, zero octets MUST be replaced with the cookie
            delimiter ("; ").

            Coookie报头字段也可以使用0值字节(0x0)来分割，同HeaderOrdering中定义。当解码的时候，0值字节必须被替换成Cookie的分隔符(";")。
          </t>
        </section>

        <section anchor="malformed" title="Malformed Messages">
          <t>
            A malformed request or response is one that uses a valid sequence of HTTP/2 frames, but
            is otherwise invalid due to the presence of prohibited header fields, the absence of
            mandatory header fields, or the inclusion of uppercase header field names.

            不规范的请求或者响应是一个使用了有效序列的HTTP/2帧，但是使用了禁止的报头字段、必须字段缺失或者字段名称使用了大写。
          </t>
          <t>
            A request or response that includes an entity body can include a <spanx
            style="verb">content-length</spanx> header field.  A request or response is also
            malformed if the value of a <spanx style="verb">content-length</spanx> header field does
            not equal the sum of the <x:ref>DATA</x:ref> frame payload lengths that form the body.

            包含实体的请求或者响应可以保护一个实体内容长度的报头字段。如果内容长度报头字段的值不等于组成实体的数据帧载荷长度，同样是不规范的。

          </t>
          <t>
            Intermediaries that process HTTP requests or responses (i.e., all intermediaries other
            than those acting as tunnels) MUST NOT forward a malformed request or response.

            中介者处理HTTP请求或者响应(除了用来作为隧道的所有中介者)绝对不能转发一个不规范的请求或者响应。
          </t>
          <t>
            Implementations that detect malformed requests or responses need to ensure that the
            stream ends.  For malformed requests, a server MAY send an HTTP response prior to
            closing or resetting the stream.  Clients MUST NOT accept a malformed response. Note
            that these requirements are intended to protect against several types of common attacks
            against HTTP; they are deliberately strict, because being permissive can expose
            implementations to these vulnerabilites.

            中介者检测到不规范的请求或者响应必须保证流已经终止。对于不规范的请求，服务端可以发送之前提到的响应来关闭或者重置流。客户端绝对不能接收一个不规范的响应。请注意，这些要求是为了防止一些针对HTTP的常见攻击；故意这么严格，是因为允许这些情况的话可能会暴露这些漏洞的实现。
          </t>
        </section>
      </section>

      <section anchor="Reliability" title="Request Reliability Mechanisms in HTTP/2">
          <t>
            In HTTP/1.1, an HTTP client is unable to retry a non-idempotent request when an error
            occurs, because there is no means to determine the nature of the error.  It is possible
            that some server processing occurred prior to the error, which could result in
            undesirable effects if the request were reattempted.

            在HTTP/1.1中，HTTP客户端在发送错误时不能重试一个非幂等的请求，因为没有方式来确定错误的性质。有可能服务器在错误之前正在处理，如果请求重试可能导致不良影响。
          </t>
          <t>
            HTTP/2 provides two mechanisms for providing a guarantee to a client that a request has
            not been processed:

            HTTP/2提供了两种机制来确保让客户端知道请求没有被处理:
            <list style="symbols">
              <t>
                The <x:ref>GOAWAY</x:ref> frame indicates the highest stream number that might have
                been processed.  Requests on streams with higher numbers are therefore guaranteed to
                be safe to retry.

                超时帧指示了流可能被处理的最大流流标示。在更大数字的流上的请求可以保证安全的重试。
              </t>
              <t>
                The <x:ref>REFUSED_STREAM</x:ref> error code can be included in a
                <x:ref>RST_STREAM</x:ref> frame to indicate that the stream is being closed prior to
                any processing having occurred.  Any request that was sent on the reset stream can
                be safely retried.

                RST_STREAM帧中可以包含REFUSED_STREAM错误码来指示流由于之前的处理正在关闭。重置流上的任何请求都可以安全重试。
              </t>
            </list>
          </t>
          <t>
            Requests that have not been processed have not failed; clients MAY automatically retry
            them, even those with non-idempotent methods.

            未经处理的请求且没有失败；客户可以自动重试，甚至包括那些非幂等元的方法。
          </t>
          <t>
            A server MUST NOT indicate that a stream has not been processed unless it can guarantee
            that fact.  If frames that are on a stream are passed to the application layer for any
            stream, then <x:ref>REFUSED_STREAM</x:ref> MUST NOT be used for that stream, and a
            <x:ref>GOAWAY</x:ref> frame MUST include a stream identifier that is greater than or
            equal to the given stream identifier.

            服务端绝对不能表示一个流未被处理除非它能确保这个事实。如果流上的帧被传递给应用层的任何流，绝对不能在这个流上使用REFUSED_STREAM，而且一个超时帧必须包含一个大于或等于给定流表示的标识符。
          </t>
          <t>
            In addition to these mechanisms, the <x:ref>PING</x:ref> frame provides a way for a
            client to easily test a connection.  Connections that remain idle can become broken as
            some middleboxes (for instance, network address translators, or load balancers) silently
            discard connection bindings.  The <x:ref>PING</x:ref> frame allows a client to safely
            test whether a connection is still active without sending a request.

            除了这些机制，PING帧给客户的提供了一种方式来简单测试连接。保持空闲的连接可能被一些中间件(例如网络地址翻译或负载均衡器)静默丢弃连接绑定而打破。PING帧允许客户端在无需发送请求的情况下安全地测试连接是否依旧激活。
          </t>
        </section>
      </section>

      <section anchor="PushResources" title="Server Push">
        <t>
          HTTP/2 enables a server to pre-emptively send (or "push") one or more associated
          responses to a client in response to a single request. This feature becomes particularly
          helpful when the server knows the client will need to have those responses available in
          order to fully process the response to the original request.

          HTTP/2允许服务端针对客户端一个单独的请求，主动的发送(或推送)一个或者多个相关的响应。这种特定在服务端知道客户端需要这些响应来完整的处理最初的请求的时候特别有用。
        </t>

        <t>
          Pushing additional responses is optional, and is negotiated between individual
          endpoints.  The <x:ref>SETTINGS_ENABLE_PUSH</x:ref> setting can be set to 0 to indicate
          that server push is disabled.

          推送额外的响应是可选的，并且由单独的终端之间协商。SETTINGS_ENABLE_PUSH设置设置为0来标识服务端推送是可用的。
        </t>
        <t>
          Because pushing responses is effectively hop-by-hop, an intermediary could receive pushed
          responses from the server and choose not to forward those on to the client. In other
          words, how to make use of the pushed responses is up to that intermediary. Equally, the
          intermediary might choose to push additional responses to the client, without any action
          taken by the server.

          因为推送的响应只在逐跳情况下有效，中介端接从服务端接收到推送响应的可以选择不转发这些到客户端。也就是说，如何使用推送响应取决于这些中介端。相等的，中介可能选择不推送的额外的响应给客户端，不需要服务端进行任何操作。
        </t>
        <t>
          A client cannot push. Thus, servers MUST treat the receipt of a
          <x:ref>PUSH_PROMISE</x:ref> frame as a <xref target="ConnectionErrorHandler">connection
          error</xref>. Clients MUST reject any attempt to change the
          <x:ref>SETTINGS_ENABLE_PUSH</x:ref> setting to a value other than "0" by treating the
          message as a <xref target="ConnectionErrorHandler">connection error</xref> of type
          <x:ref>PROTOCOL_ERROR</x:ref>.

          客户端不能推送。因此，服务端收到客户端的PUSH_PROMISE帧必须作为连接错误处理。客户端不许拒绝任何尝试修改SETTINGS_ENABLE_PUSH设置值为0以外的值，并将这消息作为类型为协议错误的连接错误处理。
        </t>
        <t>
          A server can only push responses that are cacheable (see <xref target="HTTP-p6" x:fmt=","
          x:rel="#response.cacheability"/>); promised requests MUST be safe (see <xref
          target="HTTP-p2" x:fmt="," x:rel="#safe.methods"/>) and MUST NOT include a request body.

          服务端智能推送被缓存的响应(见xxx);被承诺的请求必须是安全的，而且绝对不能包含一个请求主体。
        </t>

        <section title="Push Requests">
          <t>
            Server push is semantically equivalent to a server responding to a request; however, in
            this case that request is also sent by the server, as a <x:ref>PUSH_PROMISE</x:ref>
            frame.

            服务端推送语义上等同于服务端响应一个请求；然而，这种情况下请求也是由服务端发送的，作为一个PUSH_PROMISE帧。
          </t>
          <t>
            The <x:ref>PUSH_PROMISE</x:ref> frame includes a header block that contains a complete
            set of request header fields that the server attributes to the request. It is not
            possible to push a response to a request that includes a request body.

            PUSH_PROMISE包含了一个报头区块，含有完整的服务端属性请求报头字段。不可能对带有请求实体的请求进行推送。

          </t>

          <t>
            Pushed responses are always associated with an explicit request from the client. The
            <x:ref>PUSH_PROMISE</x:ref> frames sent by the server are sent on that explicit
            request's stream. The <x:ref>PUSH_PROMISE</x:ref> frame also includes a promised stream
            identifier, chosen from the stream identifiers available to the server (see <xref
            target="StreamIdentifiers"/>).

            推送的响应总是与客户端的一个明确的请求相关。服务端在这个明确的请求流上发送PUSH_PROMISE帧。PUSH_PROMISE帧一般包含被承诺的流标识符，从可用的服务端流标识符中选择(见xxx)。
          </t>

          <t>
            The header fields in <x:ref>PUSH_PROMISE</x:ref> and any subsequent
            <x:ref>CONTINUATION</x:ref> frames MUST be a valid and complete set of <xref
                target="HttpRequest">request header fields</xref>.  The server MUST include a
            method in the <spanx style="verb">:method</spanx> header field that is safe and
            cacheable.  If a client receives a <x:ref>PUSH_PROMISE</x:ref> that does not include a
            complete and valid set of header fields, or the <spanx style="verb">:method</spanx>
            header field identifies a method that is not safe, it MUST respond with a <xref
                target="StreamErrorHandler">stream error</xref> of type
            <x:ref>PROTOCOL_ERROR</x:ref>.

            在PUSH_PROMISE或者任何其他延续的帧中的报头字段必须是完整的请求报头字段。服务端必须在:method字段中包含一个安全而且可缓存的方法。如何客户端收到不包含完整而且有效的报头字段的PUSH_PROMISE帧、或者:method表示的方法不是安全的，客户端必须响应一个类型为协议错误的流错误。
          </t>

          <t>
            The server SHOULD send <x:ref>PUSH_PROMISE</x:ref> (<xref target="PUSH_PROMISE"/>)
            frames prior to sending any frames that reference the promised responses. This avoids a
            race where clients issue requests prior to receiving any <x:ref>PUSH_PROMISE</x:ref>
            frames.

            服务端应当在发送任何被承诺的响应之前发送一个PUSH_PROMISE帧。这避免了客户端在收到任何PUSH_PROMISE帧前发出请求而出现的竞赛。
          </t>
          <t>
            For example, if the server receives a request for a document containing embedded links
            to multiple image files, and the server chooses to push those additional images to the
            client, sending push promises before the <x:ref>DATA</x:ref> frames that contain the
            image links ensures that the client is able to see the promises before discovering
            embedded links. Similarly, if the server pushes responses referenced by the header
            block (for instance, in Link header fields), sending the push promises before sending
            the header block ensures that clients do not request them.

            例如：如果服务端收到文档请求包含多个嵌入式的图像链接，而且服务端选择推送那些额外的图像给客户端，再数据帧前发送push promises能确保客户端能够在发现内嵌链接前看到这些承诺。类似的，如果服务端推送与报头区块(例如，在Link报头域)相关的响应，再发送报头区块前推送承诺能确保客户端不请求它们。
          </t>

          <t>
            <x:ref>PUSH_PROMISE</x:ref> frames MUST NOT be sent by the client.
            <x:ref>PUSH_PROMISE</x:ref> frames can be sent by the server on any stream that was
            opened by the client.  They MUST be sent on a stream that is in either the "open" or
            "half closed (remote)" state to the server.  <x:ref>PUSH_PROMISE</x:ref> frames are
            interspersed with the frames that comprise a response, though they cannot be
            interspersed with <x:ref>HEADERS</x:ref> and <x:ref>CONTINUATION</x:ref> frames that
            comprise a single header block.

            PUSH_PROMISE帧绝对不能由客户端发送。
            PUSH_PROMISE可以由服务端在任意由客户端打开的流上发送。他们必须在对服务端状态为“打开”或者“半封闭(远端)”的流上发送。PUSH_PROMISE帧由响应帧穿插组成，不过他们不能由包含单个报头区块的报头帧和延续帧组成。

          </t>
        </section>

        <section title="Push Responses">
          <t>
            After sending the <x:ref>PUSH_PROMISE</x:ref> frame, the server can begin delivering the
            pushed response as a <xref target="HttpResponse">response</xref> on a server-initiated
            stream that uses the promised stream identifier.  The server uses this stream to transmit
            an HTTP response, using the same sequence of frames as defined in <xref
            target="HttpSequence"/>.  This stream becomes <xref target="StreamStates">"half closed" to
            the client</xref> after the initial <x:ref>HEADERS</x:ref> frame is sent.

            发送PUSH_PROMISE帧后，服务端可以开始传送推送响应作为一个响应，在由服务端初始化的使用被承诺的流标识符的流上传送。服务端使用这些流传送一个HTTP响应，使用HttpSequence中定义的相同的帧序列。在初始化报头帧发送后，流对客户端变为“半封闭”状态。
          </t>

          <t>
            Once a client receives a <x:ref>PUSH_PROMISE</x:ref> frame and chooses to accept the
            pushed response, the client SHOULD NOT issue any requests for the promised response
            until after the promised stream has closed.

            一旦客户端接收到PUSH_PROMISE帧并且选择接受推送的响应，客户端不应该对被承诺的响应发起人和请求，直到被承诺的流被关闭为止。
          </t>

          <t>
            If the client determines, for any reason, that it does not wish to receive the pushed
            response from the server, or if the server takes too long to begin sending the promised
            response, the client can send an <x:ref>RST_STREAM</x:ref> frame, using either the
            <x:ref>CANCEL</x:ref> or <x:ref>REFUSED_STREAM</x:ref> codes, and referencing the pushed
            stream's identifier.

            如果客户端以任何理由决定不希望接受服务端推送的响应，或者服务端花费太长时间才开始发送承诺的响应，客户端可以发送一个RST_STREAM帧，使用CANCEL或者REFUSED_STREAM码来关联被推送的流标识符。
          </t>
          <t>
            A client can use the <x:ref>SETTINGS_MAX_CONCURRENT_STREAMS</x:ref> setting to limit the
            number of responses that can be concurrently pushed by a server.  Advertising a
            <x:ref>SETTINGS_MAX_CONCURRENT_STREAMS</x:ref> value of zero disables server push by
            preventing the server from creating the necessary streams.  This does not prohibit a
            server from sending PUSH_PROMISE frames; clients need to reset any promised streams that
            are not wanted.

            客户端可以使用SETTINGS_MAX_CONCURRENT_STREAMS设置来限制服务端推送的响应的并发量。广播值为0的SETTINGS_MAX_CONCURRENT_STREAMS能防止服务端创建必需的流。这不能禁止服务端发送PUSH_PROMISE帧；客户端需要重置任何不需要的被承诺的流。
          </t>

          <t>
            Clients receiving a pushed response MUST validate that the server is authorized to
            provide the response, see <xref target="authority"/>.  For example, an server that
            offers a certificate for only the <spanx style="verb">example.com</spanx> DNS-ID or
            Common Name is not permitted to push a response for <spanx
            style="verb">https://www.example.org/doc</spanx>.

            客户端收到推送响应必须验证服务端是授权提供响应的，见authority。例如，服务端只带有针对example.com的DNS的授权证书是不允许给https://www.example.org/doc推送给响应的。
          </t>
        </section>

      </section>

      <section anchor="CONNECT" title="The CONNECT Method">
        <t>
          In HTTP/1.x, the pseudo-method CONNECT (<xref target="HTTP-p2" x:fmt=","
          x:rel="#CONNECT"/>) is used to convert an HTTP connection into a tunnel to a remote host.
          CONNECT is primarily used with HTTP proxies to establish a TLS session with an origin
          server for the purposes of interacting with <spanx style="verb">https</spanx> resources.

          在HTTP/1.x中，伪方法连接()用来转换HTTP连接成隧道到远端主机。连接主要用HTTP代理为使用HTTPS资源相互作用的目的源服务器建立TLS会话。
        </t>
        <t>
          In HTTP/2, the CONNECT method is used to establish a tunnel over a single HTTP/2 stream
          to a remote host, for similar purposes. The HTTP header field mapping works as mostly as
          defined in <xref target="HttpRequest">Request Header Fields</xref>, with a few
          differences. Specifically:

          在HTTP/2中，连接方法用来在一个单一的HTTP/2流上建立一个通向远端主机的隧道，目的类似。HTTP报头字段寻址工作大部分同请求报头字段中定义，有一部分不同。具体为：
          <list style="symbols">
              <t>
                The <spanx style="verb">:method</spanx> header field is set to <spanx
                style="verb">CONNECT</spanx>.
                连接中包含:method报头字段。
              </t>
              <t>
                The <spanx style="verb">:scheme</spanx> and <spanx style="verb">:path</spanx> header
                fields MUST be omitted.

                :scheme和:path报头字段必须被忽略。

              </t>
              <t>
                The <spanx style="verb">:authority</spanx> header field contains the host and port
                to connect to (equivalent to the authority-form of the request-target of CONNECT
                requests, see <xref target="HTTP-p1" x:fmt="," x:rel="#request-target"/>).

                :authority报头字段包含主机及连接的端口(相当于authority形式的请求目标连接请求，见xxx)。
              </t>
          </list>
        </t>
        <t>
          A proxy that supports CONNECT establishes a <xref target="TCP">TCP connection</xref> to
          the server identified in the <spanx style="verb">:authority</spanx> header field. Once
          this connection is successfully established, the proxy sends a <x:ref>HEADERS</x:ref>
          frame containing a 2xx series status code to the client, as defined in <xref
          target="HTTP-p2" x:fmt="," x:rel="#CONNECT"/>.

          支持CONNECT的端口建立一个TCP连接到服务器，如:authority报头字段中定义。一旦连接建立成功，代理发送一个报头帧包含一个2xx序列状态码到客户端，如xxx中定义。
        </t>
        <t>
          After the initial <x:ref>HEADERS</x:ref> frame sent by each peer, all subsequent
          <x:ref>DATA</x:ref> frames correspond to data sent on the TCP connection.  The payload of
          any <x:ref>DATA</x:ref> frames sent by the client are transmitted by the proxy to the TCP
          server; data received from the TCP server is assembled into <x:ref>DATA</x:ref> frames by
          the proxy.  Frame types other than <x:ref>DATA</x:ref> or stream management frames
          (<x:ref>RST_STREAM</x:ref>, <x:ref>WINDOW_UPDATE</x:ref>, and <x:ref>PRIORITY</x:ref>)
          MUST NOT be sent on a connected stream, and MUST be treated as a <xref
          target="StreamErrorHandler">stream error</xref> if received.

          初始化报头帧由各个对等端发送后，所有随后的与数据对应的数据帧在TCP连接上发送。客户端发送的数据帧载荷由代理转换再发送给TCP服务器；从TCP服务器接收到的数据由代理组装成数据帧。数据帧或者流管理帧以外的帧(RST_STREAM、WINDOW_UPDATE和PRIORITY)绝对不能再建立的流上发送，如果收到这样的帧必须作为流错误处理。
        </t>
        <t>
          The TCP connection can be closed by either peer.  The END_STREAM flag on a
          <x:ref>DATA</x:ref> frame is treated as being equivalent to the TCP FIN bit.  A client is
          expected to send a <x:ref>DATA</x:ref> frame with the END_STREAM flag set after receiving
          a frame bearing the END_STREAM flag.  A proxy that receives a <x:ref>DATA</x:ref> frame
          with the END_STREAM flag set sends the attached data with the FIN bit set on the last TCP
          segment.  A proxy that receives a TCP segment with the FIN bit set sends a
          <x:ref>DATA</x:ref> frame with the END_STREAM flag set.  Note that the final TCP segment
          or <x:ref>DATA</x:ref> frame could be empty.

          TCP连接可以被各个对等端关闭。数据帧上的END_STREAM标记被认为与TCP FIN比特相同。客户端在收到带有END_STREAM标记的帧后被期望应该发送一个带有 END_STREAM标记的数据帧。代理接收到带有END_STREAM 标记的数据帧将在发送这些数据的时候在最后的TCP段上设置FIN位。带有接收到带有FIN位的TCP端发送一个带有END_STREAM标记的数据帧。注意最后的TCP端或者数据帧可以为空。
        </t>
        <t>
          A TCP connection error is signaled with <x:ref>RST_STREAM</x:ref>.  A proxy treats any
          error in the TCP connection, which includes receiving a TCP segment with the RST bit set,
          as a <xref target="StreamErrorHandler">stream error</xref> of type
          <x:ref>CONNECT_ERROR</x:ref>.  Correspondingly, a proxy MUST send a TCP segment with the
          RST bit set if it detects an error with the stream or the HTTP/2 connection.

          TCP连接错误由RST_STREAM来标记。代理对外TCP连接中的任何错误，包括接收到设置了RST位的TCP段，作为类型为连接错误的流错误处理。相应的，代理如果检测到流或者HTTP/2连接的错误必须发送一个设置了RST位的TCP段。
        </t>
      </section>
    </section>

    <section anchor="HttpExtra" title="Additional HTTP Requirements/Considerations">
      <t>
        This section outlines attributes of the HTTP protocol that improve interoperability, reduce
        exposure to known security vulnerabilities, or reduce the potential for implementation
        variation.

        这段概况了HTTP协议的属性，包括提高互操作性、减少暴露已知的安全漏洞，或者减少执行变动的可能。
      </t>

      <section title="Connection Management">
        <t>
          HTTP/2 connections are persistent.  For best performance, it is expected clients will not
          close connections until it is determined that no further communication with a server is
          necessary (for example, when a user navigates away from a particular web page), or until
          the server closes the connection.

          HTTP/2连接是永久性的。为了最佳的性能，它期待客户端不会关闭连接，直到确定与服务端的进一步沟通不再必要(例如，当用户导航到其他特定的网页)，或者直到服务端关闭连接。
        </t>
        <t>
          Clients SHOULD NOT open more than one HTTP/2 connection to a given destination, where a
          destination is the IP address and TCP port that is identified for a given URI <cref>Here
          is where we need to be careful with Alt-Svc</cref>, or the IP and port of a configured
          proxy.  A client can create additional connections as replacements, either to replace
          connections that are near to exhausting the available <xref
          target="StreamIdentifiers">stream identifier space</xref>, or to replace connections that
          have encountered <xref target="ConnectionErrorHandler">errors</xref>.

          客户端不应该再给定的目的地上打开多个HTTP/2连接，目的地是由给定的URI确定的IP地址及TCP端口【这里我们需要小心Alt-Svc】，或者配置的代理的IP和端口。客户端可以创建额外的连接作为替代，或者取代快要用尽可用流标识空间的连接，或者替换遇到错误的连接。
        </t>
        <t>
          A client MAY open multiple connections to the same IP address and TCP port using different
          <xref target="TLS-EXT">Server Name Indication</xref> values or to provide different TLS
          client certificates, but SHOULD avoid creating multiple connections with the same
          configuration.  <cref>Need more text on how client certificates relate here, see issue
          #363.</cref>

          客户端可以使用不相同的服务端名称标识值或者提供不一样的TLS客户端证书对相同IP地址及TCP端口打开多个连接，但应该避免对相同的配置上创建多个连接。关于客户端证书相关的更多信息，见xxx.
        </t>
        <t>
          Clients MAY use a single server connection to send requests for URIs with multiple
          different authority components as long as the server is <xref
          target="authority">authoritative</xref>.

          客户端可以使用单个的服务端连接来发送不同认证组件的URIs请求，只要服务端是认证的。
        </t>
        <t>
          Servers are encouraged to maintain open connections for as long as possible, but are
          permitted to terminate idle connections if necessary.  When either endpoint chooses to
          close the transport-level TCP connection, the terminating endpoint SHOULD first send a
          <x:ref>GOAWAY</x:ref> (<xref target="GOAWAY"/>) frame so that both endpoints can reliably
          determine whether previously sent frames have been processed and gracefully complete or
          terminate any necessary remaining tasks.

          服务端被孤立尽可能长的保持打开的连接，但在必要下允许关闭空闲的连接。当任意一个终端决定关闭传输层的TCP连接，决定关闭的终端应首先发送一个GOAWAY帧这样两个终端都能可靠的确定之前发送的帧是否已经被处理及优雅的完成或者终止任何必要的剩余任务。
        </t>
      </section>

      <section title="Use of TLS Features" anchor="TLSUsage">
        <t>
          Implementations of HTTP/2 MUST support <xref target="TLS12">TLS 1.2</xref>.  The general
          TLS usage guidance in <xref target="TLSBCP"/> SHOULD be followed, with some additional
          restrictions that are specific to HTTP/2.

          实现HTTP/2必须支持TLS 1.2。通用的TLS用法指导应该遵循，同时加上对HTTP/2的特定支持。
        </t>
        <t>
          The TLS implementation MUST support the <xref target="TLS-EXT">Server Name Indication
          (SNI)</xref> extension to TLS. HTTP/2 clients MUST indicate the target domain name when
          negotiating TLS.

          TLS实现必须支持服务端名称标识(SNI)的TLS扩展。HTTP/2客户端再协商TLS的时候必须标明目标域名名称。
        </t>
        <t>
          The TLS implementation MUST disable compression.  TLS compression can lead to the exposure
          of information that would not otherwise be revealed <xref target="RFC3749"/>.  Generic
          compression is unnecessary since HTTP/2 provides compression features that are more aware
          of context and therefore likely to be more appropriate for use for performance, security
          or other reasons.

          TLS实现必须禁止压缩。TLS压缩可能导致信息暴露。通用的压缩是不必要的，因为HTTP/2提供的压缩功能更加上下文，因为可能是更符合使用性能、安全或者其他原因。
        </t>
        <t>
          Implementations MUST negotiate - and therefore use - ephemeral cipher suites, such as
          ephemeral Diffie-Hellman (DHE) or the elliptic curve variant (ECDHE) with a minimum size
          of 2048 bits (DHE) or security level of 128 bits (ECDHE). Clients MUST accept DHE sizes of
          up to 4096 bits.

          实现必须歇山-因此使用短暂的密码套件，如短暂的Diffie-Hellman（DHE）或椭圆曲线的变体（ecdhe）具有最小尺寸的2048位（DHE）或128位的安全级别（ecdhe）。客户端必须接受多达4096位DHE尺寸。
        </t>
        <t>
          Implementations are encouraged not to negotiate TLS cipher suites with known
          vulnerabilities, such as <xref target="RC4"/>.

          实现不鼓励使用已知的存在漏洞的TLS密码套件进行协商，如RC4。
        </t>
        <t>
          An implementation that negotiates a TLS connection that does not meet the requirements in
          this section, or any policy-based constraints, SHOULD NOT negotiate HTTP/2.  Removing
          HTTP/2 protocols from consideration could result in the removal of all protocols from the
          set of protocols offered by the client.  This causes protocol negotiation failure, as
          described in <xref target="TLSALPN" x:fmt="of" x:sec="3.2"/>.

          实现中与不符合本章要求或者任何基于策略的约束的TLS协商，都不应该协商HTTP/2。考虑下移除HTTP/2协议可能导致所有客户端提供的协议集合被移除。这个导致的协议协议协商错误，如xxx中描述。
        </t>
        <t>
          Due to implementation limitations, it might not be possible to fail TLS negotiation based
          on all of these requirements.  An endpoint MUST terminate an HTTP/2 connection that is
          opened on a TLS session that does not meet these minimum requirements with a <xref
          target="ConnectionErrorHandler">connection error</xref> of type
          <x:ref>INADEQUATE_SECURITY</x:ref>.

          由于实施的限制，不可能基于所有需求来使TLS协商失败。终端必须终止不符合TLS最小需求的TLS会话上建立的HTTP/2连接，并作为类型为INADEQUATE_SECURITY的连接错误处理。
        </t>
      </section>

      <section anchor="Compression" title="GZip Content-Encoding">
        <t>
          Clients MUST support gzip compression for HTTP response bodies.  Regardless of the value
          of the accept-encoding header field, a server MAY send responses with gzip or deflate
          encoding.  A compressed response MUST still bear an appropriate content-encoding header
          field.

          客户端必须支持HTTP响应体的Gzip压缩。不管接收白头字段的编码的值，服务端可以发送Gzip编码响应。一个压缩的响应还必须承担适当的内容编码报头字段。
        </t>
      </section>
    </section>

    <section anchor="security" title="Security Considerations">
      <section title="Server Authority" anchor="authority">
        <t>
          A client is only able to accept HTTP/2 responses from servers that are authoritative for
          those resources.  This is particularly important for <xref target="PushResources">server
          push</xref>, where the client validates the <x:ref>PUSH_PROMISE</x:ref> before accepting
          the response.

          客户端只有经过权限验证才能获取HTTP/2响应的资源。这在服务器推送中尤为重要，客户端在接收响应前验证PUSH_PROMISE帧。
        </t>
        <t>
          HTTP/2 relies on the HTTP/1.1 definition of authority for determining whether a server is
          authoritative in providing a given response, see <xref target="HTTP-p1" x:fmt=","
          x:rel="#establishing.authority"/>).  This relies on local name resolution for the "http"
          URI scheme, and the offered server identity for the "https" scheme (see <xref
          target="RFC2818" x:fmt="," x:sec="3"/>).

          HTTP/2依据HTTP/1.1权限定义来检测服务端是否有权限提供给定的响应，见xxx.这依赖于本地“HTTP”URI方案的域名解析，以及服务端提供的“https”方案验证。
        </t>
        <t>
          A client MUST NOT use, in any way, resources provided by a server that is not
          authoritative for those resources.

          客户端绝对不能以任何形式使用服务端提供的客户端没有权限的资源。
        </t>
      </section>

      /*****************************************************
        在跨协议攻击中，攻击者使客户端在一种协议中向解析另一种协议的服务器启动一个交易。攻击者可能能够使交易看起来在第二种协议中是合法的。结合对web上下文的利用，这个可以针对保护不力的服务器在秘密网络下进行互动。

        在ALPN验证下完成HTTP/2 TLS握手可以认为是足够的。ALPN提供了一个积极的指示说明服务器愿意处理HTTP/2,这有助于阻止基于TLS协议的攻击。

        TLS中的加密使得攻击者很难控制明文协议中能被用来进行跨协议攻击的数据。

        HTTP/2明文版本对于跨协议攻击具有最小的保护措施。连接序言(章节3.5)包含一个字符串，是用来迷惑HTTP/1.1服务器的，但是对于其他版本协议没有提供特殊保护。服务端愿意忽略包含升级字段的HTTP/1.1请求部分的可以认为是一次跨协议攻击。

        10.3 中介者封装攻击

        HTTP/2报头名称和值编码成带有长度前缀的字节序列。这使得HTTP/2能够携带任何字符串的字节作为报头字段的名称或值。中介端直接转换HTTP/2请求或响应到HTTP/1.1时可以允许HTTP/1.1消息创建的损坏。攻击者可以利用这个行为让中介端创建HTTP/1.1消息时带有非法报头字段、额外报头字段，甚至是完全伪造的新消息。

        报头字段名称或值带有不被HTTP/1.1允许的字符，包括回车(U+000D)或者换行(U+000A),绝对不能被中介端逐行解析，见[HTTP-p1]定义，章节3.2.4.


        从HTTP/1.x转换到HTTP/2不会被攻击者利用出现类似的情况。执行转换的中介端必须移除折叠obs的任何实例。

        10.4 推送响应的缓存

        推送响应并没有一个来自客户端的明确请求；请求是服务端从PUSH_PROMISE帧中提供的。

        缓存推送响应可能是基于原始服务器的缓存控制报头字段的指导。然而，如果服务端主机包含多个用户可能会导致问题。例如，服务端可能为多个用户每个提供小部分的URI空间。

        当多个用户共享同一台服务器时，该服务器必须确保用户不能推送没有权限使用的资源。如果不能确保这个将导致用户可能提供超出缓存以外的内容，覆盖用户实际有权限提供的内容。

        源服务器没有权限的(见10.1章节)推送响应将不会被缓存或者使用。

        10.5 拒绝服务的注意事项

        HTTP/2连接可以要求使用比HTTP/1.1连接更大的资源。报头压缩和流量控制的使用取决于承诺的资源存储更大量的状态。这些功能的设置确保这些承诺的内存是严格限制的。处理能力不能在相同的高速缓存中被守护。

        设置帧可能被滥用导致对等端花费额外的处理时间。这可能是毫无意义改变设置参数、设置多个未定义的参数，或者在同个帧中多次修改同个值。WINDOW_UPDATE 或 PRIORITY帧也可能被滥用导致资源的不必要的浪费。服务端可能在没有权限为客户端产生过量工作时错误地假定源服务器的ALTSVC帧。

        大量的小或空的值可能被滥用导致对等端花费额外的时间处理报头帧。但需要注意的是有些使用是完全合法的，例如发送空数据帧结束流。

        报头压缩也可能导致处理资源的浪费；见[COMPRESSION]查更多潜在滥用的细节。


        设置参数的限制不能瞬间降低，这使终端对对等端暴露的行为可能超出新的限制。特别是，连接连接后瞬间，服务端设置的限制并不被客户端知道，而且客户端可能在不明显违反协议的情况下超出限制。

        所有的这些功能，即设置的修改、小帧、报头压缩使用都是合法的。他们只有在不必要或者多余的使用时才会成为负担。

        终端不监测这种行为可能暴露其遭受拒绝服务攻击的风险。具体实现应当跟踪这些功能的使用并限制它们的使用。终端可以对待这些可疑的活动作为类型为ENHANCE_YOUR_CALM的连接错误处理。

        10.6 压缩的使用

        HTTP/2允许更大的使用报头字段(见4.3章节)和响应主体(见9.3章节)的压缩。压缩可以使攻击者在相同上下文数据压缩的攻击控制下恢复秘密数据。

        明文网络(例如[BREACH])下有针对压缩的明显攻击。攻击者诱导包含不同明文的多个请求，观察各个得到的密文的长度，当密码猜测是正确时就揭示了更短的长度。

        具体实现在一个安全通道通信时绝对不能压缩保密的和受攻击者控制的内容，除非对于各个数据源的压缩字典是不同的。绝对不能使用数据源可靠性不确定的压缩数据。

        关于报头uziduan压缩的更多表述参照[COMPRESSION]

        10.7 填充的使用

        HTTP/2的填充不打算作为通用填充的替换，如可能在TLS [TLS12]提供的。多余的填充可能会适得其反。正确的应用依靠的是对于填充的数据有具体的认知。

        为了减轻依靠压缩的攻击，禁用攻击可能是作为填充的最好对策。

        填充可以用来混淆帧内容的实际大小，而且减少HTTP中的特殊攻击。例如，压缩的内容包含攻击者控制的明文和秘密数据的攻击(见xxx)。

        使用填充可能导致比明显看起来的更少的保护。最好情况下，通过增加攻击者需要观察的帧的数量，填充能使得攻击者更难推断长度信息。但不正确的实现填充方案可能被轻松破解。特别是，带有可预测分布的随机填充提供保护非常小；或者填充的载荷是一个固定大小的公开信息做未来分布在固定大小的边界，这可能导致攻击者能控制明文的情况下破解。

        中介端不应该移除填充，但中介如果是想提高填充的保护可以移除填充添加不同数量的填充量。

        10.8 隐私注意事项

        HTTP/2的一些特点导致观察者有机会观察单个客户端或服务器的行为。这包含设置的值、流量控制窗口的管理方式、优先分配流的方法、反应时间以及任何可选功能的处理。

        至于这个可观察到的行为的差异，他们可以作为特定的客户端的指纹的基础，见《xxx》定义。

        11.1 HTTP/2识别字符串的注册

        这个文档在"应用层协议协商(ALPN)协议IDs"中的[TLSALPN]注册列表创建了两种HTTP/2标识符注册。

        使用TLS时“h2”字符串标识HTTP/2:

        协议: TLS上的HTTP/2
        标识序列 ： 0x68 0x32 ("h2")
        定义： 本文档(RFCXXX)

        "h2c"字符串标识使用明文TCP时的HTTP/2:

        协议： TCP上的HTTP/2
        标识序列： 0x68 0x32 0x63 ("h2c")
        定义： 本文档(RFCXXX)

        11.2 错误码注册

        本文档建立了HTTP/2错误码注册表。“HTTP/2错误码”注册表管理一个32位空间。“HTTP/2错误码”注册表操作在“专家评审”政策下[RFC5226]。

        错误码注册表必须包括错误码描述信息。专家评审建议检查新的注册可能复制现有的错误码信息。使用现有的错误码是被建议的，但没有规定。

        新的注册应提供以下信息：

        错误码：32位错误码值
        名称： 错误码名称。指定一个错误码的名称是可选的。
        描述： 描述错误码的适用条件
        规范： 定义错误码规范的可选参考。

        错误码等级初始表可以在第7章节中找到。

        11.3 HTTP2设置报头字段注册

        本章节注册永久消息报头字段注册[BCP90]中的HTTP2设置报头字段。

        报头字段名称： HTTP2-Settings
        应用层协议： http
        状态： 标准
        作者/修改操作者：LETF
        文档定义: 本文档3.2.1章节
        相关信息： 本字段只在HTTP/2客户端基于升级的协商中使用。

        11.4 PRI方法注册

        本章节注册HTTP方法注册[HTTP-p2]中的PRI方法。

        方法名称 ： PRI
        安全： 否
        幂等元 ： 否
        文档定义: 本文档3.5章节
        相关信息： 这个方法从不会被确切的客户端使用。该方法只在HTTP/1.1服务端或者中介端试图解析HTTP/2连接序言中使用。

       



      /*******************************************************



      <section title="Cross-Protocol Attacks">
        <t>
          When using TLS, we believe that HTTP/2 introduces no new cross-protocol attacks.  TLS
          encrypts the contents of all transmission (except the handshake itself), making it
          difficult for attackers to control the data which could be used in a cross-protocol
          attack.  <cref>Issue: This is no longer true</cref>
        </t>
      </section>

      <section title="Intermediary Encapsulation Attacks">
        <t>
          HTTP/2 header field names and values are encoded as sequences of octets with a length
          prefix.  This enables HTTP/2 to carry any string of octets as the name or value of a
          header field.  An intermediary that translates HTTP/2 requests or responses into HTTP/1.1
          directly could permit the creation of corrupted HTTP/1.1 messages.  An attacker might
          exploit this behavior to cause the intermediary to create HTTP/1.1 messages with illegal
          header fields, extra header fields, or even new messages that are entirely falsified.
        </t>
        <t>
          Header field names or values that contain characters not permitted by HTTP/1.1, including
          carriage return (U+000D) or line feed (U+000A) MUST NOT be translated verbatim by an
          intermediary, as stipulated in <xref target="HTTP-p1" x:rel="#field.parsing" x:fmt=","/>.
        </t>
        <t>
          Translation from HTTP/1.x to HTTP/2 does not produce the same opportunity to an attacker.
          Intermediaries that perform translation to HTTP/2 MUST remove any instances of the <spanx
          style="verb">obs-fold</spanx> production from header field values.
        </t>
      </section>

      <section title="Cacheability of Pushed Responses">
        <t>
          Pushed responses do not have an explicit request from the client; the request
          is provided by the server in the <x:ref>PUSH_PROMISE</x:ref> frame.
        </t>
        <t>
          Caching responses that are pushed is possible based on the guidance provided by the origin
          server in the Cache-Control header field.  However, this can cause issues if a single
          server hosts more than one tenant.  For example, a server might offer multiple users each
          a small portion of its URI space.
        </t>
        <t>
          Where multiple tenants share space on the same server, that server MUST ensure that
          tenants are not able to push representations of resources that they do not have authority
          over.  Failure to enforce this would allow a tenant to provide a representation that would
          be served out of cache, overriding the actual representation that the authoritative tenant
          provides.
        </t>
        <t>
          Pushed responses for which an origin server is not authoritative (see
          <xref target="authority"/>) are never cached or used.
        </t>
      </section>

      <section title="Denial of Service Considerations">
        <t>
          An HTTP/2 connection can demand a greater commitment of resources to operate than a
          HTTP/1.1 connection.  The use of header compression and flow control depend on a
          commitment of resources for storing a greater amount of state.  Settings for these
          features ensure that memory commitments for these features are strictly bounded.
          Processing capacity cannot be guarded in the same fashion.
        </t>
        <t>
          The <x:ref>SETTINGS</x:ref> frame can be abused to cause a peer to expend additional
          processing time. This might be done by pointlessly changing SETTINGS parameters, setting
          multiple undefined parameters, or changing the same setting multiple times in the same
          frame. Similarly, <x:ref>WINDOW_UPDATE</x:ref> or <x:ref>PRIORITY</x:ref> frames can be
          abused to cause an unnecessary waste of resources.
        </t>
        <t>
          Large numbers of small or empty frames can be abused to cause a peer to expend time
          processing frame headers.  Note however that some uses are entirely legitimate, such as
          the sending of an empty <x:ref>DATA</x:ref> frame to end a stream.
        </t>
        <t>
          Header compression also offers some opportunities to waste processing resources; see <xref
          target="COMPRESSION"/> for more details on potential abuses.
        </t>
        <t>
          Limits in <x:ref>SETTINGS</x:ref> parameters cannot be reduced instantaneously, which
          leaves an endpoint exposed to behavior from a peer that could exceed the new limits. In
          particular, immediately after establishing a connection, limits set by a server are not
          known to clients and could be exceeded without being an obvious protocol violation.
        </t>
        <t>
          All these features - i.e., <x:ref>SETTINGS</x:ref> changes, small frames, header
          compression - have legitimate usages.  These features become a burden only when they are
          used unnecessarily or to excess.
        </t>
        <t>
          An endpoint that doesn't monitor this behavior exposes itself to a risk of denial of
          service attack.  Implementations SHOULD track the use of these features and set limits on
          their use.  An endpoint MAY treat activity that is suspicious as a <xref
          target="ConnectionErrorHandler">connection error</xref> of type
          <x:ref>ENHANCE_YOUR_CALM</x:ref>.
        </t>
      </section>

      <section title="Use of Padding" anchor="padding">
        <t>
          Padding within HTTP/2 is not intended as a replacement for general purpose padding, such
          as might be provided by <xref target="TLS12">TLS</xref>.  Redundant padding could even be
          counterproductive.  Correct application can depend on having specific knowledge of the
          data that is being padded.
        </t>
        <t>
          To mitigate attacks that rely on compression, disabling compression might be preferable to
          padding as a countermeasure.
        </t>
        <t>
          Padding can be used to obscure the exact size of frame content, and is provided to
          mitigate specific attacks within HTTP.  For example, attacks where compressed content
          includes both attacker-controlled plaintext and secret data (see for example, <xref
          target="BREACH"/>).
        </t>
        <t>
          Use of padding can result in less protection than might seem immediately obvious.  At
          best, padding only makes it more difficult for an attacker to infer length information by
          increasing the number of frames an attacker has to observe.  Incorrectly implemented
          padding schemes can be easily defeated.  In particular, randomized padding with a
          predictable distribution provides very little protection; or padding payloads to a fixed
          size exposes information as payload sizes cross the fixed size boundary, which could be
          possible if an attacker can control plaintext.
        </t>
        <t>
          Intermediaries SHOULD NOT remove padding, though an intermediary MAY remove padding and
          add differing amounts if the intent is to improve the protections padding affords.
        </t>
      </section>

      <section title="Privacy Considerations">
        <t>
          Several characteristics of HTTP/2 provide an observer an opportunity to correlate actions
          of a single client or server over time.  This includes the value of settings, the manner
          in which flow control windows are managed, the way priorities are allocated to streams,
          timing of reactions to stimulus, and handling of any optional features.
        </t>
        <t>
          As far as this creates observable differences in behavior, they could be used as a basis
          for fingerprinting a specific client, as defined in <eref
          target="http://www.w3.org/TR/html5/introduction.html#fingerprint"/>.
        </t>
      </section>
   </section>

    <section anchor="iana" title="IANA Considerations">
      <t>
        A string for identifying HTTP/2 is entered into the "Application Layer Protocol Negotiation
        (ALPN) Protocol IDs" registry established in <xref target="TLSALPN"/>.
      </t>
      <t>
        This document establishes a registry for error codes.  This new registry is entered into a
        new "Hypertext Transfer Protocol (HTTP) 2 Parameters" section.
      </t>
      <t>
        This document registers the <spanx style="verb">HTTP2-Settings</spanx> header field for
        use in HTTP.
      </t>
      <t>
        This document registers the <spanx style="verb">PRI</spanx> method for use in HTTP, to avoid
        collisions with the <xref target="ConnectionHeader">connection preface</xref>.
      </t>

      <section anchor="iana-alpn" title="Registration of HTTP/2 Identification String">
        <t>
          This document creates a registration for the identification of HTTP/2 in the "Application
          Layer Protocol Negotiation (ALPN) Protocol IDs" registry established in <xref
          target="TLSALPN"/>.
          <list style="hanging">
            <t hangText="Protocol:">HTTP/2</t>
            <t hangText="Identification Sequence:"> 0x68 0x32
            ("h2")</t>
            <t hangText="Specification:">This document (RFCXXXX)</t>
          </list>
        </t>
      </section>

      <section title="Error Code Registry">
        <t>
          This document establishes a registry for HTTP/2 error codes.  The "HTTP/2 Error Code"
          registry manages a 32-bit space.  The "HTTP/2 Error Code" registry operates under the
          <xref target="RFC5226">"Expert Review" policy</xref>.
        </t>
        <t>
          Registrations for error codes are required to include a description of the error code.  An
          expert reviewer is advised to examine new registrations for possible duplication with
          existing error codes.  Use of existing registrations is to be encouraged, but not
          mandated.
        </t>
        <t>
          New registrations are advised to provide the following information:
          <list style="hanging">
            <t hangText="Error Code:">
              The 32-bit error code value.
            </t>
            <t hangText="Name:">
              A name for the error code.  Specifying an error code name is optional.
            </t>
            <t hangText="Description:">
              A description of the conditions where the error code is applicable.
            </t>
            <t hangText="Specification:">
              An optional reference for a specification that defines the error code.
            </t>
          </list>
        </t>
        <t>
          An initial set of error code registrations can be found in <xref target="ErrorCodes"/>.
        </t>
      </section>

      <section title="HTTP2-Settings Header Field Registration">
        <t>
          This section registers the <spanx style="verb">HTTP2-Settings</spanx> header field in the
          <xref target="BCP90">Permanent Message Header Field Registry</xref>.
          <list style="hanging">
            <t hangText="Header field name:">
              HTTP2-Settings
            </t>
            <t hangText="Applicable protocol:">
              http
            </t>
            <t hangText="Status:">
              standard
            </t>
            <t hangText="Author/Change controller:">
              IETF
            </t>
            <t hangText="Specification document(s):">
              <xref target="Http2SettingsHeader"/> of this document
            </t>
            <t hangText="Related information:">
              This header field is only used by an HTTP/2 client for Upgrade-based negotiation.
            </t>
          </list>
        </t>
      </section>

      <section title="PRI Method Registration">
        <t>
          This section registers the <spanx style="verb">PRI</spanx> method in the
          <xref target="HTTP-p2">HTTP Method Registry</xref>.
          <list style="hanging">
            <t hangText="Method Name:">
              PRI
            </t>
            <t hangText="Safe">
              No
            </t>
            <t hangText="Idempotent">
              No
            </t>
            <t hangText="Specification document(s)">
              <xref target="ConnectionHeader"/> of this document
            </t>
            <t hangText="Related information:">
              This method is never used by an actual client. This method will appear to be used
              when an HTTP/1.1 server or intermediary attempts to parse an HTTP/2 connection
              preface.
            </t>
          </list>
        </t>
      </section>
    </section>

    <section title="Acknowledgements">
      <t>
        This document includes substantial input from the following individuals:
        <list style="symbols">
          <t>
            Adam Langley, Wan-Teh Chang, Jim Morrison, Mark Nottingham, Alyssa Wilk, Costin
            Manolache, William Chan, Vitaliy Lvin, Joe Chan, Adam Barth, Ryan Hamilton, Gavin
            Peters, Kent Alstad, Kevin Lindsay, Paul Amer, Fan Yang, Jonathan Leighton (SPDY
            contributors).
          </t>
          <t>
            Gabriel Montenegro and Willy Tarreau (Upgrade mechanism).
          </t>
          <t>
            William Chan, Salvatore Loreto, Osama Mazahir, Gabriel Montenegro, Jitu Padhye, Roberto
            Peon, Rob Trace (Flow control).
          </t>
          <t>
            Mark Nottingham, Julian Reschke, James Snell, Jeff Pinner, Mike Bishop, Herve Ruellan
            (Substantial editorial contributions).
          </t>
          <t>
            Alexey Melnikov was an editor of this document during 2013.
          </t>
          <t>
            A substantial proportion of Martin's contribution was supported by Microsoft during his
            employment there.
          </t>
        </list>
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <reference anchor="COMPRESSION">
        <front>
          <title>HPACK - Header Compression for HTTP/2</title>
          <author initials="H." surname="Ruellan" fullname="Herve Ruellan"/>
          <author initials="R." surname="Peon" fullname="Roberto Peon"/>
          <date month="February" year="2014" />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-header-compression-06" />
      </reference>

      <reference anchor="TCP">
        <front>
          <title abbrev="Transmission Control Protocol">
            Transmission Control Protocol
          </title>
          <author initials="J." surname="Postel" fullname="Jon Postel">
            <organization>University of Southern California (USC)/Information Sciences
            Institute</organization>
          </author>
          <date year="1981" month="September" />
        </front>
        <seriesInfo name="STD" value="7" />
        <seriesInfo name="RFC" value="793" />
      </reference>

      <reference anchor="RFC2119">
        <front>
          <title>
            Key words for use in RFCs to Indicate Requirement Levels
          </title>
          <author initials="S." surname="Bradner" fullname="Scott Bradner">
            <organization>Harvard University</organization>
            <address><email>sob@harvard.edu</email></address>
          </author>
          <date month="March" year="1997"/>
        </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="2119"/>
      </reference>

     <reference anchor="RFC2818">
        <front>
          <title>
            HTTP Over TLS
          </title>
          <author initials="E." surname="Rescorla" fullname="Eric Rescorla"/>
          <date month="May" year="2000"/>
        </front>
        <seriesInfo name="RFC" value="2818"/>
      </reference>

      <reference anchor="UTF-8">
        <front>
          <title abbrev="UTF-8">UTF-8, a transformation format of ISO 10646</title>
          <author initials="F." surname="Yergeau" fullname="Francois Yergeau"/>
          <date year="2003" month="November" />
        </front>
        <seriesInfo name="STD" value="63" />
        <seriesInfo name="RFC" value="3629" />
      </reference>

      <reference anchor="RFC3986">
        <front>
          <title abbrev="URI Generic Syntax">Uniform Resource Identifier (URI): Generic
          Syntax</title>
          <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee"></author>
          <author initials="R." surname="Fielding" fullname="Roy T. Fielding"></author>
          <author initials="L." surname="Masinter" fullname="Larry Masinter"></author>
          <date year="2005" month="January" />
        </front>
        <seriesInfo name="STD" value="66" />
        <seriesInfo name="RFC" value="3986" />
      </reference>

      <reference anchor="RFC4648">
        <front>
          <title>The Base16, Base32, and Base64 Data Encodings</title>
          <author fullname="S. Josefsson" initials="S." surname="Josefsson"/>
          <date year="2006" month="October"/>
        </front>
        <seriesInfo value="4648" name="RFC"/>
      </reference>

      <reference anchor="RFC5226">
        <front>
          <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
          <author initials="T." surname="Narten" fullname="T. Narten"/>
          <author initials="H." surname="Alvestrand" fullname="H. Alvestrand"/>
          <date year="2008" month="May" />
        </front>
        <seriesInfo name="BCP" value="26" />
        <seriesInfo name="RFC" value="5226" />
      </reference>

      <reference anchor="RFC5234">
        <front>
          <title>Augmented BNF for Syntax Specifications: ABNF</title>
          <author initials="D." surname="Crocker" fullname="D. Crocker"/>
          <author initials="P." surname="Overell" fullname="P. Overell"/>
          <date year="2008" month="January" />
        </front>
        <seriesInfo name="STD" value="68" />
        <seriesInfo name="RFC" value="5234" />
      </reference>

      <reference anchor="TLS12">
        <front>
          <title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
          <author initials="T." surname="Dierks" fullname="Tim Dierks"/>
          <author initials="E." surname="Rescorla" fullname="Eric Rescorla"/>
          <date year="2008" month="August" />
        </front>
        <seriesInfo name="RFC" value="5246" />
      </reference>

      <reference anchor="TLS-EXT">
        <front>
          <title>
            Transport Layer Security (TLS) Extensions: Extension Definitions
          </title>
          <author initials="D." surname="Eastlake" fullname="D. Eastlake"/>
          <date year="2011" month="January"/>
        </front>
        <seriesInfo name="RFC" value="6066"/>
      </reference>

      <reference anchor="TLSALPN">
        <front>
          <title>Transport Layer Security (TLS) Application Layer Protocol Negotiation Extension</title>
          <author initials="S." surname="Friedl" fullname="Stephan Friedl"></author>
          <author initials="A." surname="Popov" fullname="Andrei Popov"></author>
          <author initials="A." surname="Langley" fullname="Adam Langley"></author>
          <author initials="E." surname="Stephan" fullname="Emile Stephan"></author>
          <date month="January" year="2014" />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-tls-applayerprotoneg-04" />
      </reference>

      <reference anchor="HTTP-p1">
        <front>
          <title>
          Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
          <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
            <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
            <address><email>fielding@gbiv.com</email></address>
          </author>
          <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
            <organization abbrev="greenbytes">greenbytes GmbH</organization>
            <address><email>julian.reschke@greenbytes.de</email></address>
          </author>
          <date month="February" year="2014" />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p1-messaging-26" />
        <x:source href="refs/draft-ietf-httpbis-p1-messaging-26.xml"
                  basename="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/26/p1-messaging"/>
      </reference>
      <reference anchor="HTTP-p2">
        <front>
          <title>
          Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
          <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
            <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
            <address><email>fielding@gbiv.com</email></address>
          </author>
          <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
            <organization abbrev="greenbytes">greenbytes GmbH</organization>
            <address><email>julian.reschke@greenbytes.de</email></address>
          </author>
          <date month="February" year="2014" />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p2-semantics-26" />
        <x:source href="refs/draft-ietf-httpbis-p2-semantics-26.xml"
                  basename="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/26/p2-semantics"/>
      </reference>
      <reference anchor="HTTP-p4">
        <front>
          <title>Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</title>
          <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
            <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
            <address><email>fielding@gbiv.com</email></address>
          </author>
          <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
            <organization abbrev="greenbytes">greenbytes GmbH</organization>
            <address><email>julian.reschke@greenbytes.de</email></address>
          </author>
          <date month="February" year="2014" />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p4-conditional-26" />
      </reference>
      <reference anchor="HTTP-p5">
        <front>
          <title>Hypertext Transfer Protocol (HTTP/1.1): Range Requests</title>
          <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
            <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
            <address><email>fielding@gbiv.com</email></address>
          </author>
          <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
            <organization abbrev="W3C">World Wide Web Consortium</organization>
            <address><email>ylafon@w3.org</email></address>
          </author>
          <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
            <organization abbrev="greenbytes">greenbytes GmbH</organization>
            <address><email>julian.reschke@greenbytes.de</email></address>
          </author>
          <date month="February" year="2014" />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p5-range-26"/>
      </reference>
      <reference anchor="HTTP-p6">
        <front>
          <title>Hypertext Transfer Protocol (HTTP/1.1): Caching</title>
          <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
            <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
            <address><email>fielding@gbiv.com</email></address>
          </author>
          <author fullname="Mark Nottingham" initials="M." role="editor" surname="Nottingham">
            <organization>Akamai</organization>
            <address><email>mnot@mnot.net</email></address>
          </author>
          <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
            <organization abbrev="greenbytes">greenbytes GmbH</organization>
            <address><email>julian.reschke@greenbytes.de</email></address>
          </author>
          <date month="February" year="2014" />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p6-cache-26"/>
        <x:source href="refs/draft-ietf-httpbis-p6-cache-26.xml"
                  basename="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/26/p6-cache"/>
      </reference>
      <reference anchor="HTTP-p7">
        <front>
          <title>Hypertext Transfer Protocol (HTTP/1.1): Authentication</title>
          <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
            <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
            <address><email>fielding@gbiv.com</email></address>
          </author>
          <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
            <organization abbrev="greenbytes">greenbytes GmbH</organization>
            <address><email>julian.reschke@greenbytes.de</email></address>
          </author>
          <date month="February" year="2014" />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p7-auth-26"/>
        <x:source href="refs/draft-ietf-httpbis-p7-auth-26.xml"
                  basename="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/26/p7-auth"/>
      </reference>

      <reference anchor="COOKIE">
        <front>
          <title>HTTP State Management Mechanism</title>
          <author initials="A." surname="Barth" fullname="A. Barth"/>
          <date year="2011" month="April" />
        </front>
        <seriesInfo name="RFC" value="6265" />
      </reference>

    </references>

    <references title="Informative References">
      <reference anchor="RFC1323">
        <front>
          <title>
            TCP Extensions for High Performance
          </title>
          <author initials="V." surname="Jacobson" fullname="Van Jacobson"></author>
          <author initials="B." surname="Braden" fullname="Bob Braden"></author>
          <author initials="D." surname="Borman" fullname="Dave Borman"></author>
          <date year="1992" month="May" />
        </front>
        <seriesInfo name="RFC" value="1323" />
      </reference>

      <reference anchor="RFC3749">
        <front>
          <title>Transport Layer Security Protocol Compression Methods</title>
          <author initials="S." surname="Hollenbeck" fullname="S. Hollenbeck"/>
          <date year="2004" month="May" />
        </front>
        <seriesInfo name="RFC" value="3749" />
      </reference>

      <reference anchor="TALKING" target="http://w2spconf.com/2011/papers/websocket.pdf">
        <front>
          <title>
            Talking to Yourself for Fun and Profit
          </title>
          <author initials="L-S." surname="Huang"/>
          <author initials="E." surname="Chen"/>
          <author initials="A." surname="Barth"/>
          <author initials="E." surname="Rescorla"/>
          <author initials="C." surname="Jackson"/>
          <date year="2011" />
        </front>
      </reference>

      <reference anchor="BREACH"
                 target="http://breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf">
        <front>
          <title>
            BREACH: Reviving the CRIME Attack
          </title>
          <author initials="Y." surname="Gluck"/>
          <author initials="N." surname="Harris"/>
          <author initials="A." surname="Prado"/>
          <date year="2013" month="July" day="12"/>
        </front>
      </reference>

      <reference anchor="RC4">
        <front>
          <title>
            The RC4 encryption algorithm
          </title>
          <author initials="R." surname="Rivest" fullname="Ron Rivest"></author>
          <date year="1992" month="March" />
        </front>
        <seriesInfo name="RSA Data Security, Inc." value="" />
      </reference>

      <reference anchor="BCP90">
        <front>
          <title>Registration Procedures for Message Header Fields</title>
          <author initials="G." surname="Klyne" fullname="G. Klyne">
            <organization>Nine by Nine</organization>
            <address><email>GK-IETF@ninebynine.org</email></address>
          </author>
          <author initials="M." surname="Nottingham" fullname="M. Nottingham">
            <organization>BEA Systems</organization>
            <address><email>mnot@pobox.com</email></address>
          </author>
          <author initials="J." surname="Mogul" fullname="J. Mogul">
            <organization>HP Labs</organization>
            <address><email>JeffMogul@acm.org</email></address>
          </author>
          <date year="2004" month="September" />
        </front>
        <seriesInfo name="BCP" value="90" />
        <seriesInfo name="RFC" value="3864" />
      </reference>

      <reference anchor="AltSvc">
        <front>
          <title>
            HTTP Alternate Services
          </title>
          <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
            <organization>Akamai</organization>
            <address><email>mnot@mnot.net</email></address>
          </author>
          <date year="2013" month="December"/>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-nottingham-httpbis-alt-svc-01"/>
      </reference>

      <reference anchor="TLSBCP">
        <front>
          <title>
            Recommendations for Secure Use of TLS and DTLS
          </title>
          <author initials="Y." surname="Sheffer" fullname="Yaron Sheffer">
            <organization>Porticor</organization>
            <address><email>yaronf.ietf@gmail.com</email></address>
          </author>
          <author initials="R." surname="Holz" fullname="Ralph Holz">
            <organization>Technische Universitaet Muenchen</organization>
            <address><email>holz@net.in.tum.de</email></address>
          </author>
          <date year="2013" month="September"/>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-sheffer-tls-bcp-01"/>
      </reference>
    </references>

    <section title="Change Log (to be removed by RFC Editor before publication)" anchor="change.log">

      <section title="Since draft-ietf-httpbis-http2-10" anchor="changes.since.draft-ietf-httpbis-http2-10">
        <t>
          Changed "connection header" to "connection preface" to avoid confusion.
        </t>
      </section>

      <section title="Since draft-ietf-httpbis-http2-09" anchor="changes.since.draft-ietf-httpbis-http2-09">
        <t>
          Adding padding for data frames.
        </t>
        <t>
          Renumbering frame types, error codes, and settings.
        </t>
        <t>
          Adding INADEQUATE_SECURITY error code.
        </t>
        <t>
          Updating TLS usage requirements to 1.2; forbidding TLS compression.
        </t>
        <t>
          Removing extensibility for frames and settings.
        </t>
        <t>
          Changing setting identifier size.
        </t>
        <t>
          Removing the ability to disable flow control.
        </t>
        <t>
          Changing the protocol identification token to "h2".
        </t>
        <t>
          Changing the use of :authority to make it optional and to allow userinfo in non-HTTP
          cases.
        </t>
        <t>
          Allowing split on 0x0 for Cookie.
        </t>
        <t>
          Reserved PRI method in HTTP/1.1 to avoid possible future collisions.
        </t>
      </section>

      <section title="Since draft-ietf-httpbis-http2-08" anchor="changes.since.draft-ietf-httpbis-http2-08">
        <t>
          Added cookie crumbling for more efficient header compression.
        </t>
        <t>
          Added header field ordering with the value-concatenation mechanism.
        </t>
      </section>

      <section title="Since draft-ietf-httpbis-http2-07" anchor="changes.since.draft-ietf-httpbis-http2-07">
        <t>
          Marked draft for implementation.
        </t>
      </section>

      <section title="Since draft-ietf-httpbis-http2-06" anchor="changes.since.draft-ietf-httpbis-http2-06">
        <t>
          Adding definition for CONNECT method.
        </t>
        <t>
          Constraining the use of push to safe, cacheable methods with no request body.
        </t>
        <t>
          Changing from :host to :authority to remove any potential confusion.
        </t>
        <t>
          Adding setting for header compression table size.
        </t>
        <t>
          Adding settings acknowledgement.
        </t>
        <t>
          Removing unnecessary and potentially problematic flags from CONTINUATION.
        </t>
        <t>
          Added denial of service considerations.
        </t>
      </section>
      <section title="Since draft-ietf-httpbis-http2-05" anchor="changes.since.draft-ietf-httpbis-http2-05">
        <t>
          Marking the draft ready for implementation.
        </t>
        <t>
          Renumbering END_PUSH_PROMISE flag.
        </t>
        <t>
          Editorial clarifications and changes.
        </t>
      </section>

      <section title="Since draft-ietf-httpbis-http2-04" anchor="changes.since.draft-ietf-httpbis-http2-04">
        <t>
          Added CONTINUATION frame for HEADERS and PUSH_PROMISE.
        </t>
        <t>
          PUSH_PROMISE is no longer implicitly prohibited if SETTINGS_MAX_CONCURRENT_STREAMS is
          zero.
        </t>
        <t>
          Push expanded to allow all safe methods without a request body.
        </t>
        <t>
          Clarified the use of HTTP header fields in requests and responses.  Prohibited HTTP/1.1
          hop-by-hop header fields.
        </t>
        <t>
          Requiring that intermediaries not forward requests with missing or illegal routing
          :-headers.
        </t>
        <t>
          Clarified requirements around handling different frames after stream close, stream reset
          and <x:ref>GOAWAY</x:ref>.
        </t>
        <t>
          Added more specific prohibitions for sending of different frame types in various stream
          states.
        </t>
        <t>
          Making the last received setting value the effective value.
        </t>
        <t>
          Clarified requirements on TLS version, extension and ciphers.
        </t>
      </section>

      <section title="Since draft-ietf-httpbis-http2-03" anchor="changes.since.draft-ietf-httpbis-http2-03">
        <t>
          Committed major restructuring atrocities.
        </t>
        <t>
          Added reference to first header compression draft.
        </t>
        <t>
          Added more formal description of frame lifecycle.
        </t>
        <t>
          Moved END_STREAM (renamed from FINAL) back to <x:ref>HEADERS</x:ref>/<x:ref>DATA</x:ref>.
        </t>
        <t>
          Removed HEADERS+PRIORITY, added optional priority to <x:ref>HEADERS</x:ref> frame.
        </t>
        <t>
          Added <x:ref>PRIORITY</x:ref> frame.
        </t>
      </section>

      <section title="Since draft-ietf-httpbis-http2-02" anchor="changes.since.draft-ietf-httpbis-http2-02">
        <t>
          Added continuations to frames carrying header blocks.
        </t>
        <t>
          Replaced use of "session" with "connection" to avoid confusion with other HTTP stateful
          concepts, like cookies.
        </t>
        <t>
          Removed "message".
        </t>
        <t>
          Switched to TLS ALPN from NPN.
        </t>
        <t>
          Editorial changes.
        </t>
      </section>

      <section title="Since draft-ietf-httpbis-http2-01" anchor="changes.since.draft-ietf-httpbis-http2-01">
        <t>
          Added IANA considerations section for frame types, error codes and settings.
        </t>
        <t>
          Removed data frame compression.
        </t>
        <t>
          Added <x:ref>PUSH_PROMISE</x:ref>.
        </t>
        <t>
          Added globally applicable flags to framing.
        </t>
        <t>
          Removed zlib-based header compression mechanism.
        </t>
        <t>
          Updated references.
        </t>
        <t>
          Clarified stream identifier reuse.
        </t>
        <t>
          Removed CREDENTIALS frame and associated mechanisms.
        </t>
        <t>
          Added advice against naive implementation of flow control.
        </t>
        <t>
          Added session header section.
        </t>
        <t>
          Restructured frame header.  Removed distinction between data and control frames.
        </t>
        <t>
          Altered flow control properties to include session-level limits.
        </t>
        <t>
          Added note on cacheability of pushed resources and multiple tenant servers.
        </t>
        <t>
          Changed protocol label form based on discussions.
        </t>
      </section>

      <section title="Since draft-ietf-httpbis-http2-00" anchor="changes.since.draft-ietf-httpbis-http2-00">
        <t>
          Changed title throughout.
        </t>
        <t>
          Removed section on Incompatibilities with SPDY draft#2.
        </t>
        <t>
          Changed <x:ref>INTERNAL_ERROR</x:ref> on <x:ref>GOAWAY</x:ref> to have a value of 2 <eref
          target="https://groups.google.com/forum/?fromgroups#!topic/spdy-dev/cfUef2gL3iU"/>.
        </t>
        <t>
          Replaced abstract and introduction.
        </t>
        <t>
          Added section on starting HTTP/2.0, including upgrade mechanism.
        </t>
        <t>
          Removed unused references.
        </t>
        <t>
          Added <xref target="fc-principles">flow control principles</xref> based on <eref
          target="http://tools.ietf.org/html/draft-montenegro-httpbis-http2-fc-principles-01"/>.
        </t>
      </section>

      <section title="Since draft-mbelshe-httpbis-spdy-00" anchor="changes.since.draft-mbelshe-httpbis-spdy-00">
        <t>
          Adopted as base for draft-ietf-httpbis-http2.
        </t>
        <t>
          Updated authors/editors list.
        </t>
        <t>
          Added status note.
        </t>
      </section>
    </section>

  </back>
</rfc>
<!--
  vim:et:tw=100:sw=2:
  -->
